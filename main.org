#+title: Personal Dotfiles
#+author: Junyi Hou
#+property: header-args:emacs-lisp :tangle ./emacs.d/init.el :mkdirp yes
#+property: header-args:nix :mkdirp yes
#+startup: show3levels
#+options: toc:3

* Overview

** Repository Structure

* ~home-manager~ Initialization

#+begin_src nix :tangle home.nix :noweb yes
  { pkgs, lib, config, ... }:

  let
    user = builtins.getEnv "USER";
    realUser = "Junyi Hou";
    homeDir = builtins.getEnv "HOME";
    mailDir = ''${homeDir}/.mail'';
    lispDir = ''${homeDir}/.emacs.d/site-lisp'';
    projectDir = ''${homeDir}/projects'';
    researchDir = ''${homeDir}/research'';
  in

  {
    programs.home-manager.enable = true;

    home = {
      stateVersion = "21.03";
      username = user;
      homeDirectory = homeDir;
      sessionVariables = {
        NIX_PATH = ''$HOME/.nix-defexpr/channels''${NIX_PATH:+:}$NIX_PATH'';
      };
      activation = {
        createProjectDir = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
          $DRY_RUN_CMD mkdir -p ${projectDir}
        '';
        createResearchDir = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
          $DRY_RUN_CMD mkdir -p ${researchDir}
        '';
      };
    };

    <<home-manager>>
  }
#+end_src

* Cache Support

#+begin_src nix :noweb-ref home-manager
  imports = [
    (
      let
        declCachix = builtins.fetchTarball "https://github.com/jonascarpay/declarative-cachix/archive/master.tar.gz";
      in
        import "${declCachix}/home-manager.nix"
    )
  ];

  caches.cachix = [
    { name = "nix-community"; }
  ];

  home.file = {
    nixConf.text = ''
      experimental-features = nix-command flakes
      keep-derivations = true
      keep-outputs = true
    '';
  };
#+end_src

* System-specific Settings

~home-manager~ cannot manage display sessions (or X-sessions). This is fair as ~home-manager~ should not be use to install systemwide package and start system services. Instead, I use system package manager (~pacman~ in my case) to install relevant packages and services. On Linux/GNU system, the list of packages I installed with ~pacman~ includes

+ display services (~wayland~, ~sway~)
+ notification services (~libnotify~, ~mako~)
+ fonts
+ network services (~networkmanager~, ~bluez~)

Notwithstanding this shortcoming, ~home-manager~ can still be used to manage their configuration files, which I include below.

#+begin_src nix :noweb-ref (if (eq system-type 'gnu/linux) "home-manager" "nowave") :noweb yes
    home = {
      file = {
        ".config/fontconfig" = {
          source = ./linux/fontconfig;
          recursive = true;
        };
        ".config/sway/config".source = ./linux/sway;
        ".config/sway/wallpaper.jpg".source = ./linux/wallpaper.jpg;
        ".config/waybar/config".source = ./linux/waybar;
        ".config/waybar/style.css".source = ./linux/waybar-style;
      };
    };

    fonts.fontconfig.enable = true;

    <<linux-setup>>
#+end_src

I will also need to put ~/usr/bin~ back to my ~$PATH~ in order to use system packages (e.g., ~sway~).

#+begin_src nix :noweb linux-setup
  home.sessionPath = [ "/usr/bin" ];
#+end_src

In addition, I include some Linux-wayland specific packages.

#+begin_src nix :noweb linux-setup
  home.packages = with pkgs; [
    bemenu
    havoc # terminal
  ];

  home.file".config/havoc.cfg" = {
    text = ''
      [child]
      program=bash
      [font]
      size=25
      [bind]
      C-S-c=copy
      C-S-v=paste
    '';
  };
#+end_src

On MacOS system, those components are builtin, and I don't need to worry about it.

*  ~emacs~ Configuration

This section contains the code and explanation of my personal configuration for ~emacs~ editor. This configuration is meant to be used with the native comp branch and a running emacs server (with ~server-start~).

In lieu of a proper namespace, I prefix all custom functions, variables with ~gatsby:~, which is the name of my dog.

** The Main ~emacs~ Package

#+begin_src nix :noweb-ref home-manager
  nixpkgs.overlays = [
    (import (builtins.fetchTarball {
      url = https://github.com/nix-community/emacs-overlay/archive/a1c89c95cf659512f72f6ec51c764c03801f890d.tar.gz;
    }))
  ];

  programs.emacs = {
    enable = true;
    package = pkgs.emacsPgtkGcc;
  };

  home = {
    file.".emacs.d" = {
      source = ./emacs.d;
      recursive = true;
    };
    sessionVariables = {
      EDITOR = "emacsclient -c";
      VISUAL = "emacsclient -c";
    };
  };

  services.emacs = {
    enable = true;
    client.enable = true;
  };
#+end_src

** Lexical Binding

First, make sure that the init file is lexcially bind.

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-
#+end_src

** Opinionated Defaults

~emacs~ has a long history. Some of the default values it inherits do not make sense in a modern desktop/laptop, others are incompatible with my personal preference. This section overrides many default settings to provide, in my opinion, a more sensible default.

*** garbage collection

~emacs~ has a rather low limit for garbage collection. With larger memories in modern computers we can be more liberal with how many memories ~emacs~ is allow to use, especially when initializing.

#+begin_src emacs-lisp
  (setq gc-cons-threshold most-positive-fixnum)
#+end_src

Later in the configuration, I will loan ~gcmh~ package that provide a more nuanced garbage collection management.

*** message buffer size

~emacs~ collects messages in the ~*Message*~ buffer. If it runs for a long time, this buffer can get large and slow down any attempts to use this buffer. I limit the max size of this buffer to prevent this from happening.

#+begin_src emacs-lisp
  (setq message-log-max 10000)
#+end_src

*** bells

Bells and unnecessary notifications are annoying, turn them off.

#+begin_src emacs-lisp
  (setq visible-bell t
        ring-bell-function 'ignore
        server-client-instructions nil)
#+end_src

*** mini-window size

mini-window is a window at the bottom of the screen. It is used to display messages and errors. If the message it tries to display is longer than one line, it will grow and eat into the space displaying normal windows. This behavior can be annoying because it changes the absolute pixel position of what I focus on in the normal window(s). I limit its max height to just 1 line so it won't mess up the window layout. By using ~eldoc-box~ package I can display messages longer than one line in a childframe, so there is not really any down side of setting this limit.

#+begin_src emacs-lisp
  (setq max-mini-window-height 1)
#+end_src

*** replace yes-or-no-p

Sometimes, ~emacs~ asks me for a yes/no answer. But instead of typing "yes" or "no", I can simply use "y" or "n" to answer those questions.

#+begin_src emacs-lisp
  (if (boundp 'use-short-answers)
      (setq use-short-answers t)
    (defalias 'yes-or-no-p 'y-or-n-p))
#+end_src

*** unkillable ~*scratch*~

~*scratch*~ buffer comes in handy when I want to experiment some small functions. Here I make it "unkillable" so I would not accidentally kill it and have to re-create it myself.

#+begin_src emacs-lisp
  (defun gatsby:core--unkillable-scratch ()
    (if (string= (buffer-name (current-buffer)) "*scratch*")
        (progn
          (delete-region (point-min) (point-max))
          (insert initial-scratch-message)
          nil)
      t))

  (add-hook 'kill-buffer-query-functions #'gatsby:core--unkillable-scratch)
#+end_src

*** unkillable ~*Messages*~

~*Messages*~ buffer holds valuable information. Although ~emacs~ will recreate a ~*Messages*~ buffer as soon as the existing one gets killed, the new buffer will be empty and the existing information will loss. I want to redirect ~kill-buffer~ to simply delete the message window instead of killing it.

#+begin_src emacs-lisp
  (defun gatsby:core--unkillable-message ()
    (if (string= (buffer-name (current-buffer)) "*Messages*")
        (progn
          (delete-window (get-buffer-window "*Messages*"))
          nil)
      t))

  (add-hook 'kill-buffer-query-functions #'gatsby:core--unkillable-message)
#+end_src

*** no useless GUI

One of the key advantage of ~emacs~ over other editors like ~vs-code~ and ~sublime-text~ is its focus on keyboard. Here I disable some GUI elements that are designed for interaction using the mouse to save some spaces for displaying code/text instead.

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (horizontal-scroll-bar-mode -1)
  (blink-cursor-mode -1)
#+end_src

*** split window rule

#+begin_src emacs-lisp
  (defun gatsby:core--split-vertical (window)
    "Return t if should split WINDOW vertically, otherwise return nil."
    (let* ((h (window-total-height window))
           (w (window-total-width window))
           (ratio (/ (float h) w)))
      (cond
       ((< ratio 0.15) t)
       ((< (/ (float w) 2) 90) nil)
       (t t))))

  (defun gatsby:core-split-window (&optional window)
    "Split WINDOW side-by-side, if WINDOW width < 90, split it top-and-down."
    (let ((window (or window (selected-window))))
      (if (gatsby:core--split-vertical window)
          (split-window-right)
        (split-window-below))))

  (setq split-window-preferred-function 'gatsby:core-split-window)
#+end_src

*** smooth scrolling

#+begin_src emacs-lisp
  (setq scroll-step 1)
#+end_src

** Package Manager

I use ~straight.el~ as my main ~emacs~ package manager. The key advantage of ~straight.el~ over other managers (e.g., the builtin ~package.el~ and ~quelpa.el~) is its reproducibility. For someone who often rebuild ~emacs~ and my ~.emacs.d~ for various reasons like me, reproducibility is a big plus. Other minor advantages of ~straight.el~ includes the ability to install packages from github (or any other git repository). Here I simply bootstrap ~straight.el~ following its [[https://github.com/raxod502/straight.el#getting-started][document]].

#+begin_src emacs-lisp
  (setq straight-repository-branch "develop"
        straight-use-package-by-default t
        straight-vc-git-default-protocol 'https)

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'use-package)
#+end_src

** Core Packages

*** Libraries

~dash.el~, ~f.el~, ~s.el~ provides haskell-like libraries to list, file and string manipulations. They may not be more efficient than the builtin ~seq.el~, ~file.el~ and ~string.el~, but they offer a consistent interface for almost all functions.

#+begin_src emacs-lisp
  (use-package dash)
  (use-package f)
  (use-package s)
#+end_src

*** garbage collector magic hack (gcmh)

~gcmh~ is a great package that is trying to be smart about when to run garbage collection. Essentially, it sets a large enough threshold during normal use, and trigger garbage collection only when ~emacs~ is idle.

#+begin_src emacs-lisp
  (use-package gcmh :demand t)
#+end_src

I set the ~gc-threshold~ to 32MB, which is suggested by [[https://github.com/hlissner/doom-emacs/issues/3108][hlissner himself]].

#+begin_src emacs-lisp
  (setq gcmh-high-cons-threshold 33554432)
#+end_src

Finally, I reset the ~gc-cons-threshold~ back when the emacs initialization is
finished.

#+begin_src emacs-lisp
  (defun gatsby:core--reset-gc ()
    (setq gc-cons-threshold 25165824))

  (add-hook 'after-init-hook #'gatsby:core--reset-gc)
#+end_src

Now enable ~gcmh~ mode.

#+begin_src emacs-lisp
  (gcmh-mode 1)
#+end_src

*** general

~general.el~ provides a uniform interface of defining and removing keybindings. In particular, it is evil-friendly, which makes my life very easy.

#+begin_src emacs-lisp
  (use-package general :demand t)
#+end_src

I use ~general.el~ mostly through its ~use-package~ keyword ~:general~. A drawback of this method is it messes up the builtin ~lisp~ indentation (see [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned][this question]] on stackexchange for more information). Here I override the original indent function in ~emacs-lisp-mode~ to fix this issue.

#+begin_src emacs-lisp
  (defun gatsby:lisp--fix-indent ()
    (setq-local lisp-indent-function #'gatsby:lisp-indent-function))

  (defun gatsby:lisp-indent-function (indent-point state)
    (let ((normal-indent (current-column))
          (orig-point (point)))
      (goto-char (1+ (elt state 1)))
      (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
      (cond
       ;; car of form doesn't seem to be a symbol, or is a keyword
       ((and (elt state 2)
             (or (not (looking-at "\\sw\\|\\s_"))
                 (looking-at ":")))
        (if (not (> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp))
            (progn (goto-char calculate-lisp-indent-last-sexp)
                   (beginning-of-line)
                   (parse-partial-sexp (point)
                                       calculate-lisp-indent-last-sexp 0 t)))
        ;; Indent under the list or under the first sexp on the same
        ;; line as calculate-lisp-indent-last-sexp.  Note that first
        ;; thing on that line has to be complete sexp since we are
        ;; inside the innermost containing sexp.
        (backward-prefix-chars)
        (current-column))
       ((and (save-excursion
               (goto-char indent-point)
               (skip-syntax-forward " ")
               (not (looking-at ":")))
             (save-excursion
               (goto-char orig-point)
               (looking-at ":")))
        (save-excursion
          (goto-char (+ 2 (elt state 1)))
          (current-column)))
       (t
        (let ((function (buffer-substring (point)
                                          (progn (forward-sexp 1) (point))))
              method)
          (setq method (or (function-get (intern-soft function)
                                         'lisp-indent-function)
                           (get (intern-soft function) 'lisp-indent-hook)))
          (cond ((or (eq method 'defun)
                     (and (null method)
                          (> (length function) 3)
                          (string-match "\\`def" function)))
                 (lisp-indent-defform state indent-point))
                ((integerp method)
                 (lisp-indent-specform method state
                                       indent-point normal-indent))
                (method
                 (funcall method indent-point state))))))))

  (add-hook 'emacs-lisp-mode-hook #'gatsby:lisp--fix-indent)
#+end_src

*** no-littering

~no-littering~ regularizes how other emacs packages saves config/temp files, so the ~~/.emacs.d/~ folder is clean and organized.

#+begin_src emacs-lisp
  (use-package no-littering)

  (setq auto-save-file-name-transforms  `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))
        backup-directory-alist `((".*" . ,(no-littering-expand-var-file-name "backup/")))
        custom-file (no-littering-expand-etc-file-name "custom.el"))

  (load custom-file 'noerror)
#+end_src

*** saveplace

~saveplace~ is a builtin package that records and restores the cursor position when closing files. This is helpful to pick up any works left last time.

#+begin_src emacs-lisp
  (use-package saveplace :straight (:type built-in) :hook (after-init . save-place-mode))

  (setq save-place-file (expand-file-name "save-place.el" no-littering-var-directory))
#+end_src

*** paren

It is always helpful to know where the pairing deliminator is when editing files, especially for ~lisp~ which is known to be liberal with the use of parentheses. ~paren~ is a package that highlights the pairing parenthesis/deliminator when the cursor is on a paren/deliminator.

#+begin_src emacs-lisp
  (use-package paren :hook (after-init . show-paren-mode))
#+end_src

*** subword

~subword~ makes it easy to edit carmalWords by recognizing word boundaries in carmalWords.

#+begin_src emacs-lisp
  (use-package subword :hook (after-init . global-subword-mode))
#+end_src

*** simple

~simple~ is a builtin package offering a variety of small useful tricks. I use two of them: ~visual-line-mode~ which breaks long lines visually (into "visual lines") for ease of read/edit. ~auto-fill-mode~ which automatically breaks long single-line comments into multi-line comments for better aestheticity.

#+begin_src emacs-lisp
  (use-package simple :straight (:type built-in))
#+end_src

**** visual-line-mode

~visual-line-mode~ turns lines longer than the window width into "visual lines" without actually breaking them. I enable ~visual-line-mode~ globally right after ~emacs~ is initialized.

#+begin_src emacs-lisp
  (add-hook 'after-init-hook #'global-visual-line-mode)
#+end_src

Alongside with the builtin ~visual-line-mode~, there is also ~visual-fill-column-mode~ that applies the visual break at ~fill-column~ instead of the window edge.

Before loading the package, I set ~visual-fill-column-inhibit-sensible-window-split~ to ~t~ to prevent ~visual-fill-column-mode~ to change the ~split-window-preferred-function~ I set in [[split window rule]].

#+begin_src emacs-lisp
  (setq visual-fill-column-inhibit-sensible-window-split t)
  (use-package visual-fill-column)
#+end_src

I turn on ~visual-fill-column-mode~ only for ~text-mode~, while using the builtin ~auto-fill-mode~ for ~prog-mode~, as the latter can be configured to hard-wrap only the comments, not the actual code.

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook #'visual-fill-column-mode)
#+end_src

**** auto-fill-mode

~auto-fill-mode~ is a little bit tricky. On the one hand, I do not want it to mess up with my code formatting. For that, I can set ~comment-auto-fill-only-comments~ to non-nil to prevent ~auto-fill~ to wrap code.

#+begin_src emacs-lisp
  (setq comment-auto-fill-only-comments t)
  (add-hook 'prog-mode-hook #'auto-fill-mode)
#+end_src

I set the auto fill column uniformly to 80.

#+begin_src emacs-lisp
  (setq-default fill-column 80)
  (setq fill-column 80)
#+end_src

**** messages-buffer-mode

The normal ~messages-buffer-mode~ binding will be shadowed by the evil mode. Therefore, I need to restore it:

#+begin_src emacs-lisp
  (general-define-key :keymaps 'messages-buffer-mode-map :states 'normal
    "q" #'delete-window)
#+end_src

*** whitespace

~whitespace~ automatically clean them up when saving the file.

#+begin_src emacs-lisp
  (use-package whitespace :straight (:type built-in) :hook (before-save . whitespace-cleanup))
#+end_src

*** autorevert

~autorevert~ automatically update opened files when the file is changed by other processes to make sure that I always get the most up-to-date version of the file.

#+begin_src emacs-lisp
  (use-package autorevert :hook (after-init . global-auto-revert-mode))
#+end_src

*** alert

~alert.el~ allow ~emacs~ use the system notification popups to show information. It requires ~libnotify~ and a notification frontend (I use ~mako~ on wayland) gnu/linux system. On macOS system, it uses the builtin ~osx-notifier~, which does not have extra dependency.

#+begin_src emacs-lisp
  (use-package alert :commands alert)
#+end_src

~alert~ allows different methods of displaying alerts. As mentioned above, I need to setup ~alert~ to use the system notifier as default.

#+begin_src emacs-lisp
  (setq alert-default-style (if (eq system-type 'gnu/linux) 'libnotify 'osx-notifier))
#+end_src

I also want the notification to last long enough for me to at least read it.

#+begin_src emacs-lisp
  (setq alert-fade-time 60)
#+end_src

** Theme

The stock ~emacs~ looks horrible. This section concerns mainly the aesthetics.

*** package

I like the color theme to provide enough visual cue (to read code) but not too colorful and distracting. ~lab-theme~ provide just the right balance for me.

#+begin_src emacs-lisp
  (use-package lab-themes)
  (setq custom-safe-themes t)
  (lab-themes-load-style 'dark)
#+end_src

*** fringe bitmaps

The stock ~emacs~ has various visual indicators at the fringe for line continuation/truncation/... I want to reserve the fringe for syntax checker. So I disable those indicators.

#+begin_src emacs-lisp
  (setq-default fringe-indicator-alist
                '((continuation nil nil)
                  (truncation nil nil)
                  (overlay-arrow . nil)
                  (up . nil)
                  (down . nil)
                  (top nil nil)
                  (bottom nil nil nil nil)
                  (top-bottom nil nil nil nil)
                  (empty-line . nil)
                  (unknown . nil)))
#+end_src

*** mode-line

Since I want a minimalistic mode-line which displays only one of two essential pieces of information, I customize the mode line information myself instead of using a mode-line package.

In addition to the builtin segments, I need the following segments:

+ evil state info ([[evil mode-line indicator]])
+ git branch and repo info
+ new slack messages
+ new unread mails ([[email client]])
+ envrc info ([[Local Environment]])

I defer configuring evil state, slack, mail and envrc segments when I load those packages. The configuration can be done by inserting segments to ~gatsby:right-mode-line~.

#+begin_src emacs-lisp
  (defvar gatsby:right-mode-line '((:eval (gatsby:mode-line-vc-info)) mode-name))

  (defun gatsby:format-right-mode-line ()
    (format-mode-line gatsby:right-mode-line))

  (defun gatsby:mode-line-vc-info ()
    (if (and vc-mode buffer-file-name)
        (let* ((backend (vc-backend buffer-file-name))
               (repo (file-name-nondirectory (directory-file-name (vc-root-dir))))
               (state (vc-state buffer-file-name backend))
               (str (format "%s:%s "
                            repo
                            (substring vc-mode (+ (if (eq backend 'Hg) 2 3) 2)))))
          (propertize (if (> (length str) 15)
                          (concat
                           (substring str 0 (- 15 3))
                           "...")
                        str)
                      'mouse-face 'mode-line-highlight))
      ""))

  (defun gatsby:mode-line-maybe-shorten-buffer-name ()
    "Shorten the buffer name if it is too long, otherwise return the original buffer name string."
    (if-let* ((buf-name (buffer-name))
              (str-len (length buf-name))
              (_ (> str-len 50)))
        (format "%s...%s"
                (substring buf-name 0 10)
                (substring buf-name (- str-len 37) str-len))
      buf-name))

  (setq mode-line-format
        (list mode-line-mule-info
              mode-line-modified
              mode-line-remote " "
              "%[" '(:eval (gatsby:mode-line-maybe-shorten-buffer-name)) "%]"
              '(:eval (propertize
                       " " 'display
                       `((space :align-to (- (+ right right-fringe right-margin)
                                             ,(+ 3 (string-width (gatsby:format-right-mode-line))))))))
              '(:eval (gatsby:format-right-mode-line))))

  (setq-default mode-line-format
                (list mode-line-mule-info
                      mode-line-modified
                      mode-line-remote " "
                      "%[" '(:eval (gatsby:mode-line-maybe-shorten-buffer-name)) "%]"
                      '(:eval (propertize
                               " " 'display
                               `((space :align-to (- (+ right right-fringe right-margin)
                                                     ,(+ 3 (string-width (gatsby:format-right-mode-line))))))))
                      '(:eval (gatsby:format-right-mode-line))))
#+end_src

*** font size

I use a resolution-based scale method to determine font size. Specifically, I first define a base font size (in ~gatsby:base-font-size~) for a 1080p monitor. The actual font size is determined by the resolution of the monitor at the time of creating frame. For example, if a frame is made on a 1440p monitor, then the actual font size will be 180 (= 135 * 1440/1080).

#+begin_src emacs-lisp
  (defconst gatsby:base-font-size 135 "The base level of font size.")

  (set-face-attribute
   'default nil
   :family "monospace"
   :width 'normal
   :weight 'Light)

  (defun gatsby:theme-fontsize-up (&optional size)
    "Increase the font size in the current frame by SIZE.  If SIZE is nil, default to 5."
    (interactive)
    (let* ((current-size (plist-get (custom-face-attributes-get 'default nil) :height))
           (new-size (+ (or size 5) current-size)))
      (set-face-attribute
       'default (selected-frame)
       :height new-size)))

  (defun gatsby:theme-fontsize-down (&optional size)
    "Decrease the font size in the current frame by SIZE.  If SIZE is nil, default to 5."
    (interactive)
    (let* ((current-size (plist-get (custom-face-attributes-get 'default nil) :height))
           (new-size (- current-size (or size 5))))
      (set-face-attribute
       'default (selected-frame)
       :height new-size)))

  (defun gatsby:theme--determine-font-size (frame)
    "Determine the fontsize by looking at `x-display-pixel-height'."
    (set-face-attribute
     'default frame
     :height (round (* gatsby:base-font-size (/ (x-display-pixel-height) 1080.0)))))

  (add-to-list 'after-make-frame-functions #'gatsby:theme--determine-font-size)

  (general-define-key :keymaps '(motion normal visual emacs insert)
    "C-+" 'gatsby:theme-fontsize-up
    "C--" 'gatsby:theme-fontsize-down)
#+end_src

Finally, I do not want the minibuffer prompt to stand out too much:

#+begin_src emacs-lisp
  (set-face-attribute 'minibuffer-prompt nil :weight 'normal)
#+end_src

*** indentation

Indentation is important for both aesthetics and syntax (in ~python~). Here, I first set a sensible default of indentation, including:

+ use space, not tab;
+ default tab-width of 4
+ do not try to be smart and change indentations base on some rules
+ one ~delete~ key kills all spaces and the new-line character (~\n~)

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 4
                electric-indent-inhibit t)

  (setq backward-delete-char-untabify-method 'all)
#+end_src

Second, I use ~highlight-indent-guides~ to provide visual cues on the level of indentation for each code blocks.

#+begin_src emacs-lisp
  (use-package highlight-indent-guides

    :hook
    (prog-mode . highlight-indent-guides-mode)

    :custom
    (highlight-indent-guides-method 'bitmap)
    (highlight-indent-guides-responsive nil))
#+end_src

*** cursor position

~beacon~ provides a temporary visual cue of the current cursor position when a buffer/window/frame/... gains focus.

#+begin_src emacs-lisp
  (use-package beacon :straight (beacon :host github :repo "junyi-hou/beacon") :hook (after-init . beacon-mode))
#+end_src

I adjust the following setting:

+ do not blink when I stay in the same window and just scroll up and down: I rarely lose track when I do that.
+ The stock version of ~beacon~ have an UI issue: ~beacon~ work by adding spaces (and highlight its background) when the cursor is near the right edge of the window, the extra spaces could cause ~visual-line-mode~ to wrap line around. After the blinking ends, these spaces are removed and thus the line become unwrapped. This process causes small "flicks" happening every now and then, which is annoying. I amend ~beacon~ to allow it to blink backwards so it will not create the extra spaces.
+ I set the size of the blink to be 15 because why not.

#+begin_src emacs-lisp
  (setq beacon-blink-when-window-scrolls nil
        beacon-can-go-backwards t
        beacon-size 15)
#+end_src

*** highlight keywords

~hl-todo~ is a package provides visual emphasis in places when future attention is warranted.

#+begin_src emacs-lisp
  (use-package hl-todo :hook (after-init . global-hl-todo-mode))
#+end_src

I only need a handful of keywords: todo, fixme, hack, and note.

#+begin_src emacs-lisp
  (setq hl-todo-keyword-faces '(("TODO" . "#FB4934")
                                ("FIXME"  . "#FB4934")
                                ("NOTE"   . "#FABD2F")
                                ("HACK"   . "#FABD2F")))
#+end_src

I also want to have these highlights in all modes, even in ~org-mode~ where there are already todo highlights.

#+begin_src emacs-lisp
  (setq hl-todo-exclude-modes nil)
#+end_src

*** display line number

I need to know line numbers for two reasons. First, it helps me to know where I am in the file. Second, it helps me to pinpoint the position of a piece of code from debug/error log. ~emacs~ had an old issue that calculating and displaying line number for a large file is extremely slow. Fortunately, since emacs 26.1, a new builtin ~display-line-numbers~ mode improves the performance of calculating and displaying line number quite a bit.

#+begin_src emacs-lisp
  (use-package display-line-numbers :hook (prog-mode . display-line-numbers-mode))
#+end_src

Some themes do not specific ~line-mumber~ face which ~display-line-numbers~ uses. I advice ~load-theme~

#+begin_src emacs-lisp
  (defun gatsby:theme--set-line-number-background (&rest _)
    (set-face-attribute 'line-number nil :background (face-background 'default)))

  (gatsby:theme--set-line-number-background)
  (advice-add #'load-theme :after #'gatsby:theme--set-line-number-background)
#+end_src

By default, line numbers in ~display-line-numbers~ are left-align. The following setting makes them right-align.

#+begin_src emacs-lisp
  (setq display-line-numbers-width-start t)
#+end_src

*** ligature

Ligatures are multi-byte characters (like Chinese) that represent some commonly used mathematical symbols (e.g., != and >=). Displaying ligatures properly is not only aesthetically pleasing, but also makes the code easier to read. Before this package, only the ~emacs-plus~ build on macOS supports universal ligature. Now I can have ligatures on GNU version of the emacs as well.

#+begin_src emacs-lisp
  (use-package ligature :straight (ligature :host github :repo "mickeynp/ligature.el"))
#+end_src

Different font offers different ligatures, and I need to register the proper ligatures that are compatible with the font that I am using. I follow the example configuration for ~Iosevka~ in the [[https://github.com/mickeynp/ligature.el][ligature repository]] to register ligatures.

#+begin_src emacs-lisp
  (ligature-set-ligatures
   'prog-mode
   '("<--" "<---" "<<-" "<-" "<->" "->" "->>" "-->" "--->"
     "<!--" "-<<" "-<" "-<-" "->-" ">-" ">>-" "<-->" "<--->"
     "<---->" "<==" "<===" "<<=" "<=" "<=>" "=>" "=>>" "==>"
     "===>" "<!---" "=<<" "=<" "=<=" "=>=" ">=" ">>=" "<==>"
     "<===>" "<====>" "<-------" "------->" "<======>" "<~~"
     "<~" "~>" "~~>" "\\/" "/\\" "==" "!=" "/=" "~=" "<>"
     "===" "!==" "=/=" "=!=" ":=" ":-" ":+" "<*" "<*>" "*>"
     "<|" "<|>" "|>" "+:" "-:" "=:" "::" ":::" "<." "<.>"
     ".>" "(*" "*)" ":>" "++" "+++" "|-" "-|"))
#+end_src

Enable ~ligature~ globally.

#+begin_src emacs-lisp
  (add-hook 'after-init-hook #'global-ligature-mode)
#+end_src

*** eldoc-box

~eldoc~ is a nice builtin package that displays useful information in the mini-window. Since I limits the size of mini-window to 1 in [[mini-window size]], multi-line messages will get truncated and not display in its full. ~eldoc-box~ solves this problem by displaying ~eldoc~ messages in a separate child frame.

#+begin_src emacs-lisp
  (use-package eldoc-box :hook ((text-mode prog-mode) . eldoc-box-hover-mode))
#+end_src

I fix the display position of ~eldoc-box~ at the bottom right corner of the current window, which is almost always out of my immediate focus in the main window, but still very easy to find and skim its information.

#+begin_src emacs-lisp
  (defun gatsby:eldoc-box--position (width height)
    "Display `eldoc-box' in the bottom right corner of the `selected-window'."
    (let* ((edge (window-inside-pixel-edges))
           (y (- (nth 3 edge) 5 height))
           (x (- (nth 2 edge) 2 width)))
      (cons x y)))
  (setq eldoc-box-position-function #'gatsby:eldoc-box--position)
#+end_src

I allow the frame to disappear 0.5 seconds after I move the cursor.

#+begin_src emacs-lisp
  (setq eldoc-box-cleanup-interval 0.5)
#+end_src

I limit the maximum height of the ~eldoc-box~ to 400 pixel so it won't grow too high to clutter the main window.

#+begin_src emacs-lisp
  (setq eldoc-box-max-pixel-height 400)
#+end_src

The new way of determine font size (see [[font size]] section) did not work well with ~eldoc-box~ since it reuses old frames to display messages across different frame. So I need to reset the default font size every time ~eldoc-box~ displays.

#+begin_src emacs-lisp
  (defun gatsby:eldoc-box--set-font-size (&rest _)
    (set-face-attribute
     'default eldoc-box--frame
     :height (face-attribute 'default :height (frame-parameter eldoc-box--frame 'parent-frame))))

  (add-hook 'eldoc-box-frame-hook #'gatsby:eldoc-box--set-font-size)
#+end_src

** Editing

The main job of ~emacs~ is interacting with text. This section contains settings on improving ~emacs~'s editing functionality. The core building block is the ~evil~ mode, which brings vim's modal editing into ~eamcs~. In addition, I also have a numbers of advises of the builtin ~emacs~ functions that take a few keystrokes out of my daily workflow.

*** evil

I like the customizability and extensibility ~emacs~ offers, but I am not a big fan of key combinations. Rather, I am more used to vim's modal editing paradigm. ~evil~ allows me to have the best of both worlds.

#+begin_src emacs-lisp
  (use-package evil

    :custom (evil-undo-system 'undo-redo)

    :init (evil-mode 1)

    :general
    (:keymaps '(motion normal visual)
     "j" 'evil-next-visual-line
     "k" 'evil-previous-visual-line

     "H" 'evil-first-non-blank-of-visual-line
     "L" 'evil-end-of-visual-line

     "SPC" nil)

    (:keymaps '(motion normal visual emacs insert)
     "C-h" 'windmove-left
     "C-j" 'windmove-down
     "C-k" 'windmove-up
     "C-l" 'windmove-right

     "C-u" 'evil-scroll-up
     "C-d" 'evil-scroll-down

     "C-e" (lambda () (interactive) (evil-scroll-line-down 5))
     "C-y" (lambda () (interactive) (evil-scroll-line-up 5)))

    (:keymaps '(motion normal visual)
     :prefix "SPC"

     ;; execute
     "ee" 'execute-extended-command
     "el" 'eval-last-sexp
     "eL" (lambda () (interactive)
            (eval-buffer)
            (message "buffer %s evaluated!" (buffer-name)))

     ;; basic function
     "w" 'evil-write
     "k" 'delete-window
     "K" 'delete-frame

     ;; split
     "\\"  (lambda () (interactive) (evil-window-vsplit) (evil-window-right 1))
     "-"   (lambda () (interactive) (evil-window-split) (evil-window-down 1)))

    (:keymaps 'visual
     :prefix "SPC"
     "a" 'align-regexp)

    (:keymaps '(normal motion)
     "<tab>" 'evil-jump-item))
#+end_src

*** evil-surround

~evil-surround~ ports ~vim-surround~ to evil.

#+begin_src emacs-lisp
  (use-package evil-surround :hook (after-init . global-evil-surround-mode))
#+end_src

*** evil-nerd-commenter

~evil-nerd-commenter~ provides quick ways to comment/uncomment visually select lines.

#+begin_src emacs-lisp
  (use-package evil-nerd-commenter

    :after evil

    :commands evilnc-comment-or-uncomment-lines

    :general
    (:keymaps '(normal visual)
     :prefix "SPC"
     "t" 'evilnc-comment-or-uncomment-lines))
#+end_src

*** expand-region

~expand-region~ is a package that could automatically enlarge/shrink selected region.

#+begin_src emacs-lisp
  (use-package expand-region

    :general
    (:keymaps 'visual
     "v" 'er/expand-region
     "V" 'er/contract-region))
#+end_src

*** electric pair

~electric-pair-mode~ helps me in two ways. First, it automatically closed pairs and put cursor in between. Second, it automatically remove empty pairs when I hit ~delete~.

#+begin_src emacs-lisp
  (use-package elec-pair :hook (after-init . electric-pair-mode))
#+end_src

*** improvements and advises

**** evil mode-line indicator

Since evil is a modal editing package, it is important to know what "mode" (or "state" in evil's term) I am in.

#+begin_src emacs-lisp
  (setq-default mode-line-format `((:evil evil-mode-line-tag) ,@mode-line-format))

  (--each (buffer-list)
    (with-current-buffer it
      (setq mode-line-format `((:evil evil-mode-line-tag) ,@mode-line-format))))
#+end_src

The ~*Messages*~ buffer is created before this

**** move up and down a bit more precise

I like ~C-d~ and ~C-u~, but they are moving too fast (half a screen at a time). On the other hand, ~j~ and ~k~ move too slow (one line at a time). I come up with a compromise between those two modes of movement below.

#+begin_src emacs-lisp
  (evil-define-motion gatsby:evil-next-three-lines ()
    (interactive)
    (evil-next-visual-line 3))

  (evil-define-motion gatsby:evil-previous-three-lines ()
    (interactive)
    (evil-previous-visual-line 3))

  (general-define-key :keymaps '(motion normal visual)
    "J" 'gatsby:evil-next-three-lines
    "K" 'gatsby:evil-previous-three-lines)
#+end_src

**** context aware tab in the visual-state

I want my ~tab~ key to be context aware. Here is the first of many examples to come: when in the ~visual-line~ mode, ~tab~ execute ~indent-region~ on the selected regions. When in ~visual~ mode, ~tab~ execute ~evil-jump-item~ to jump to the matching pair (for quick selection within pair of deliminator).

#+begin_src emacs-lisp
  (defun gatsby:evil-visual-tab ()
    "Indent region if in visual-line-mode, otherwise select contains inside a pair of tags via `evil-jump-item'"
    (interactive)
    (if (eq evil-visual-selection 'line)
        (indent-region (region-beginning) (region-end))
      (evil-jump-item)))

  (general-define-key :keymaps 'visual
    "<tab>" 'gatsby:evil-visual-tab)
#+end_src

**** global escape

Shit always hits the fan some days. To restore normality I have the following function bind globally to the ~escape~ key.

#+begin_src emacs-lisp
  (defun gatsby:evil-normal-state-if-not-motion ()
      "Switch to evil normal state if the current state is not motion state."
      (interactive)
      (unless (or (evil-motion-state-p)
                  (evil-normal-state-p)
                  (minibufferp (current-buffer))
                  (memq major-mode evil-emacs-state-modes))
        (evil-normal-state)))

  (global-set-key (kbd "<escape>") #'gatsby:evil-normal-state-if-not-motion)
#+end_src

**** alternative universal argument

~C-u~ was taken up by one of ~evil~'s scrolling commands. This is unfortunate because ~emacs~ likes ~C-u~ (the universal argument) quite a bit. I use ~M-u~ for UA.

#+begin_src emacs-lisp
  (global-set-key (kbd "M-u") #'universal-argument)
#+end_src

**** better newline

I write multi-line comments a lot, so I advice ~newline~ command to automatically insert the comment characters when doing so.

#+begin_src emacs-lisp
  (defun gatsby:evil-better-newline (newline-fun &rest args)
      "When calling `newline', check whether current line is a comment line (i.e., start with 0 or more spaces followed by `comment-start-skip')  If so, automatically indent and insert `comment-start-skip' after calling `newline' for the first call.  Delete the auto-inserted comment for the second call.  Otherwise call `newline' as default."
      (let* (;; line - the current line as string
             (line (buffer-substring-no-properties
                    (line-beginning-position)
                    (line-end-position)))
             ;; only-comment - t if the current line starts with comment
             (only-comment (and comment-start-skip
                                (string-match (concat "\\(^[\t ]*\\)\\(" comment-start-skip "\\)") line)))
             ;; newline-string - string insert into newline
             (newline-string (if only-comment
                                 (match-string 2 line)
                               "")))
        (if (and only-comment
                 (eq last-command 'newline))
            (progn
              (delete-region (line-beginning-position) (point))
              (insert (match-string 1 line)))
          (apply newline-fun args)
          (insert newline-string))))

  (advice-add 'newline :around #'gatsby:evil-better-newline)
#+end_src

**** center at cursor after moving

When I jump to a new location via search, ~G~, or ~g*~, I want my cursor position right at the middle of the screen. The following advises accomplish this.

#+begin_src emacs-lisp
  (defun gatsby:evil--center-cursor-line (&rest _)
      "Thin wrapper around `evil-scroll-line-to-center' for advice purpose."
      (recenter nil))

  (advice-add #'evil-search-next :after #'gatsby:evil--center-cursor-line)
  (advice-add #'evil-search-previous :after #'gatsby:evil--center-cursor-line)
  (advice-add #'gatsby:evil-search-visually-forward :after #'gatsby:evil--center-cursor-line)
  (advice-add #'gatsby:evil-search-visually-backward :after #'gatsby:evil--center-cursor-line)

  (defun gatsby:evil--recenter-after-goto-point-max (count)
    "Thin wrapper around `evil-scroll-line-to-center' so center the end-of-buffer after a G motion."
    (unless count
      (recenter nil)))

  (advice-add #'evil-goto-line :after #'gatsby:evil--recenter-after-goto-point-max)
#+end_src

**** killing buffers and/or window

There are two kinds of window. The first kind holds buffer visiting normal files. I do not want to delete the window when killing the buffer since the chances are I still want to use that window to display other buffers visiting files. The second kind holds temporary buffers (like help, message buffer), for which I do not want to reuse that window. Therefore, I want ~kill-buffer~ to keep window for the first kind of buffers, but delete window for the second kid of buffers.

#+begin_src emacs-lisp
  (defun gatsby:kill-buffer-and-or-window ()
    "Delete window and kill buffer if `buffer-file-name' is nil."
    (interactive)
    (if (buffer-file-name)
        (kill-buffer)
      (kill-buffer-and-window)))

  (general-define-key :keymaps '(normal motion visual) :prefix "SPC"
    "q" #'gatsby:kill-buffer-and-or-window)
#+end_src

** Minibuffer

minibuffer is a mechanism in ~emacs~ to query user input interactively. For this mechanism to be efficient, it needs to

+ offer a way of narrowing and selecting from candidates, so I do not need to type exactly the thing I need;
+ have an efficient fuzzy matching mechanism, so I can get where I need to without remembering exactly what it is.

*** selectrum

~selectrum~ offers a narrowing and selection framework build on the builtin ~completing-read~ function.

#+begin_src emacs-lisp
  (use-package selectrum

    :straight (selectrum :host github :repo "raxod502/selectrum")

    :defines (selectrum-minibuffer-bindings selectrum-should-sort-p)

    :custom (selectrum-fix-minibuffer-height t)

    :init (selectrum-mode 1)

    :general
    (:keymaps '(motion normal visual)
     :prefix "SPC"
     "oo" #'find-file
     "om" (lambda () (interactive)
            (switch-to-buffer-other-window (get-buffer-create "*Messages*"))))

    ;; evil like scrolling
    (:keymaps 'selectrum-minibuffer-map
     "C-d" #'selectrum-next-page
     "C-u" #'selectrum-previous-page
     "C-e" #'selectrum-next-page
     "C-y" #'selectrum-previous-page))
#+end_src

A common use case of ~selectrum~ is to complete file path. A good quality-of-life improvement ~ivy~ has but ~selectrum~ lacks is killing the directory name just before ~point~ with one ~delete~. Below I implement this function myself.

#+begin_src emacs-lisp
  (defun gatsby:selectrum--remove-until-slash (bound n)
    "Return the position of the backwards Nth slash until BOUND.
    If no slash was found, return BOUND."
    (save-excursion
      (if-let* ((found (search-backward "/" bound 'noerror n)))
          (1+ found)
        bound)))

  (defun gatsby:selectrum-better-backspace ()
    "If `point' is at \"/\", delete till the last \"/\"."
    (interactive)
    (cond ((thing-at-point-looking-at "~/")
           (progn
             (delete-region (minibuffer-prompt-end) (point))
             (insert (file-name-directory (expand-file-name "~")))))
          ((string= (buffer-substring (minibuffer-prompt-end) (point)) "/")
           (call-interactively #'backward-delete-char))
          ((thing-at-point-looking-at "/")
           (delete-region (gatsby:selectrum--remove-until-slash
                           (minibuffer-prompt-end) 2)
                          (point)))
          (t (call-interactively #'backward-delete-char))))

  (general-define-key :keymaps #'selectrum-minibuffer-map
    "<backspace>" #'gatsby:selectrum-better-backspace)
#+end_src

Furthermore, by default, ~selectrum~ do not cycle back to the first (last) candidate if going beyond the last (first) one. I want to have the ability to quickly go to the first/last candidate, which is achieved through the following functions.

#+begin_src emacs-lisp
  (defun gatsby:selectrum-next-candidate-cycle ()
    "Move selection to next candidate, if at the end, go to the top."
    (interactive)
    (when selectrum--current-candidate-index
      (setq selectrum--current-candidate-index
            (if (= selectrum--current-candidate-index (1- (length selectrum--refined-candidates)))
                (if selectrum--match-required-p 0 -1)
              (1+ selectrum--current-candidate-index)))))

  (defun gatsby:selectrum-previous-candidate-cycle ()
    "Move selection to previous candidate, if at the beginning, go to the end."
    (interactive)
    (when selectrum--current-candidate-index
      (setq selectrum--current-candidate-index
            (if (= selectrum--current-candidate-index (if selectrum--match-required-p 0 -1))
                (1- (length selectrum--refined-candidates))
              (1- selectrum--current-candidate-index)))))

  (general-define-key :keymaps #'selectrum-minibuffer-map
   "M-j" #'gatsby:selectrum-next-candidate-cycle
   "M-k" #'gatsby:selectrum-previous-candidate-cycle)
#+end_src

Finally, I want my ~tab~ to be smart in ~selectrum~ and achieve the following things together:

+ if there is a common part among all candidates, complete the common part
+ if there is only one candidate, select the candidate. There are two subcases here:
  - if the current candidate is a directory, enter the directory into the minibuffer
  - if the current candidate is /not/ a directory, exit with the candidate
+ finally, if the last command is ~tab~, or the current candidate is not the top candidate, then select the candidate.

First, I implement the selection mechanism for directory or other case:

#+begin_src emacs-lisp
  (defun gatsby:selectrum-select-current-candidate-if-not-dir ()
    "Select the current candidate. If, however, the current selection is a directory, enter the directory instead of opening it using `dired'."
    (interactive)
    (let*  ((index selectrum--current-candidate-index)
            (candidate (selectrum--get-candidate index)))
      (if (not (directory-name-p candidate))
          (selectrum-select-current-candidate)
        (delete-region (gatsby:selectrum--remove-until-slash
                        (minibuffer-prompt-end) 1)
                       (point-max))
        (insert candidate))))
#+end_src

Then the ~tab~ dispatch.

#+begin_src emacs-lisp
  (defun gatsby:selectrum-unified-tab ()
    "<tab> does the following things
  1. if there is a common part among candidates, complete the common part;
  2. if there is only one candidate, select the candidate
  3. if the last command is `gatsby:selectrum-unified-tab', or `selectrum--current-candidate-index' is not 0/-1 (the top candidate), then select the current candidate"
    (interactive)
    (when selectrum--current-candidate-index
      (let* ((common (try-completion "" selectrum--refined-candidates)))
        (cond
         ;; case 3
         ((or (eq last-command this-command)
              (not (memq selectrum--current-candidate-index '(0 -1))))
          (gatsby:selectrum-select-current-candidate-if-not-dir))
         ;; case 2
         ((= 1 (length selectrum--refined-candidates))
          (gatsby:selectrum-select-current-candidate-if-not-dir))
         ;; case 1
         ((not (string= common ""))
          (progn
            (delete-region (gatsby:selectrum--remove-until-slash
                            (minibuffer-prompt-end) 1)
                           (point-max))
            (insert common)))))))

  (general-define-key :keymaps 'selectrum-minibuffer-map
    "<tab>" #'gatsby:selectrum-unified-tab)
#+end_src

*** selectrum-become

One thing that is missing in the ~selectrum~ mode is the ability to jump from one command to another while keeping the input. This can be useful for the following two use cases:

+ when in the middle of a ~selectrum~ session but realized there is no match for the outcome, hence need to jump to another session but keep the typed query. An example of this is jumping from ~describe-variable~ to ~describe-function~.
+ when just finish a ~selectrum~ session but find out that the outcome is not ideal, and want to resume the last session and select a different outcome. An example of this is to use ~consult-outline~ to jump to an outline.

~selectrum~ has already a builtin function to address the second use case: ~selectrum-repeat~.

#+begin_src emacs-lisp
  (general-define-key :keymaps '(motion normal visual emacs insert)
    "<C-return>" #'selectrum-repeat)
#+end_src

I now implement the first case, which I call ~selectrum-become~. The idea is very simple. First, I store commands that can "become" each other in a variable call ~selectrum-become-command-context-list~, then I define a command ~selectrum-become~ which, upon calling, get the current selectrum command, find the list of other commands that it can become, and prompt the user to choose from that candidate list the new command, and resume ~selectrum~ with the new command.

#+begin_src emacs-lisp
  (defcustom selectrum-become-command-context-list
    '((helpful-variable helpful-function helpful-callable)
      (consult-outline consult-line consult-flymake)
      (find-file switch-to-buffer project-plus-switch-project
                 project-plus-find-file consult-buffer))
    "The selectrum-become context list.

      Each element is a list of selectrum commands that should be considered
      within the same group and can become each other. See the default value
      for example."
    :type '(list '(list command))
    :group 'selectrum)

  (defun selectrum-become ()
    (interactive)
    (let ((cmd selectrum--last-command)
          (input selectrum--previous-input-string)
          (enable-recursive-minibuffers t))
      (let ((new-cmd (completing-read "Select different command: "
                                      (->> selectrum-become-command-context-list
                                           (--first (memq cmd it))
                                           (--map (symbol-name it))
                                           (--filter (not (eq (symbol-name cmd) it)))))))
        (run-at-time 0 nil
                     (lambda ()
                       (let ((selectrum--repeat t)
                             (selectrum--previous-input-string input))
                         (call-interactively (intern new-cmd))
                         (setq selectrum--current-candidate-index 0))))
        (abort-recursive-edit))))

  (general-define-key :keymaps #'selectrum-minibuffer-map
    "<C-return>" #'selectrum-become)
#+end_src

*** prescient

~selectrum~ offers the basic narrowing and selecting mechanism. ~prescient~ improves the narrowing mechanism by considering fuzzy matching from a list of substrings or initials. In addition, it also offers a sorting mechanism based on selection histories for each individual command that queries user input.

#+begin_src emacs-lisp
  (use-package prescient

    :config
    (setq prescient-save-file (concat no-littering-var-directory "prescient-save.el"))
    (prescient-persist-mode 1))

  (use-package selectrum-prescient :config (selectrum-prescient-mode 1))
#+end_src

*** consult

~consult~ is a package providing some useful functions by using the query framework offered by ~selectrum~. The ones that I use on a daily basis are ~consult-line~, ~consult-outline~, ~consult-flymake~ (since I use the builtin ~flymake~).

#+begin_src emacs-lisp
  (use-package consult

    :commands
    (consult-buffer consult-line consult-outline)

    :custom
    (consult-preview-key nil)

    :general
    (:keymaps '(motion normal visual)
     :prefix "SPC"
     "ob" #'consult-buffer))
#+end_src

I like ~#~ and ~*~ commands in vim, which search the current word under the cursor forwards/backwards. ~consult-line~ and ~consult-outline~ provide a more powerful mechanism for searching. I also implement a "visual" version of the command to search visually-selected text using ~consult-line~ and ~consult-outline~

#+begin_src emacs-lisp
  (defun gatsby:consult-search-visual-line (beg end)
    (interactive "r")
    (evil-exit-visual-state)
    (let ((target-length (1- (- end beg)))
          (target (buffer-substring beg end)))
      (consult--jump
       (consult--read (consult--with-increased-gc (consult--line-candidates))
                      :prompt "Go to line: "
                      :category 'consult-location
                      :sort nil
                      :default-top nil
                      :require-match t
                      :add-history (list (thing-at-point 'symbol) isearch-string)
                      :history '(:input consult--line-history)
                      :lookup #'consult--line-match
                      :initial target
                      :state (consult--jump-state)))))

  (defun gatsby:consult-search-visual-outline (beg end)
    (interactive "r")
    (evil-exit-visual-state)
    (let ((target-length (1- (- end beg)))
          (target (buffer-substring beg end)))
      (consult--jump
       (consult--read (consult--with-increased-gc (consult--outline-candidates))
                      :prompt "Go to heading: "
                      :category 'consult-location
                      :sort nil
                      :require-match t
                      :lookup #'consult--line-match
                      :history '(:input consult--line-history)
                      :add-history (thing-at-point 'symbol)
                      :initial target
                      :state (consult--jump-state)))))

  (general-define-key :keymaps '(motion normal)
    "*" #'consult-line
    "#" #'consult-outline)

  (general-define-key :keymaps 'visual
    "*" #'gatsby:consult-search-visual-line
    "#" #'gatsby:consult-search-visual-outline)
#+end_src

Finally, ~consult~ provides a compatibility patch to use with ~selectrum~, which is included below.

#+begin_src emacs-lisp
  (use-package consult-selectrum

    :straight (:type built-in)

    :after (consult selectrum))
#+end_src

*** marginalia

~marginalia~ is a package that provides meta data to ~consult~ commands. These meta data includes

+ symbol type (command/function/(local/global) variable/advice-p/etc...)
+ symbol docstring
+ file or buffer
+ key bindings

#+begin_src emacs-lisp
  (use-package marginalia :straight (marginalia :host github :repo "minad/marginalia" :branch "main"))
  (marginalia-mode 1)
#+end_src

** Shell Integration

The ability to drop down into a shell and run CLI commands is invaluable. I use mostly two ways of interacting with shell. First, via ~eshell~ mode, which is an ~elisp~ emulation of a shell and not technically a real shell. The second is ~vterm~ mode, which is a fully fledged terminal capable of running any shell.

*** eshell

Although not being a real shell, ~eshell~ is a normal ~emacs~ buffer that I can interact with using ~evil~ without any problems. The idea of having a consistent modal editing experience in all environment (especially in a shell-like environment) is an important reason that convince me to start using ~emacs~ in the first place.

#+begin_src emacs-lisp
  (use-package eshell)
#+end_src

I also want to set some environment variables specific to the ~emacs~ process and any other processes spanned from the main process. These includes

+ the ~PAGER~ variable. With the power of ~evil~, a simple ~cat~ will do

  #+begin_src emacs-lisp
    (setenv "PAGER" "cat")
  #+end_src

+ the ~TERM~ variable. By default, ~emacs~ uses ~dumb~ terminal. However, some programs (e.g. ~bat~) requires a proper ~TERM~ to apply color.

  #+begin_src emacs-lisp
    (setenv "TERM" "xterm-256color")
  #+end_src


To support xterm color, I use ~xterm-color~ package.

#+begin_src emacs-lisp
  (use-package xterm-color)
#+end_src

I then make sure ~company-mode~ is enable so I have autocompletion.

#+begin_src emacs-lisp
  (add-hook 'eshell-mode-hook #'company-mode)
#+end_src

Unlike "normal packages", ~eshell~ needs to hook setup functions onto ~eshell-first-time-mode-hook~. So, instead of customizing variables directly, I wrap them inside a function and hook it onto the required hook.

#+begin_src emacs-lisp :noweb yes
  (defun gatsby:eshell--setup ()
    "Further setup eshell mode."
    <<eshell-setup>>
    )

  (add-hook 'eshell-first-time-mode-hook #'gatsby:eshell--setup)
#+end_src

First, command history. I want to:

+ save history when executing it

  #+begin_src emacs-lisp :noweb-ref eshell-setup
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
  #+end_src
+ do not record duplicated command to the history

  #+begin_src emacs-lisp :noweb-ref eshell-setup
    (setq eshell-hist-ignoredups t)
  #+end_src
+ save up to 10000 commands

  #+begin_src emacs-lisp :noweb-ref eshell-setup
    (setq eshell-history-size 10000)
  #+end_src

Second, setup proper xterm color.

#+begin_src emacs-lisp :noweb-ref eshell-setup
  (add-hook 'eshell-before-prompt-hook (lambda () (setq xterm-color-preserve-properties t)))
  (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
  (setq eshell-output-filter-functions
        (remove 'eshell-handle-ansi-color eshell-output-filter-functions))
#+end_src

Third, do not let ~eshell~ buffer grow unlimited and slow down everything.

#+begin_src emacs-lisp :noweb-ref eshell-setup
  (setq eshell-buffer-maximum-lines 12000)
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)
#+end_src

Forth, list files after changing to a new directory.

#+begin_src emacs-lisp :noweb-ref eshell-setup
  (setq eshell-list-files-after-cd t)
#+end_src

Fifth, when globing, ignore case.

#+begin_src emacs-lisp :noweb-ref eshell-setup
  (setq eshell-error-if-no-glob t
        eshell-glob-case-insensitive t)
#+end_src

Sixth, when the underlying process died, destroy the corresponding ~eshell~ buffer.

#+begin_src emacs-lisp :noweb-ref eshell-setup
  (setq eshell-destroy-buffer-when-process-dies t)
#+end_src

Finally, when typing into a ~eshell~ buffer, automatically scroll to the last prompt.

#+begin_src emacs-lisp :noweb-ref eshell-setup
  (setq eshell-scroll-to-bottom-on-input 'all)
#+end_src

In addition to the above setting, I also need to use ~em-term~ package for correctly parsing ANSI escape sequences in ~eshell~ buffers.

#+begin_src emacs-lisp
  (use-package em-term :straight (em-term :type built-in) :after eshell)
#+end_src

Like other shells, ~eshell~ support defining alias.

#+begin_src conf :tangle ./emacs.d/eshell/aliases :mkdirp yes
  alias cat bat $*
  alias ll ls -alh
  alias cls gatsby:eshell-clear-buffer
  alias sudo eshell/sudo $*
  alias su eshell/su $*
#+end_src

Since I use ~bat~ to replace the builtin ~cat~, I need to make it available.

#+begin_src nix :noweb-ref home-manager
  home.packages = [ pkgs.bat ];
#+end_src

Now I define useful functions to interact with ~eshell~. First, I implement ~bash~'s history command search (~C-r~) in ~eshell~. ~eshell~'s version is better than the ~bash~'s since I have a powerful completion framework ~selectrum~.

#+begin_src emacs-lisp
  (defun gatsby:eshell-history ()
    "Search history"
    (interactive)
    (let* ((selectrum-should-sort-p nil)
           (eshell-bol (save-excursion (eshell-bol) (point)))
           (command (selectrum-read
                     "History: "
                     (if eshell-history-ring
                         (-distinct (ring-elements eshell-history-ring))
                       '())
                     :initial-input (buffer-substring eshell-bol (point)))))
      (delete-region eshell-bol (point))
      (insert command)))
#+end_src

I also want to be able to quickly go to the last prompt.

#+begin_src emacs-lisp
  (defun gatsby:eshell-goto-last-prompt ()
    "Goto current prompt and continue editting."
    (interactive)
    (goto-char (point-max))
    (evil-insert 1))
#+end_src

It is quite useful to have ~eshell~ buffers to include the current working directory information in its title. So when I switching to them, I know which directory I am switching into.

#+begin_src emacs-lisp
  (defun gatsby:eshell--change-buffer-title ()
    "Change the title of eshell buffer to reflect $pwd."
    (rename-buffer (format "%s: %s" eshell-buffer-name (directory-file-name default-directory)) 'unique))

  (add-hook 'eshell-mode-hook #'gatsby:eshell--change-buffer-title)
  (add-hook 'eshell-directory-change-hook #'gatsby:eshell--change-buffer-title)
#+end_src

Cleaning the content of ~eshell~ buffer if it is too long.

#+begin_src emacs-lisp
  (defun gatsby:eshell-clear-buffer ()
    "Eshell version of `cls'."
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)
      (eshell-send-input)))
#+end_src

I can also quickly toggle "sudo" in front of the current command.

#+begin_src emacs-lisp
  (defun gatsby:eshell-toggle-sudo ()
    "Add/Remove sudo in the begining of command line."
    (interactive)
    (let ((pos (point))
          (commands (buffer-substring-no-properties
                     (eshell-bol) (point-max))))
      (if (string-match-p "^sudo " commands)
          (progn
            (eshell-bol)
            (while (re-search-forward "sudo " nil t)
              (replace-match "" t nil))
            (setq pos (- pos 4)))
        (eshell-bol)
        (insert "sudo ")
        (setq pos (+ pos 6)))
      (goto-char pos)
      (evil-insert-state)))
#+end_src

Following the code from [[https://github.com/hlissner/doom-emacs/blob/develop/modules/term/eshell/autoload/evil.el][doom-emacs]] to use ~evil~ movements in ~eshell~, I need to define new ~evil~ operators.

#+begin_src emacs-lisp
  (evil-define-operator eshell/evil-change (beg end type register yank-handler delete-func)
    "Like `evil-change' but will not delete/copy the prompt."
    (interactive "<R><x><y>")
    (save-restriction
      (narrow-to-region eshell-last-output-end (point-max))
      (evil-change (max beg (point-min))
                   (if (eq type 'line) (point-max) (min (or end (point-max)) (point-max)))
                   type register yank-handler delete-func)))

  (evil-define-operator eshell/evil-change-line (beg end type register yank-handler)
    "Change to end of line."
    :motion evil-end-of-line
    (interactive "<R><x><y>")
    (eshell/evil-change beg end type register yank-handler #'evil-delete-line))

  (evil-define-operator eshell/evil-delete (beg end type register yank-handler)
    "Like `evil-delete' but will not delete/copy the prompt."
    (interactive "<R><x><y>")
    (save-restriction
      (narrow-to-region eshell-last-output-end (point-max))
      (evil-delete (if beg (max beg (point-min)) (point-min))
                   (if (eq type 'line) (point-max) (min (or end (point-max)) (point-max)))
                   type register yank-handler)))

  (evil-define-operator eshell/evil-delete-line (_beg end type register yank-handler)
    "Change to end of line."
    :motion nil
    :keep-visual t
    (interactive "<R><x>")
    (eshell/evil-delete (point) end type register yank-handler))
#+end_src

I now collect all those functions and bind them to their appropriate key in ~eshell-mode-map~.

#+begin_src emacs-lisp
  (defun gatsby:eshell--setkey ()
    "Customize key in eshell-mode."
    (general-define-key
     :states '(normal visual motion)
     :keymaps 'eshell-mode-map
     "A" 'gatsby:eshell-goto-last-prompt
     "H" 'eshell-bol
     "S" 'gatsby:eshell-toggle-sudo
     "c" 'eshell/evil-change
     "C" 'eshell/evil-change-line
     "d" 'eshell/evil-delete
     "D" 'eshell/evil-delete-line
     "<" 'eshell-previous-prompt
     ">" 'eshell-next-prompt)

    (general-define-key
     :states 'insert
     :keymaps 'eshell-mode-map
     "C-r" 'gatsby:eshell-history)

    (general-define-key
     :states '(normal visual motion emacs insert)
     :keymaps 'eshell-mode-map
     :prefix "C-c"
     "C-l" 'gatsby:eshell-clear-buffer)

    (general-define-key
     :states '(normal visual motion)
     :keymaps 'eshell-mode-map
     :prefix "SPC"
     "q" 'kill-buffer-and-window))

  (add-hook 'eshell-first-time-mode-hook #'gatsby:eshell--setkey)
#+end_src

Functions with ~eshell/~ prefix can be called directly in ~eshell~.

#+begin_src emacs-lisp
  (defun eshell/x (file &rest args)
    "Unpack FILE with ARGS using default command."
    (let* ((command
            (-some (lambda (x)
                     (if (string-match-p (car x) file)
                         (cadr x)))
                   '((".*\.tar.bz2" "tar xjf")
                     (".*\.tar.gz" "tar xzf")
                     (".*\.bz2" "bunzip2")
                     (".*\.rar" "unrar x")
                     (".*\.gz" "gunzip")
                     (".*\.tar" "tar xf")
                     (".*\.tbz2" "tar xjf")
                     (".*\.tgz" "tar xzf")
                     (".*\.zip" "unzip")
                     (".*\.Z" "uncompress")
                     (".*" "echo 'Could not unpack the file:'"))))
           (unpack-command
            (concat command " " file " " (mapconcat 'identity args " "))))
      (eshell/printnl "Unpack command: " unpack-command)
      (eshell-command-result unpack-command)))

  (defun eshell/mkcd (dir &rest _)
    "Run \"mkdir dir\" then \"cd dir\""
    (interactive)
    (eshell/mkdir dir)
    (eshell/cd dir))

  (defun eshell/ff (&rest files)
    "Open FILES in emacs."
    (setq files (flatten-tree files))
    (mapc 'find-file files))

  (defun eshell/FF (&rest files)
    "Open FILES in a new window in emacs."
    (setq files (flatten-tree files))
    (gatsby:core-split-window)
    (other-window 1)
    (mapc 'find-file files))
#+end_src

As a quick way to call ~eshell~, I define two functions. The first one opens an ~eshell~ buffer at ~default-directory~, and the second one opens an ~eshell~ buffer at ~$HOME~.

#+begin_src emacs-lisp
  (defun gatsby:eshell-open-here (&optional arg)
    "Open a new shell in the current directory.
  If the prefix argument (ARG) is not null, go to the home directory.
  If there is already a eshell buffer open for that directory, switch to that buffer."
    (interactive "P")
    (let* ((dir (if arg (expand-file-name "~/") default-directory))
           ;; check whether there exists a eshell buffer for DIR
           (exists (--first (with-current-buffer it
                              (and (string-equal major-mode "eshell-mode")
                                   (f-equal-p dir default-directory)))
                            (buffer-list)))
           ;; check if the matched eshell buffer is visible
           (visible (when exists (get-buffer-window exists 'all-frames))))
      (if visible
          (select-window visible)
        (split-window-below (- (/ (window-total-height) 3)))
        (other-window 1)
        (if exists
            (switch-to-buffer exists)
          (let ((default-directory dir))
            (eshell 'Z))))
      (goto-char (point-max))
      (evil-insert-state)))

  (general-define-key :keymaps '(motion normal visual) :prefix "SPC"
    "os" 'gatsby:eshell-open-here)
#+end_src

~tramp~ is a way ~emacs~ communicate with remote machines using ~ssh~ as backend. It is also the backend for ~sudo~ or ~su~ command in ~eshell~. To use those, I need to load the ~em-tramp~ package.

#+begin_src emacs-lisp
  (use-package tramp :straight (:type built-in))
  (use-package em-tramp :straight (:type built-in))
#+end_src

Sometimes, ~tramp~ may have some problems with the ~PATH~ variables. The following setting fix those problems

#+begin_src emacs-lisp
  (setq tramp-histfile-override "/dev/null")
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
#+end_src

Finally, the builtin ~eshell/sudo~ and ~eshell/su~ lacks support on remote machines. Specifically, ~su~/~sudo~ and ~ssh~ are parallel protocols in ~tramp~. This means that if I type ~sudo~ in a remote machine connecting using ~ssh~, I will exit the ~ssh~ and back to my local machine with ~sudo~ privilege. I override the builtin versions of ~eshell/sudo~ and ~eshell/su~ to allow running ~su~/~sudo~ on ~ssh~ as well.

#+begin_src emacs-lisp
  (defun gatsby:eshell-sudo (&rest commands)
    "Use `tramp' run COMMAND in /sudo::`default-directory'.  Does not have any flags so won't get error if -i or --user is given."
    (setq commands (flatten-tree commands))
    (if (not commands)
        (gatsby:eshell-su)
      (throw 'eshell-external
             (let ((user "root")
                   (host (or (file-remote-p default-directory 'host) "localhost"))
                   (dir (file-local-name (expand-file-name default-directory)))
                   (prefix (file-remote-p default-directory))
                   (sudo? (string-equal "sudo" (file-remote-p default-directory 'method))))
               (cond (sudo?
                      (eshell-named-command (car commands) (cdr commands)))
                     (prefix
                      (let ((default-directory (format "%s|sudo:%s@%s:%s"
                                                       (substring prefix 0 -1) user host dir)))
                        (eshell-named-command (car commands) (cdr commands))))
                     (t
                      (let ((default-directory (format "/sudo:%s@%s:%s" user host dir)))
                        (eshell-named-command (car commands) (cdr commands)))))))))

  (advice-add #'eshell/sudo :override #'gatsby:eshell-sudo)

  ;; override eshell/su
  (defun gatsby:eshell-su (&rest _)
    "toggle between `default-directory' and /sudo::`default-directory'."
    (let ((user "root")
          (host (or (file-remote-p default-directory 'host) "localhost"))
          (dir (file-local-name (expand-file-name default-directory)))
          (prefix (file-remote-p default-directory))
          (sudo? (string-equal "sudo" (file-remote-p default-directory 'method))))
      (if sudo?
          ;; in sudo mode, go back to non-sudo
          (let ((new-prefix (replace-regexp-in-string
                             (format "[|/]sudo:root@%s" host) ""
                             prefix)))
            (eshell/cd (if (string= ":" new-prefix) dir (format "%s%s" new-prefix dir))))
        ;; in non-sudo mode, go to sudo
        (if prefix
            (eshell/cd
             (format "%s|sudo:%s@%s:%s" (substring prefix 0 -1) user host dir))
          (eshell/cd (format "/sudo:%s@%s:%s" user host dir))))))

  (advice-add #'eshell/su :override #'gatsby:eshell-su)
#+end_src

Similarly, the builtin ~eshell/cd~ does not consider protocols. If I type ~cd~ when ~ssh~-ing into a remote machine, instead of going to the ~$HOME~ directory of whichever user I logged into the remote machine, I will go back to the ~$HOME~ directory on my local machine as my login user. I advice ~eshell/cd~ to fix this.

#+begin_src emacs-lisp
  (defun gatsby:eshell-cd (cd &rest args)
    "Make `eshell/cd' tramp-aware."
    (let* ((host (file-remote-p default-directory))
           (home (format "%s/home/%s" host (file-remote-p default-directory 'user))))
      (if (and (not args)
               host)
          (if (file-exists-p home)
              (funcall cd home)
            (funcall cd (format "%s/" host)))
        (funcall cd args))))

  (advice-add #'eshell/cd :around #'gatsby:eshell-cd)
#+end_src

The following advice enable ~eshell~ to follow the correct local environment.

#+begin_src emacs-lisp
  (with-eval-after-load 'envrc
    (defun gatsby:envrc--update-after-cd (&rest _)
      "Update the current direnv environment after `eshell/cd'."
      (let ((buf (current-buffer)))
        (if (f-traverse-upwards (lambda (dir)
                                  (f-exists-p (format "%s/.envrc" dir))))
            (envrc--update)
          (envrc--clear buf)
          (setq envrc--status 'none))))

    (advice-add #'eshell/cd :after #'gatsby:envrc--update-after-cd))
#+end_src

This concludes configuration for ~eshell~.

*** vterm

~eshell~ is not perfect, as it may not be consistent with the real shell in some cases (e.g., when running TUI programs like ~htop~ and ~nmtui~, or when ~ssh~-ing to remote). When this happens, I use ~vterm~ to launch a real shell to deal with it.

I do not need to register ~libvterm~ with ~home-manager~. Rather, the recommended way of having ~libvterm~ is through the ~vterm~ package.

#+begin_src emacs-lisp
  (use-package vterm)
  (add-to-list 'evil-insert-state-modes 'vterm-mode)
#+end_src

According to the [[https://github.com/akermu/emacs-libvterm][document]], ~vterm~ requires some shell-side configuration. Since I use ~bash~ by default, I need to add those shell-side configuration to my ~.bashrc~.

#+begin_src nix :noweb-ref home-manager
  programs.bash = {
    enable = true;

    profileExtra = ''
      [[ -f ~/.bashrc ]] && . ~/.bashrc
    '';

    initExtra = ''
      alias ls="ls --color"
      alias ll="ls -alh --color"
      alias cat="bat"

      mkcd(){
          mkdir -p -- "$1" && cd -P -- "$1"
      }

      vterm_printf(){
          if [ -n "$TMUX" ] && ([ "''${TERM%%-*}" = "tmux" ] || [ "''${TERM%%-*}" = "screen" ] ); then
              # Tell tmux to pass the escape sequences through
              printf "\ePtmux;\e\e]%s\007\e\\" "$1"
          elif [ "''${TERM%%-*}" = "screen" ]; then
              # GNU screen (screen, screen-256color, screen-256color-bce)
              printf "\eP\e]%s\007\e\\" "$1"
          else
              printf "\e]%s\e\\" "$1"
          fi
      }

      vterm_prompt_end(){
          vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
      }
      PS1=$PS1'\[$(vterm_prompt_end)\]'

      vterm_cmd() {
          local vterm_elisp
          vterm_elisp=""
          while [ $# -gt 0 ]; do
              vterm_elisp="$vterm_elisp""$(printf '"%s" ' "$(printf "%s" "$1" | sed -e 's|\\|\\\\|g' -e 's|"|\\"|g')")"
              shift
          done
          vterm_printf "51;E$vterm_elisp"
      }

      PROMPT_COMMAND='echo -ne "\033]0;${HOSTNAME}:${PWD}\007"'
    '';
  };
#+end_src

~vterm_prompt_end~ function also depends on the ~hostname~ command line utility, which is provided by ~inetutils~ package.

#+begin_src nix :noweb-ref home-manager
  home.packages = [ pkgs.inetutils ];
#+end_src

To configure ~vterm~, I first allow ~vterm~ to change the buffer name according to ~$PWD~.

#+begin_src emacs-lisp
  (setq vterm-buffer-name-string "*vterm*: %s")
#+end_src

I then extend the scrollback limit of ~vterm~ to retain more information.

#+begin_src emacs-lisp
  (setq vterm-max-scrollback 10000)
#+end_src

Third, ~vterm~ is a terminal emulator and not an internal ~emacs~ buffer, keystrokes send to ~vterm~ will go straight to the underlying shell process. Therefore, I need to configure ~vterm~ to translate evil movements before send them to the underlying shell. I borrow most of the translations from the [[https://github.com/emacs-evil/evil-collection/blob/master/modes/vterm/evil-collection-vterm.el][evil-collection]] package.

First, ~evil~ moves the cursor backwards when entering the normal state. This behavior can cause confusion in terminals. I turn it off by setting ~evil-move-cursor-back~ to ~nil~ in ~vterm~ mode.

#+begin_src emacs-lisp
  (defun gatsby:vterm---escape-stay ()
    "Go back to normal state but don't move cursor backwards.
  Moving cursor backwards is the default vim behavior but
  it is not appropriate in some cases like terminals."
    (setq-local evil-move-cursor-back nil))

  (add-hook 'vterm-mode-hook #'gatsby:vterm---escape-stay)
#+end_src

Second, the basic movement commands (e.g., "h", "l", "e", "b", "w") will not get send to ~vterm~. Therefore the cursor will not move accordingly to what it seems to be. To correct this, ~vterm~ provides a function ~vterm-goto-char~ that moves cursor to ~point~. I use this function to amend ~evil-insert~ and ~evil-append~.

#+begin_src emacs-lisp
  (defun gatsby:vterm--point-follow-cursor (pos)
    "When calling `vterm-goto-char' to a POS, also move the `point' to that position."
    (goto-char pos))

  (advice-add #'vterm-goto-char :after #'gatsby:vterm--point-follow-cursor)

  (defun gatsby:vterm-insert ()
    "Insert character before cursor."
    (interactive)
    (vterm-goto-char (point))
    (call-interactively #'evil-insert))

  (defun gatsby:vterm-insert-line ()
    "Insert character at beginning of prompt."
    (interactive)
    (vterm-goto-char (vterm--get-prompt-point))
    (call-interactively #'evil-insert))

  (defun gatsby:vterm-append ()
    "Append character after cursor."
    (interactive)
    (vterm-goto-char (point))
    (call-interactively #'evil-append))

  (defun gatsby:vterm-append-line ()
    "Append character at end-of-line."
    (interactive)
    (vterm-goto-char (point-max))
    (call-interactively #'vterm-previous-prompt)
    (vterm-goto-char (vterm-end-of-line))
    (call-interactively #'evil-append))

  (defun gatsby:vterm-bol ()
    "Move to the beginning of line."
    (interactive)
    (vterm-goto-char (vterm--get-prompt-point)))

  (defun gatsby:vterm-eol ()
    "Move to the end of line."
    (interactive)
    (vterm-goto-char (vterm-end-of-line)))

  (general-define-key :keymaps 'vterm-mode-map :states '(normal visual motion)
    "i" #'gatsby:vterm-insert
    "I" #'gatsby:vterm-insert-line
    "a" #'gatsby:vterm-append
    "A" #'gatsby:vterm-append-line
    [remap evil-first-non-blank-of-visual-line] #'gatsby:vterm-bol
    [remap evil-end-of-visual-line] #'gatsby:vterm-eol)
#+end_src

The other two major evil operations are change and delete. ~evil-collection~ also has appropriate codes that allow me to mimic their behavior.

#+begin_src emacs-lisp
  (evil-define-operator gatsby:vterm-delete (beg end type register yank-handler)
    "Modification of evil-delete to work in vterm buffer.
  Delete text from BEG to END with TYPE.
  Save in REGISTER or in the kill-ring with YANK-HANDLER."
    (interactive "<R><x><y>")
    (let* ((beg (max (or beg (point)) (vterm--get-prompt-point)))
           (end (min (or end beg) (vterm--get-end-of-line))))
      (unless register
        (let ((text (filter-buffer-substring beg end)))
          (unless (string-match-p "\n" text)
            ;; set the small delete register
            (evil-set-register ?- text))))
      (let ((evil-was-yanked-without-register nil))
        (evil-yank beg end type register yank-handler))
      (cond
       ((eq type 'block)
        (evil-apply-on-block #'vterm-delete-region beg end nil))
       ((and (eq type 'line)
             (= end (point-max))
             (or (= beg end)
                 (/= (char-before end) ?\n))
             (/= beg (point-min))
             (=  (char-before beg) ?\n))
        (vterm-delete-region (1- beg) end))
       (t
        (vterm-delete-region beg end)))
      ;; place cursor on beginning of line
      (when (and (called-interactively-p 'any)
                 (eq type 'line))
        (evil-first-non-blank))))

  (evil-define-operator gatsby:vterm-delete-backward-char (beg end type register)
    "Delete previous character."
    :motion evil-backward-char
    (interactive "<R><x>")
    (gatsby:vterm-delete beg end type register))

  (evil-define-operator gatsby:vterm-delete-line (beg end type register yank-handler)
    "Modification of evil-delete line to work in vterm bufer. Delete to end of line."
    :motion nil
    :keep-visual t
    (interactive "<R><x>")
    ;; act linewise in Visual state
    (let* ((beg (or beg (point)))
           (end (or end beg))
           (visual-line-mode (and evil-respect-visual-line-mode
                                  visual-line-mode))
           (line-end (if visual-line-mode
                         (save-excursion
                           (end-of-visual-line)
                           (point))
                       (line-end-position))))
      (when (evil-visual-state-p)
        (unless (memq type '(line screen-line block))
          (let ((range (evil-expand beg end
                                    (if visual-line-mode
                                        'screen-line
                                      'line))))
            (setq beg (evil-range-beginning range)
                  end (evil-range-end range)
                  type (evil-type range))))
        (evil-exit-visual-state))
      (cond
       ((eq type 'block)
        ;; equivalent to $d, i.e., we use the block-to-eol selection and
        ;; call `gatsby:vterm-delete'. In this case we fake the call to
        ;; `evil-end-of-line' by setting `temporary-goal-column' and
        ;; `last-command' appropriately as `evil-end-of-line' would do.
        (let ((temporary-goal-column most-positive-fixnum)
              (last-command 'next-line))
          (gatsby:vterm-delete beg end 'block register yank-handler)))
       ((memq type '(line screen-line))
        (gatsby:vterm-delete beg end type register yank-handler))
       (t
        (gatsby:vterm-delete beg line-end type register yank-handler)))))

  (evil-define-operator gatsby:vterm-change (beg end type register yank-handler)
    (gatsby:vterm-delete beg end type register yank-handler)
    (gatsby:vterm-insert))

  (evil-define-operator gatsby:vterm-change-line (beg end type register yank-handler)
    :motion evil-end-of-line-or-visual-line
    (gatsby:vterm-delete-line beg end type register yank-handler)
    (gatsby:vterm-insert))

  (general-define-key :keymaps 'vterm-mode-map :states 'normal
    "x" #'gatsby:vterm-delete-backward-char
    "d" #'gatsby:vterm-delete
    "D" #'gatsby:vterm-delete-line
    "c" #'gatsby:vterm-change
    "C" #'gatsby:vterm-change-line)

  (general-define-key :keymaps 'vterm-mode-map :states 'visual
    "d" #'gatsby:vterm-delete
    "c" #'gatsby:vterm-change
    "x" #'gatsby:vterm-delete-backward-char)
#+end_src

I also need to translate evil-paste, as it also modifies the cursor position and insert text.

#+begin_src emacs-lisp
  (evil-define-command gatsby:vterm-paste-after (count &optional register yank-handler)
    "Paste after the point"
    :suppress-operator t
    (interactive "*P<x>")
    (cl-letf (((symbol-function 'insert-for-yank) #'vterm-insert)
              (inhibit-read-only t))
      (when (evil-visual-state-p)
        (vterm-delete-region (region-beginning) (region-end)))
      (evil-paste-after count register yank-handler)))

  (evil-define-command gatsby:vterm-paste-before (count &optional register yank-handler)
    "Paste before the point"
    :suppress-operator t
    (interactive "*P<x>")
    (cl-letf (((symbol-function 'insert-for-yank) #'vterm-insert)
              (inhibit-read-only t))
      (when (evil-visual-state-p)
        (vterm-delete-region (region-beginning) (region-end)))
      (evil-paste-before count register yank-handler)))

  (general-define-key :keymaps 'vterm-mode-map :states '(normal visual)
    "p" #'gatsby:vterm-paste-after
    "P" #'gatsby:vterm-paste-before)
#+end_src

Finally, I include bindings that are consistent with other REPL modes: going back and forth in prompts and clear buffer.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'vterm-mode-map :states '(normal visual)
    "u" #'vterm-undo
    "<" #'vterm-previous-prompt
    ">" #'vterm-next-prompt)

  (general-define-key :keymaps 'vterm-mode-map :states '(normal visual insert) :prefix "C-c"
    "C-l" #'vterm-clear)
#+end_src

I haven't had the luck to make ~vterm~ working with ~company~. Therefore I
fall back to the autocompletion provided by the underlying shell in the ~vterm~ mode.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'vterm-mode-map :states 'insert
    "<tab>" #'vterm-send-tab)
#+end_src

~electric-pair~ is not enabled in ~vterm~ mode for the same reason that it modifies the buffer but not the underlying shell process. The following function restores ~electric-pair~ functionality in ~vterm~.

#+begin_src emacs-lisp
  (defvar gatsby:vterm-pairs
    '(("\"" . "\"")
      ("'" . "'")
      ("(" . ")")
      ("[" . "]")
      ("{" . "}")))

  (defun gatsby:vterm--insert-pairs (opening-char)
    "Insert the pair defined by `opening-char' in `gatsby:vterm-pairs'."
    (let ((pair (assoc-string opening-char gatsby:vterm-pairs)))
      (when pair
        (vterm-insert (format "%s%s" (car pair) (cdr pair)))
        (vterm-send-left))))

  (--each gatsby:vterm-pairs
    (let ((opening-char (car it)))
      (general-define-key :keymaps 'vterm-mode-map :states 'insert
        opening-char (lambda () (interactive) (gatsby:vterm--insert-pairs opening-char)))))
#+end_src

Now I integrate ~vterm~ with ~eshell~ by overriding ~eshell-exec-visual~ and allow it to use ~vterm~ to execute those visual commands.

#+begin_src emacs-lisp
  (defun gatsby:eshell-exec-visual (&rest args)
    "Use `vterm' to execute `eshell-visual-commands'."
    (let* (eshell-interpreter-alist
             (interp (eshell-find-interpreter (car args) (cdr args)))
           (eshell-buf (current-buffer))
             (program (car interp))
             (args (flatten-tree
                      (eshell-stringify-list (append (cdr interp)
                                                           (cdr args)))))
             (term-buf (concat "*" (file-name-nondirectory program) "*")))
      (vterm term-buf)
      (vterm-send-string
       (concat program " " (string-join args " ")))
      (vterm-send-return)
      (with-current-buffer eshell-buf
        (kill-buffer)))
    nil)

  (advice-add #'eshell-exec-visual :override #'gatsby:eshell-exec-visual)
#+end_src

Finally, define the entry point for ~vterm~.

#+begin_src emacs-lisp
  (defun gatsby:vterm-open-here (&optional arg)
    "Open a new vterm in the current directory.
  If the prefix argument (ARG) is not null, go to the home directory
  If there is already a vterm buffer open for that directory, switch to that buffer."
    (interactive "P")
    (let* ((dir (if arg (expand-file-name "~/") default-directory))
           ;; check whether there exists a eshell buffer for DIR
           (exists (--first (with-current-buffer it
                              (and (string-equal major-mode "vterm-mode")
                                   (f-equal-p dir default-directory)))
                            (buffer-list)))
           ;; check if the matched eshell buffer is visible
           (visible (when exists (get-buffer-window exists 'all-frames))))
      (if visible
          (select-window visible)
        (split-window-below (- (/ (window-total-height) 3)))
        (other-window 1)
        (if exists
            (switch-to-buffer exists)
          (let ((default-directory dir))
            (vterm))))
      (vterm-goto-char (point-max))
      (call-interactively #'vterm-previous-prompt)
      (vterm-goto-char (vterm-end-of-line))
      (evil-insert-state)))

  (general-define-key :keymaps '(motion normal visual) :prefix "SPC"
    "oS" 'gatsby:vterm-open-here)
#+end_src

** Org Mode

~org-mode~ is a gigantic package (or a large collection of packages) that offers functionalities like scheduling todos, writing documents like readme and emails, waving code and text (literate programming). I am not a heavy user of ~org-mode~ itself, but many messaging interfaces I use depends on it.

*** the main package

~org-mode~ is builtin in ~emacs~. However, it is usually the old version and without extra packages included in the ~contrib~ repository. Instead of using this builtin version, I use the most reason version defined in the master branch.

Historically, ~org-mode~ grew out of ~outline-mode~, which is used to fold text parts. ~org-mode~ inherit this functionality. Yet, the folding in ~org-mode~ depends on ~emacs overlays~, which can be very slow. [[https://github.com/yantar92/org/tree/6afe70e63509214b4c305f2d8f2d713056b165ed][this repository]] re-implement the folding mechanism by using ~text properties~.

#+begin_src emacs-lisp
  (use-package org
    :straight (org :host github :repo "yantar92/org" :branch "feature/org-fold"
                   :files ("*.el" "lisp/*.el" "contrib/lisp/*.el")))
#+end_src

~org-mode~ has a few frequently used pairs that are not registered in ~elec-pair~ (e.g., "~" for inline code). I make those pairs available by modifying ~electric-pair-pairs~.

#+begin_src emacs-lisp
  (defun gatsby:org--enable-extra-pairs ()
    (make-variable-buffer-local 'electric-pair-pairs)
    (add-to-list 'electric-pair-pairs '(?\~ . ?\~)))

  (add-hook 'org-mode-hook #'gatsby:org--enable-extra-pairs)
#+end_src

Set the indent width to 2 in the ~org-mode~.

#+begin_src emacs-lisp
  (defun gatsby:org--fix-indent () (setq tab-width 2))
  (add-hook 'org-mode-hook #'gatsby:org--fix-indent)
#+end_src

~org-mode~ allows users to customize how it presents the content when opening a new file. Those variables can also be set on a per-file basis. I include the following settings that makes sense to me:
+ automatically enable ~org-indent-mode~, so the sections are automatically
  indented according to their levels
+ enable previewing the latex segments.
+ customize where the latex cache is saved so it does not get in the way,

#+begin_src emacs-lisp
  (setq org-startup-indented t
        org-startup-with-latex-preview t
        org-preview-latex-image-directory ".org-latex-imgcache/")
#+end_src

Although ~org~ try to be smart and guess which character(s) after "^" or "_" are super/subscripts, it is unnecessary. I can always group them using curly scripts to avoid any confusion.

#+begin_src emacs-lisp
  (setq org-use-sub-superscripts nil)
#+end_src

~org~ provides an option to hide the leading stars that indicates the level the section is in. I find leading stars helpful in providing a visual cue. So I turn off the option below:

#+begin_src emacs-lisp
  (setq org-hide-leading-stars nil
        org-indent-mode-turns-on-hiding-stars nil)
#+end_src

To allow ~company~ to add org keywords to its candidates, I add the following hook.

#+begin_src emacs-lisp
  (defun gatsby:org--complete-keywords ()
    "Allow company to complete org keywords after ^#+"
    (add-hook 'completion-at-point-functions
              'pcomplete-completions-at-point nil t))

  (add-hook 'org-mode-hook #'company-mode)
  (add-hook 'org-mode-hook #'gatsby:org--complete-keywords)
#+end_src

There are more to fold than just sections:

#+begin_src emacs-lisp
  (defcustom gatsby:org-foldable'(example-block export-block src-block table)
    "A list of org-element that are consider foldable, and hence can be folded/expanded by `gatsby:org-hide-block' and `gatsby:org-show-block'."
    :type '(list symbol)
    :group 'org)
#+end_src

I bind the hide/show blocks to the default vim key binding.

#+begin_src emacs-lisp
  (defun gatsby:org-hide-block ()
    "Hide current block, if it is inside element defined in `gatsby:org-foldable', first try to fold the element.  Fall back to `evil-close-fold'."
    (interactive)
    (let ((element (org-element-at-point)))
      (if (memq (car element) gatsby:org-foldable)
          (progn
            (goto-char (plist-get (cadr element) :begin))
            (org-hide-block-toggle t))
        (evil-close-fold))))

  (defun gatsby:org-show-block ()
    "Show current block."
    (interactive)
    (condition-case _
        (org-hide-block-toggle 'off)
      (error (evil-open-fold))))

  (general-define-key :keymaps 'org-mode-map :states '(normal visual motion)
    "zo" #'gatsby:org-show-block
    "zc" #'gatsby:org-hide-block)
#+end_src

Since I do not use ~<tab>~ to open or close fold. So I instruct ~org~ not to mess with my ~<tab>~ key.

#+begin_src emacs-lisp
  (setq org-cycle-emulate-tab nil)
#+end_src

I also want to make ~org~ consistent in terms of its keybindings with other modes:

#+begin_src emacs-lisp
  (general-define-key :keymaps 'org-mode-map :states '(normal visual motion) :prefix "SPC"
    "rf" #'org-footnote)

  (general-define-key :keymaps 'org-mode-map :states '(normal visual motion)
    "<" #'org-previous-visible-heading
    ">" #'org-next-visible-heading)
#+end_src

I rarely use ~<RET>~ to change line in the normal state, so I bind it to open link at point.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'org-mode-map :states 'normal
    "RET" #'org-open-at-point)
#+end_src

*** org-export

~org-mode~ includes a simple dispatch function to translate org files into other popular formats. In particular, I use the following backends: ~ascii~, ~html~, ~latex~, ~md~, and ~odt~. The only one worth mentioning is ~odt~, which is compatible with Google Docs.

#+begin_src emacs-lisp
  (setq org-export-backends '(ascii html latex md odt)
        org-export-coding-system 'utf-8
        org-export-with-sub-superscripts t
        org-export-with-toc nil
        org-latex-packages-alist '(("" "setspace")
                                   ;; https://github.com/gpoore/minted/issues/92
                                   ("cache=false" "minted")
                                   ("" "pdflscape")
                                   ("" "multirow")
                                   ("" "multicol")
                                   ("" "booktabs")
                                   ("" "amsthm")
                                   ("" "amssymb")
                                   ("" "listingsutf8")
                                   ("top=1in, bottom=1in, left=1in, right=1in" "geometry")
                                   ("" "natbib"))
        org-latex-listings 'minted
        org-highlight-latex-and-related '(latex entities script)
        org-latex-pdf-process
        '("pdflatex -shell-escape -output-directory %o %f"
          "biber %b"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

  (general-define-key :keymaps 'org-mode-map :states '(normal visual motion) :prefix "SPC"
    "re" #'org-export-dispatch)
#+end_src

Another way that ~org~ can "export" to other file is by "tangling" source blocks, which means extract the content from source code blocks with ~:tangle~ header, and put them in a separate file.

A problem with the builtin ~org-tangle~ is that it can be slow. Part of the problem is that it runs the appropriate major-mode function and the hooks on every source code block. I disable this behavior.

#+begin_src emacs-lisp
  (defun gatsby:org--fast-tangle (fn &rest args)
    (cl-letf (((symbol-function 'org-src-get-lang-mode) (lambda (&rest _) #'ignore)))
      (apply fn args)))

  (advice-add #'org-babel-tangle :around #'gatsby:org--fast-tangle)
#+end_src

*** org-babel and literate programming

A great feature ~org-mode~ provides is the ability to do literate programming. Literate programming means writing codes while explaining them in nature language. This paradigm can be powerful in making sure the programmer and the audience really understands what the code is trying to do.

There are two components of the literate programming experience offered by the ~org-mode~. The first component provides capability of displaying code. This is provided by the ~org-src~ package. The second component provides capability of running code and printing results. This is provided by the ~org-babel~ package. I configure first the ~org-src~, then the ~org-babel~ package.

**** org-src

When editing a source code block, ~org-mode~ will hide all other buffers and display only the ~org~ buffer and the source code editor. This is suboptimal for me, as other buffers may contain information that I need to refer to when editing the source code block. So I set ~org-src-window-setup~ to ~'plain~ to instruct ~org-mode~ to use the normal ~pop-to-buffer~ to open the source code editor.

#+begin_src emacs-lisp
  (setq org-src-window-setup 'plain)
#+end_src

~org-mode~ like to ask for confirmation before evaluating the source code block to prevent security risk. However, it is likely that I will just blindly hit "y" when asked such question. So I turn it off.

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

If a source block has an open editor attached to it, I want to return to that editor if I try to edit that source block again without confirming.

#+begin_src emacs-lisp
  (setq org-src-ask-before-returning-to-edit-buffer nil)
#+end_src

Make sure that the org buffer is in the ~normal~ state when opening source code editors.

#+begin_src emacs-lisp
  (defun gatsby:org--ensure-normal-state (&rest _)
    (evil-normal-state))

  (advice-add #'org-edit-src-code :before #'gatsby:org--ensure-normal-state)
#+end_src

**** org-babel

To use ~org-babel~ to evaluate source code blocks, I need to register the interpreter with ~org-babel~ by loading ~org-babel-load-languages~. A complication of the issue is that ~nix~ and ~envrc~ allows me to have a buffer local environment, so the list of interpreter I can use is different in different buffers. However, ~org-babel-load-languages~ and ~org-babel-do-load-languages~ do not play well with local variables. Luckily, I do not need to remove languages that are not supported by the local environment. Instead, I can maintain a separate list of available interpreters for autocomplete purposes (see ~src-block~ snippet for more information).

#+begin_src emacs-lisp
  (setq org-babel-load-languages '((emacs-lisp . t)
                                   (shell . t)))

  (defconst gatsby:org-babel-default-interpreters '("emacs-lisp" "shell")
    "List of interpreters that should be available at all environments.")

  (defvar gatsby:org-babel-available-interpreters nil
    "List of interpreters available in the current environment.")

  (make-variable-buffer-local 'gatsby:org-babel-available-interpreters)

  (defvar gatsby:org-babel-hook nil
    "Hook run with `org-mode-hook', but specific to my babel setting.")

  (defun gatsby:org-babel-run-hook ()
    (run-hooks 'gatsby:org-babel-hook))

  (add-hook 'org-mode-hook #'gatsby:org-babel-run-hook)
#+end_src

~org-babel~ is just like a REPL. So I set up the run key binding just like in other REPL models.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'org-mode-map :states '(normal visual motion) :prefix "SPC"
    "rr" #'org-ctrl-c-ctrl-c)
#+end_src

If the result from evaluating a code block contains images, I can run ~org-display-inline-images~ to display those images. Or even better, I can add it to the ~org-babel-after-execute-hook~ so it is ran automatically for me.

#+begin_src emacs-lisp
  (add-hook 'org-babel-after-execute-hook #'org-display-inline-images)
#+end_src

The following function is taken from [[https://github.com/dakra/dmacs/blob/master/init.org#org][here]] to quickly clear all evaluation results.

#+begin_src emacs-lisp
  (defun gatsby:org-remove-all-results ()
    "Remove results from every code block in buffer."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward org-babel-src-block-regexp nil t)
        (org-babel-remove-result))))

  (general-define-key :keymaps 'org-mode-map :states '(normal visual motion) :prefix "SPC"
    "rc" #'gatsby:org-remove-all-results)
#+end_src

~org-async~ allows code in the source code blocks run asynchronously (i.e., non-blocking) so I can keep typing while the code runs in the background.

#+begin_src emacs-lisp
  (use-package ob-async)
#+end_src

** IDE features
*** linting frontend: flymake

Instead of the popular and more powerful ~flycheck~, I use the builtin ~flymake~ package to display syntax error. This is because 1. ~flymake~ integrates better with ~eglot~, my LSP client package than ~flycheck~, and 2, ~flymake~ is good enough for my purpose.

#+begin_src emacs-lisp
  (use-package flymake :hook (prog-mode . flymake-mode))
#+end_src

I do not need to run ~flymake~ too often, so I turn off ~flymake-start-on-newline~. However, I do want to have ~flymake~ run when I enter the normal state.

#+begin_src emacs-lisp
  (setq flymake-start-on-newline nil)

  (defun gatsby:flymake-enter-normal-state-check ()
    "Check for syntax errors when entering normal state"
    (when (bound-and-true-p evil-mode)
      (flymake-log :debug "starting syntax check as entering normal state")
      (flymake-start t)))

  (add-hook 'evil-normal-state-entry-hook #'gatsby:flymake-enter-normal-state-check)
#+end_src

As mentioned in [[fringe bitmaps]], I reserve those real estates for indicating syntax errors.

#+begin_src emacs-lisp
  (define-fringe-bitmap 'gatsby:double-error-bitmap
    [#b11011000
     #b01101100
     #b00110110
     #b00011011
     #b00110110
     #b01101100
     #b11011000])

  (setq flymake-note-bitmap '(gatsby:double-error-bitmap default)
        flymake-warning-bitmap '(gatsby:double-error-bitmap compilation-warning)
        flymake-error-bitmap '(gatsby:double-error-bitmap compilation-error))
#+end_src

~flymake~ has an old-school way of showing syntax error: by adding underline. This is too colorful for me, so I turn it off.

#+begin_src emacs-lisp
  (dolist (face '(flymake-note flymake-warning flymake-error))
    (set-face-attribute face nil :underline nil))
#+end_src

Instead of using underline and a dedicate buffer ~flymake-diagnostics~ , I write a small package that display syntax error in a child frame.

#+begin_src emacs-lisp
  (use-package flymake-childframe
    :straight (flymake-childframe :repo "junyi-hou/flymake-childframe" :host github)
    :hook (flymake-mode . flymake-childframe-mode))
#+end_src

With the help of ~nerd-font~, I could have fancy prefix to indicate the type of syntax issue/error that I have.

#+begin_src emacs-lisp
  (setq flymake-childframe-prefix '((note . "\uf059 ")
                                    (warning . "\uf06a ")
                                    (error . "\uf071 ")))
#+end_src

*** auto-completion: company

~company~ is an autocomplete engine for ~emacs~.

#+begin_src emacs-lisp
  (use-package company)
  (add-hook 'prog-mode-hook #'company-mode)
#+end_src

The way that I design to use ~company~ is as following:

+ Do not automatically show ~tooltip~. Instead, manually call ~company-manual-begin~ to start autocomplete.
+ I want to have ~tab~ to be context-aware and perform as many functions as possible. Including:
  - indent, expand snippet or start autocomplete
+ Take advantage of ~company-search-mode~ to do fuzzy matching of candidates (for example, after start ~company~ mode with prefix "com", type "man beg" will match ~company-manual-begin~)

To achieve this behavior, I first define a ~tab~ command:

#+begin_src emacs-lisp
  (setq company-idle-delay nil
        company-require-match 'never
        company-search-regexp-function #'company-search-words-in-any-order-regexp)

  (defun gatsby:indent-or-complete ()
    "Tab for company, yas, and indentation.
    1, if nothing before the `point', insert `tab-width' number of spaces.
    2, if there is a yas-snippet, expand it.
    3, if 1/2 not satisfies, call `company-manual-begin'."
    (interactive)
    (if (looking-back "\\([[:space:]]+\\|^\\=\\)" (line-beginning-position)) ;; case 1
        (insert-tab)
      (unless (yas-expand) ;; case 2
        ;; case 3
        (unless (symbol-value company-search-mode)
          (company-filter-candidates)))))

  (general-define-key :keymaps 'insert
    "<tab>" 'gatsby:indent-or-complete)
#+end_src

Second, to use ~company-search-mode~ by default, I need to redefine how ~delete~ and insert character work.

#+begin_src emacs-lisp
  (defun gatsby:company-filter-delete ()
    "improve `company-search-delete-char'."
    (if (string= company-search-string "")
        (progn
          (company-search-abort)
          (call-interactively #'backward-delete-char-untabify)
          (company-filter-candidates))
      (let ((ss (substring company-search-string 0 -1)))
        (when company-search-filtering
          (company--search-update-predicate ss))
        (company--search-update-string ss))))

  (advice-add #'company-search-delete-char :override #'gatsby:company-filter-delete)

  (defun gatsby:company-filter-abort ()
    "Abort both the `company-search-mode' and the `company-mode'"
    (interactive)
    (ignore-errors (company-search-abort))
    (company-abort))
#+end_src

I try to use the same set of key bindings for mini buffer selection and autocompletion.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'company-active-map
    "M-j" 'company-select-next
    "M-k" 'company-select-previous
    "<tab>" 'company-complete-selection)

  (general-define-key :keymaps 'company-search-map
    "M-j" 'company-select-next
    "M-k" 'company-select-previous
    "C-g" 'gatsby:company-filter-abort
    "<tab>" 'company-complete-selection)
#+end_src

When I type ".", "," or "(" when ~company~ is active, it should exit with the current selection. ~company~ has a builtin variable ~company-auto-commit-char~. If the input event matches any element in this list, ~company~ will exit with the current selection and then insert the character associated with the input event to the buffer. However, this method is not available in ~company-search-mode~. I define a ~complete-and-insert-char~ to mimic this behavior.

#+begin_src emacs-lisp
  (setq company-auto-commit-chars '(?\( ?. 44))

  (defun gatsby:company-complete-and-insert-char (char)
    "Complete with the current selection and insert CHAR."
    (company-complete-selection)
    (insert (char-to-string char)))

  ;; bind auto complete chars in `company-search-map'
  (--each company-auto-commit-chars
    (define-key company-search-map (char-to-string it)
      (lambda () (interactive) (gatsby:company-complete-and-insert-char it))))
#+end_src

I am using ~tab~ to select the current candidate and quit autocomplete. ~flymake~'s auto checking timer interference with this goal. Therefore I want to turn ~flymake~'s auto checking timer off.

#+begin_src emacs-lisp
  (with-eval-after-load 'flymake
    (setq flymake-no-changes-timeout nil))
#+end_src

There are two sets of options governing how ~company~ finds potential candidates and presents them to the user: ~company-frontend~ and ~company-backends~. I use the builtin ~tooltip~ frontend.

#+begin_src emacs-lisp
  (setq company-show-numbers t
        company-tooltip-limit 10
        company-tooltip-align-annotations t
        company-selection-wrap-around t
        company-auto-commit t)
#+end_src

Now the backends.

#+begin_src emacs-lisp
  (setq company-dabbrev-downcase nil
        company-dabbrev-ignore-case nil
        company-dabbrev-code-other-buffers nil
        company-backends '((company-semantic company-capf :with company-yasnippet)
                           company-files
                           (company-dabbrev-code
                            company-keywords
                            company-abbrev)
                           company-dabbrev))
#+end_src

Finally, ~prescient~ (introduced in the [[prescient]] section) provides a nice sorting mechanism for ~company~ depend on selection history and other stuffs.

#+begin_src emacs-lisp
  (use-package company-prescient :hook (company-mode . company-prescient-mode))
#+end_src

This concludes the settings for ~company~.

*** snippet: yasnippet

~yasnippet~ is the goto snippet engine for ~emacs~.

#+begin_src emacs-lisp
  (use-package yasnippet
    :hook
    (company-mode . yas-reload-all)
    (company-mode . yas-minor-mode))
#+end_src

There are several changes I want to make on the behaviors of ~yasnippet~ when inside snippets. First, I want to be able to expand snippets within snippet

#+begin_src emacs-lisp
  (setq yas-triggers-in-field t)
#+end_src

Second, sometimes I need to go back to a (modified) snippet field and change its content. However, ~yasnippet~ makes this difficult: it goes back to the beginning of the field, and hitting ~delete~ will go out of a snippet field (therefore forcefully exit the snippet). To make changes, I need to move my cursor to the appropriate position of the field first. This is annoying. Therefore I improve the ~delete~ in ~yasnippet~ to allow me to delete the whole field if I am at the beginning of the a field, regardless of whether the field has modified or not.

#+begin_src emacs-lisp
  (defun gatsby:yas--clear-field-filter (cmd)
    "Clear field regardless of whether it has been modified or not.
  This make sure that if I backtab into a modified field I can still hit <Del> and delete the whole field."
    (let ((field (yas-current-field)))
      (when (and field
                 (eq (point) (marker-position (yas--field-start field))))
        cmd)))

  (advice-add #'yas--maybe-clear-field-filter :override #'gatsby:yas--clear-field-filter)

  (defun gatsby:yas-better-backspace ()
    "If `point' is at the beginning of an unmodified yas-field, delete the field, otherwise backwards delete char."
    (interactive)
    (cond ((yas--maybe-clear-field-filter t)
           (yas--skip-and-clear (yas-current-field)))
          (t (call-interactively #'backward-delete-char-untabify))))

  (general-define-key :keymaps 'yas-keymap "<backspace>" 'gatsby:yas-better-backspace)
#+end_src

*** LSP: eglot

~eglot~ is an excellent light-weight LSP client that requires very little configuration. On the other hand, it does not provide the fancy UI like ~LSP~ mode does with document, peak definition, jump to definition/reference etc. But these functionalities are easy to implement with the help of ~eglot~.

#+begin_src emacs-lisp
(use-package eglot
  :custom-face
  ;; less invasive symbol highlight
  (eglot-highlight-symbol-face ((t :underline t))))
#+end_src

I also don't want ~eglot~ to change my ~company-backends~ setting.

#+begin_src emacs-lisp
  (setq eglot-stay-out-of '(company))
#+end_src

*** REPL

Read-Evaluate-Print-Loop (REPL) is a convenient way to do try-and-error programming. It allows me to
+ code up a snippet
+ evaluate it
+ see print out for result
+ continue until finish the job.

In some way, REPL provides shell-like environment for other programming languages.

**** comint-mode

~comint-mode~ is a builtin REPL mode that serves as the basis of many REPL defined in ~emacs~. Therefore, by configuring ~comint-mode~, I can simultaneously configure many REPL settings.

#+begin_src emacs-lisp
  (use-package comint  :straight (:type built-in))
#+end_src

Like in ~eshell~, the last prompt is always the most important prompt. Therefore it is useful to jump to there with a single keystroke.

#+begin_src emacs-lisp
  (defun gatsby:comint-goto-last-prompt ()
    "Goto current prompt and continue editting."
    (interactive)
    (goto-char (point-max))
    (evil-insert 1))
#+end_src

Anther place where I would like to have consistent with the ~eshell~ is to clear the current REPL buffer.

#+begin_src emacs-lisp
  (defun gatsby:comint-cls ()
    "clear current REPL buffer."
    (interactive)
    (let ((comint-buffer-maximum-size 0))
      (comint-truncate-buffer)))
#+end_src

~comint~ mode sends codes to the inferior interpreter too often. In particular, I want to send codes only when the parentheses are balanced /before/ the point. Otherwise insert a newline character.

#+begin_src emacs-lisp
  (defun gatsby:comint-return ()
    "<return> sends a newline character, and double <return> sends `comint-send-input'."
    (interactive)
    (let* ((text-before-point (buffer-substring (save-excursion (comint-bol)) (point)))
           (open-b (s-count-matches "\\[" text-before-point))
           (close-b (s-count-matches "\\]" text-before-point))
           (open-c (s-count-matches "{" text-before-point))
           (close-c (s-count-matches "}" text-before-point))
           (open-p (s-count-matches "(" text-before-point))
           (close-p (s-count-matches ")" text-before-point)))
      (if (or (eq last-command this-command)
              (and (= open-b close-b)
                   (= open-c close-c)
                   (= open-p close-p)))
          (call-interactively 'comint-send-input)
        (call-interactively 'newline))))
#+end_src

By default, there is no builtin communication mechanism between the REPL buffer and the code buffer. To send code from the code buffer to the REPL buffer, I have to manually yank the code I want to evaluate from the code buffer, and copy it to the REPL buffer. This is obvious suboptimal. Therefore, I define a local variable in the code buffer called ~gatsby:comint-repl-buffer~, which records which REPL buffer is associated with the current buffer. With this information, ~gatsby:comint-eval-X~ functions can be called to send codes from the current buffer to the REPL buffer.

#+begin_src emacs-lisp
  (defcustom gatsby:comint-repl-mode-alist nil
    "An alist of (code-buffer-mode . repl-mode)."
    :type 'alist
    :group 'comint)

  (defvar-local gatsby:comint-repl-buffer nil
    "The repl associated to the current buffer.")

  (defun gatsby:comint-associate-repl ()
    "Select a repl of mode REPL-MODE and associate the current buffer to that repl."
    (interactive)
    (let* ((repl-mode (cdr (assq major-mode gatsby:comint-repl-mode-alist)))
           (candidates (-map 'buffer-name
                             (--filter
                              (with-current-buffer it
                                (eq major-mode repl-mode))
                              (buffer-list))))
           (repl-name (completing-read "Choose REPL to associate to: "
                                       (or candidates (buffer-list)))))

      (setq gatsby:comint-repl-buffer (get-buffer repl-name))))

  (general-define-key :keymaps 'comint-mode-map :states '(normal visual motion emacs insert) :prefix "C-c"
    "C-l" 'gatsby:comint-cls
    "C-c" 'comint-interrupt-subjob)

  (general-define-key :keymaps 'comint-mode-map :states 'insert
    "<up>" 'comint-previous-matching-input-from-input
    "<down>" 'comint-next-matching-input-from-input
    "<return>" 'gatsby:comint-return)

  (general-define-key :keymaps 'comint-mode-map :states '(normal motion visual insert emacs)
    "C-j" 'evil-window-down
    "C-d" 'evil-scroll-down)

  (general-define-key :keymaps 'comint-mode-map :states '(normal motion visual)
    "<" 'comint-previous-prompt
    ">" 'comint-next-prompt
    "A" 'gatsby:comint-goto-last-prompt
    "H" 'comint-bol
    "SPC" 'nil)
#+end_src

Different programming language uses different functions to call REPL. I need an interface to interact with those functions to create REPL buffers. To this end, I define a dictionary holding the relationship between major-mode and the corresponding REPL function.

#+begin_src emacs-lisp
  (defcustom gatsby:comint-repl-function-alist nil
    "An alist of (code-buffer-mode . (function to call REPL . argument if any))."
    :type 'alist
    :group 'comint)

  (defun gatsby:comint--start-repl (repl-fn &rest args)
    "Start a REPL in the background using REPL-FN with ARGS."
    (let ((code-buffer (current-buffer))
          (display-buffer-alist `(,(cons "*" (cons #'display-buffer-no-window nil)))))
      (let ((repl-buffer (apply repl-fn args)))
        (with-current-buffer code-buffer
          (setq-local gatsby:comint-repl-buffer repl-buffer)))))

  (defun gatsby:comint--pop-to-repl ()
    "Switch to `gatsby:comint-repl-buffer' associated with the current buffer."
    (if (and gatsby:comint-repl-buffer
             (buffer-live-p gatsby:comint-repl-buffer))
        (progn
          (pop-to-buffer gatsby:comint-repl-buffer)
          (select-window (get-buffer-window gatsby:comint-repl-buffer)))
      (user-error "Buffer not associated with a REPL")))

  (defun gatsby:comint-start-or-pop-to-repl ()
    "Start (or pop to the existing) repl buffer for the current buffer."
    (interactive)
    (unless (and gatsby:comint-repl-buffer
                 (buffer-live-p gatsby:comint-repl-buffer))
      (apply #'gatsby:comint--start-repl
             (cdr (assq major-mode gatsby:comint-repl-function-alist))))
    (gatsby:comint--pop-to-repl))
#+end_src

Finally, I need to define functions that send codes from the code buffer to the REPL buffer, stored in the ~gatsby:comint-repl-buffer~ variable.

#+begin_src emacs-lisp
  (defun gatsby:comint--send-code-to-repl (send-fn string)
    "Send STRING using SEND-FN to the associated buffer for evaluation."
    (if gatsby:comint-repl-buffer
        (with-current-buffer gatsby:comint-repl-buffer
          (goto-char (point-max))
          (let ((bol (save-excursion
                       (comint-bol))))
            (delete-region bol (point-max)))
          (insert string)
          (funcall send-fn))
      (user-error "Associated REPL not found")))

  (defun gatsby:comint--eval-region (send-fn beg end)
    (gatsby:comint--send-code-to-repl send-fn (buffer-substring-no-properties beg end))
    (deactivate-mark))

  (defun gatsby:comint-eval-region-or-line ()
    (interactive)
    (if (region-active-p)
        (gatsby:comint--eval-region 'comint-send-input
                                    (region-beginning) (region-end))
      (gatsby:comint--send-code-to-repl 'comint-send-input
                                        (thing-at-point 'line 'no-properties))))

  (defun gatsby:comint-eval-buffer ()
    (interactive)
    (gatsby:comint--send-code-to-repl
     'comint-send-input
     (buffer-substring-no-properties (point-min) (point-max))))
#+end_src

When shutting down REPL buffers, clean up the ~gatsby:comint-repl-buffer~ variable for all code buffer that associated with it.

#+begin_src emacs-lisp
  (defun gatsby:comint-exit-repl ()
    "When quitting repl buffer, reset `gatsby:comint-repl-buffer' for all associated code buffers."
    (interactive)
    (when (y-or-n-p "Really quit this REPL? ")
      (let ((repl-buffer (current-buffer)))
        (--each (--filter (with-current-buffer it (eq gatsby:comint-repl-buffer repl-buffer))
                          (buffer-list))
          (with-current-buffer it
            (setq-local gatsby:comint-repl-buffer nil))))
      (kill-buffer-and-window)))

  (general-define-key :keymaps 'comint-mode-map :states '(normal motion visual) :prefix "SPC"
    "q" 'gatsby:comint-exit-repl)
#+end_src

This concludes the configuration for ~comint~ mode.

**** jupyter

The builtin ~comint~ mode lacks some features important for data scientists. For example, there is no easy way to display graph in the REPL buffer. ~jupyter~ provides a nice REPL platform for almost all data science-y languages that addresses those shortcomings of ~comint~ mode. There are two attempts to integrate ~jupyter~ with ~emacs~: the first is the ~ein~ package, which provides a fully-fledged ~jupyter~ notebook frontend. the second is the ~emacs-jupyter~ package, which is less ambitious in its scope and provide mainly the REPL thought a dedicated REPL mode (that works like ~jupyter-console~) and an org-babel integration. Since I do not need the fancy features of the notebook, I use the ~emacs-jupyter~ package.

#+begin_src emacs-lisp
  (use-package jupyter
#+end_src

As of March 1st 2021, ~emacs-jupyter~ does not play well with the native-comp of ~emacs~ (discussed [[https://github.com/nnicandro/emacs-jupyter/issues/297][here]]). I instruct ~straight~ to turn off native-complie for ~emacs-jupyter~.

#+begin_src emacs-lisp
  :straight
  (:no-native-compile t :host github :repo "nnicandro/emacs-jupyter")
#+end_src

I first need to fix some issues of ~emacs-jupyter~. Its traceback face does not have the ~extend~ keywords added in ~emacs~ 27.1.

#+begin_src emacs-lisp
  :custom-face
  (jupyter-repl-traceback ((t (:extend t :background "firebrick")))))
#+end_src

~emacs-jupyter~ doesn't play well with indented codes and text properties (see discussion [[https://github.com/nnicandro/emacs-jupyter/issues/314][here]]). I amend these problems with the following advises.

#+begin_src emacs-lisp
  (defun gatsby:jupyter-repl-cell-code ()
    "Return the code of the current cell, tweaked to stripped text properties to make sure things like `highlight-indent-guides' does not get picked up."
    (buffer-substring-no-properties
     (jupyter-repl-cell-code-beginning-position)
     (jupyter-repl-cell-code-end-position)))

  (advice-add #'jupyter-repl-cell-code :override #'gatsby:jupyter-repl-cell-code)

  (defun gatsby:jupyter--encode-before-eval (fn &rest args)
    "advice `jupyter-eval-string' to encode first the strings with utf-8."
    (let (str)
      (if (cdr args)
          (setq str (apply #'buffer-substring-no-properties (cdr args)))
        (setq str (car args)))
      (funcall fn (encode-coding-string str 'utf-8))))

  (advice-add #'jupyter-eval-string :around #'gatsby:jupyter--encode-before-eval)
#+end_src

~emacs-jupyter~ also have issues on the font locks it uses (see discussion [[https://github.com/nnicandro/emacs-jupyter/issues/219][here]]), I need to temporarily disable font look in the REPL buffer for now.

#+begin_src emacs-lisp
  (defun jupyter-repl-font-lock-override (_ignore beg end &optional verbose)
    `(jit-lock-bounds ,beg . ,end))

  (advice-add #'jupyter-repl-font-lock-fontify-region :override #'jupyter-repl-font-lock-override)
#+end_src

~emacs-jupyter~ sets up its own ~isearch~ functions that do not interact well with evil search. I turn these isearch functions off.

#+begin_src emacs-lisp
  (advice-add #'jupyter-repl-isearch-setup :override #'ignore)
#+end_src

Finally, ~emacs-jupyter~ uses many ~emacs~ infrastructures that circumvented the ~envrc~ modifications of the process environment. This includes:

+ ~jupyter-command~ uses a ~with-temp-buffer~ to gather outputs, which will be running in the default process environment instead of the local one.
+ ~jupyter--kernelspecs~ won't be automatically refreshed when calling ~jupyter-run-repl~, so the local kernel may not be picked up correctly.

I make necessary changes to the aforementioned points to ensure that ~emacs-jupyter~ play well with ~envrc~.

#+begin_src emacs-lisp
  (advice-add #'jupyter-command :around #'envrc-propagate-environment)

  (defun gatsby:jupyter--maybe-update-kernelspecs (&rest _)
    "Update kernelspecs if necessary."
    (when (envrc--find-env-dir)
      (jupyter-available-kernelspecs 'refresh)))

  (advice-add #'jupyter-run-repl :before #'gatsby:jupyter--maybe-update-kernelspecs)
#+end_src

Second, the customization. I want to have the code I send to REPL displayed on it.

#+begin_src emacs-lisp
  (setq jupyter-repl-echo-eval-p t)
#+end_src

I also want to limit the REPL buffer size for performance reason.

#+begin_src emacs-lisp
  (setq jupyter-repl-maximum-size 12000)
#+end_src

I want to have a reasonably long enough history that I can search for.

#+begin_src emacs-lisp
  (setq jupyter-repl-history-maximum-length 5000)
#+end_src

~emacs-jupyter~ won't pop up REPL when sending codes to it if the REPL buffer is not displayed. Rather, it will run the code in background and echo/pop up a separate buffer to display result of the code. This behavior may make sense for other people, but it is certainly not the way I want to use it. Thus, I advice it to always pop-up the REPL buffer before running any code sent to it.

#+begin_src emacs-lisp
  (defun gatsby:jupyter--pop-repl (&rest _)
    "Pop repl buffer, then go back to the code buffer."
    (let* ((code-buffer (current-buffer)))
      (jupyter-repl-pop-to-buffer)
      (switch-to-buffer-other-window code-buffer)))

  (advice-add #'jupyter-eval-line-or-region :before #'gatsby:jupyter--pop-repl)
#+end_src

On a similar note, ~emacs-jupyter~ won't exit the visual mode when sending a code region to it. I change it so I don't need to hit ~esc~ to go back to the normal state after evaluating code blocks.

#+begin_src emacs-lisp
  (defun gatsby:jupyter--deactivate-mark (&rest _)
    "Deactivate mark, use &rest to satisfies the number of arguments"
    (deactivate-mark))

  (advice-add #'jupyter-eval-region :after #'gatsby:jupyter--deactivate-mark)
#+end_src

Third, I want to have consistent interface to the REPL buffer as in ~eshell~ and ~comint~ modes.

#+begin_src emacs-lisp
  (defun gatsby:jupyter-goto-last-prompt ()
    "Goto current prompt and continue editting."
    (interactive)
    (goto-char (point-max))
    (evil-insert 1))

  (defun gatsby:jupyter-clear-buffer ()
    "Jupyter REPL version of `cls'."
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)
      (jupyter-send-input)))

  (general-define-key :keymaps 'jupyter-repl-mode-map :states '(normal visual motion)
    "A" 'gatsby:jupyter-goto-last-prompt
    "<" 'jupyter-repl-backward-cell
    ">" 'jupyter-repl-forward-cell
    "SPC" nil)

  (general-define-key :keymaps 'jupyter-repl-mode-map :states '(normal visual motion) :prefix "C-c"
    "C-c" 'jupyter-repl-interrupt-kernel
    "C-l" 'jupyter-repl-clear-cells)

  (general-define-key :keymaps 'jupyter-repl-mode-map :states '(normal visual motion) :prefix "SPC"
    "q" 'kill-buffer-and-window)

  (general-define-key :keymaps 'jupyter-repl-mode-map :states 'insert
    "<up>" 'jupyter-repl-history-previous-matching
    "<down>" 'jupyter-repl-history-next-matching)
#+end_src

Similar to the ~comint~ mode, I provide an uniform entry point for creating and switching to ~jupyter~ REPL. To do so, I first define a variable that associates major-modes to the jupyter kernel that should be called.

#+begin_src emacs-lisp
  (defcustom gatsby:jupyter-repl-function-alist nil
    "An alist of (code-buffer-mode . action), where action can be:
  - a string indicating the kernel name should be called in CODE-BUFFER-MODE
  - a function with no argument that should be called to start the corresponding jupyter REPL in CODE-BUFFER-MODE"
    :type 'alist
    :group 'jupyter)
#+end_src

With the help of ~gatsby:jupyter-repl-function-alist~, I can define command that starts or switch to the existing REPL.

#+begin_src emacs-lisp
  (defun gatsby:jupyter-start-or-switch-to-repl ()
    "Switch to REPL associated the current buffer.  If there is no REPL associated with the current buffer, start one according to KERNEL type."
    (interactive)
    (if (and jupyter-current-client
             (jupyter-kernel-alive-p jupyter-current-client))
        (jupyter-repl-pop-to-buffer)
      (let ((code-buffer (current-buffer))
            (major-mode-action (cdr (assq major-mode gatsby:jupyter-repl-function-alist))))
        (cond ((stringp major-mode-action)
               (jupyter-run-repl major-mode-action major-mode-action (current-buffer) nil t))
              ((functionp major-mode-action)
               (funcall major-mode-action))
              (t (call-interactively 'jupyter-run-repl)))
        (switch-to-buffer-other-window code-buffer))))
#+end_src

Enable autocompletion within the REPL mode.

#+begin_src emacs-lisp
  (add-hook 'jupyter-repl-mode-hook #'company-mode)
#+end_src

Enable ligature in jupyter REPL mode:

#+begin_src emacs-lisp
  (add-to-list 'ligature-composition-table
               `(jupyter-repl-mode ,@(cdr (assq 'prog-mode ligature-composition-table))))
#+end_src

~emacs-jupyter~ also provides a better integration with ~org-babel~ than the builtin ~ob-ipython~. However, it requires some setup due to my localized environment.

First, according to the [[https://github.com/nnicandro/emacs-jupyter#org-mode-source-blocks][documentation]], I need to load all languages that I want to use jupyter kernel for first, and then ~jupyter~ at the last position, so it can overshadow some function defined in those libraries.

To accommodate this requirement, I first append ~jupyter~ to the end of ~org-babel-load-languages~.

#+begin_src emacs-lisp
  (add-to-list 'org-babel-load-languages '(jupyter . t) 'append)
#+end_src

Second, I want to add any missing kernels to ~org-babel-load-languages~ before ~jupyter~ if I find the kernel available in the current local environment. As I alluded to in [[org-babel]], I do not need to take it out if those kernels become unavailable in other environments.

#+begin_src emacs-lisp
  (defun gatsby:jupyter--register-local-kernels (kernel-names)
    ;; fix stata kernel issues
    (when (and (member "stata" kernel-names)
               (not (boundp 'inferior-STA-program-name)))
      (setq inferior-STA-program-name "stata-mp"))

    ;; load languages
    (let ((interpreters `(,@(butlast org-babel-load-languages)
                          ,@(--map `(,(intern it) . t) kernel-names)
                          ,@(last org-babel-load-languages))))
      (org-babel-do-load-languages 'org-babel-load-languages interpreters)))
#+end_src

I also want to register available kernels to ~gatsby:org-babel-available-interpreters~ so I can use them in the ~src-block~ snippet.

#+begin_src emacs-lisp
  (defun gatsby:jupyter--update-available-interpreters (kernel-names)
    (setq-local gatsby:org-babel-available-interpreters
                `(,@gatsby:org-babel-default-interpreters
                  ,@(--map (format "jupyter-%s" it) kernel-names))))
#+end_src

Third, instead of using ~ob-async~, ~ob-jupyter~ uses its own ~:async~ keyword to manage asynchronous kernel execution. I need to modify ~ob-async-no-async-languages-alist~ as per the [[https://github.com/nnicandro/emacs-jupyter][document]].

#+begin_src emacs-lisp
  (make-variable-buffer-local 'ob-async-no-async-languages-alist)

  (defun gatsby:jupyter--enable-async-block (kernel-names)
    ;; let jupyter manager its own async state
    (setq-local ob-async-no-async-languages-alist
                `(,@(--map (format "jupyter-%s" it) kernel-names)))

    ;; set jupyter languages default header argument
    (--each kernel-names
      (eval `(setq ,(intern (format "org-babel-default-header-args:jupyter-%s" it))
                   (quote ((:async . "yes")
                           (:session . ,it)
                           (:kernel . ,it)))))))
#+end_src

Putting them together, ~gatsby:jupyter--prepare-local-env-for-org~ will check the available kernels and modify all variables accordingly.

#+begin_src emacs-lisp
  (defun gatsby:jupyter--pre-are-local-env-for-org ()
    (let* ((_kernels (jupyter-available-kernelspecs 'refresh))
           (kernel-names (--map (plist-get (cddr it) :language) _kernels)))
      (gatsby:jupyter--register-local-kernels kernel-names)
      (gatsby:jupyter--update-available-interpreters kernel-names)
      (gatsby:jupyter--enable-async-block kernel-names)))

  (add-hook 'gatsby:org-babel-hook #'gatsby:jupyter--pre-are-local-env-for-org)
#+end_src

This concludes the configuration for ~emacs-jupyter~.

**** emacs-ipython-notebook

I do not use ~jupyter notebook~, but I need an interface to read ~.ipynb~ files. ~emacs-ipython-notebook~ (~ein~) is an all-in-one packages that deals with ~.ipynb~ files.

#+begin_src emacs-lisp
  (use-package ein)
#+end_src

Set ~ein:output-area-inlined-images~ to ~t~ so ~ein~ can display inline images.

#+begin_src emacs-lisp
  (setq ein:output-area-inlined-images t)
#+end_src

*** spelling and grammar checks

I am not a native speaker. This makes spelling and grammar checkers very helpful for my writing.

To check spelling, I use ~flyspell~ and ~flyspell-correct~ frontend, which in turn rely on ~ispell~, ~aspell~, or ~hunspell~ command line utility.

#+begin_src nix :noweb-ref home-manager
  home.packages = with pkgs; [
    aspell aspellDicts.en aspellDicts.en-computers aspellDicts.en-science
  ];
#+end_src

#+begin_src emacs-lisp
  (use-package flyspell-correct)
#+end_src

When in ~text-mode~, I want the spelling checker to check all my text. But when in ~prog-mode~, I want it to check only string literals and comments. ~flyspell~ mode has a ~flyspell-mode~ for the former, and ~flyspell-prog-mode~ for the latter.

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook #'flyspell-mode)
  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
#+end_src

~selectrum~ can be used to present alternatives of misspelled words. For that, I need to customize ~flyspell-correct-interface~ variable:

#+begin_src emacs-lisp
  (defun gatsby:style-flyspell-correct-selectrum (candidates word)
    "Run `completing-read' for the given CANDIDATES

  List of CANDIDATES is given by flyspell for the WORD."
    (let* ((selectrum-should-sort-p nil)
           (save "[SAVE]")
           (accept-session "[ACCEPT (session)]")
           (accept-buffer "[ACCEPT (buffer)]")
           (skip "[SKIP]")
           (result (completing-read
                    (format "Correcting '%s': " word)
                    (append (list save accept-session accept-buffer skip)
                            candidates)
                    nil nil nil nil (car candidates))))
      (cond
       ((string= result save)
        (cons 'save word))
       ((string= result accept-session)
        (cons 'session word))
       ((string= result accept-buffer)
        (cons 'buffer word))
       ((string= result skip)
        (cons 'skip word))
       (t
        result))))

  (setq flyspell-correct-interface #'gatsby:style-flyspell-correct-selectrum)
#+end_src

To check grammar, I use ~langtool~, which uses ~languagetool~ as backend. ~langtool~ is a fairly old package, and it does not support checking grammar on-the-go. So I am thinking about writing/updating a new ~languagetool~ integration.

#+begin_src nix :noweb-ref home-manager
    home.packages = [ pkgs.languagetool ];
#+end_src

As per [[https://github.com/mhayashi1120/Emacs-langtool][its document]], I need to set ~langtool-bin~ before loading the package.

#+begin_src emacs-lisp
  (setq langtool-bin "languagetool-commandline")
  (use-package langtool)
#+end_src

I want to make two changes to ~langtool~. First, I want to use ~eldoc-box~ to display ~langtool~ information.

#+begin_src emacs-lisp
  (defun gatsby:langtool--display-message (overlays)
    (let ((msg (langtool-details-error-message overlays)))
      (eldoc-box--eldoc-message-function msg)))

  (setq langtool-autoshow-message-function #'gatsby:langtool--display-message)
#+end_src

Second, ~langtool~ uses two commands (~langtool-check~ and ~langtool-check-done~) to start and clear the grammar checker. I want to use just one function, which I call ~gatsby:langtool-toggle~:

#+begin_src emacs-lisp
  (defvar gatsby:langtool--in-process nil
    "Non-nil means we are in the process of checking grammar.")

  (defun gatsby:langtool-toggle (&optional lang)
    "Toggle languagetool check."
    (interactive (when current-prefix-arg
                   (list (langtool-read-lang-name))))
    (if gatsby:langtool--in-process
        (progn
          (langtool-check-done)
          (setq gatsby:langtool--in-process nil))
      (langtool-check-buffer lang)
      (setq gatsby:langtool--in-process t)))

  (add-hook 'langtool-noerror-hook (lambda (&rest _) (setq gatsby:langtool--in-process nil)))
#+end_src

Finally, add key bindings for quick typo correction and grammar checking

#+begin_src emacs-lisp
  (general-define-key :keymaps '(motion normal visual) :prefix "SPC"
    "cc" 'flyspell-correct-wrapper
    "cg" 'gatsby:langtool-toggle)
#+end_src

** Window Manager Integration

Window manager cannot manage window in ~emacs~. This means I need two sets of bindings to move/manage windows. One for ~emacs~, and another for the window manager. To deal with this issue, I write a small package that allow the same set of binding applies to both ~emacs~ and the window manager.

#+begin_src emacs-lisp
  (use-package i3-mode
    :straight (:host github :repo "junyi-hou/i3-mode" :files ("i3-mode.el" "i3-call" "sway-call")))
#+end_src

Following the example given in its [[https://github.com/junyi-hou/i3-mode][readme]], I define the keys I want to use in both ~emacs~ and the window manager.

#+begin_src emacs-lisp
  (setq gatsby:i3-bindings
        '((?\C-l . "focus right")
          (?\C-h . "focus left")
          (?\C-k . "focus up")
          (?\C-j . "focus down")))

  (defun gatsby:i3--key-binding-config ()
    "Append STR with the key bindings settings according to `i3-bindings' in i3 configuration format. Return the appended string"
    (with-temp-buffer
      (let ((key-binding-string "\n"))
        (dolist (binding gatsby:i3-bindings)
          (let* ((mod (--> (car binding)
                        (event-modifiers it)
                        (-map 'symbol-name it)
                        (-map 's-capitalize it)
                        (s-join "+" it)))
                 (key (-> (car binding)
                          event-basic-type vector (key-description nil)))
                 (script (if (eq i3-flavor 'sway) "sway-call" "i3-call"))
                 (cmd (concat script " "
                              (cdr binding) " "
                              (-> (car binding) vector key-description))))
            (setq key-binding-string
                  (concat key-binding-string
                          "bindsym " mod "+" key " exec --no-startup-id " cmd "\n"))))
        (insert key-binding-string))
      (buffer-string)))

  (add-to-list 'i3-extra-config #'gatsby:i3--key-binding-config)
#+end_src

Two system level adjustments need to be made in order to use ~i3-mode~.
First, I need to install ~jq~, as it is required to use under ~sway~. Second, I need to include ~$HOME/.local/bin~ in my ~$PATH~ variable, as ~i3-mode~ places scripts in this directory.

#+begin_src nix :noweb-ref home-manager
  home = {
    packages = [ pkgs.jq ];
    sessionPath = [ "$HOME/.local/bin" ];
  };
#+end_src

Instead of automatically enable ~i3-mode~. I enable it if I really need it (e.g., when writing paper so I need to jump quickly between ~emacs~ and my pdf viewer).

* Secret Management

~emacs~ is not only a text editor, it can also serve as the integrated interface between the user (me) and the computer, via its ability to spawn subprocesses and present them in text form. In particular, ~emacs~ can be used to manage secrets like passwords and tokens.

** account setting

I use ~home-manager~ to configure my [[accounts][account information]] (email addresses and secrets). I then write a [[accounts][simple script]] to include these information to ~elisp~ form and include here.

#+begin_src emacs-lisp
  (add-to-list 'load-path (expand-file-name "site-lisp" user-emacs-directory))
  (require 'gatsby:accounts)
#+end_src

** epa

~epa~ is the builtin ~emacs~ interface with the open source authentication and encryption tool ~GPG~. With it, I can use ~emacs~'s minibuffer to read and cache passwords.

First, I include ~GPG~ in my ~home-manager~ system.

#+begin_src nix :noweb-ref home-manager
  programs = {
    gpg = {
      enable = true;
      settings.use-agent = true;
    };

    ssh.enable = true;
  };

  home = {
    packages = [ pkgs.openssh ];
    sessionVariales.SSH_AUTH_SOCK = "$(gpgconf --list-dirs agent-ssh-socket)";
    activation = {
        setGpgPermission = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
          $DRY_RUN_CMD find ~/.gnupg -type f -exec chmod 600 {} \;
          $DRY_RUN_CMD find ~/.gnupg -type d -exec chmod 700 {} \;
        '';
    };
  };

  services = {
      gpg-agent = {
        enable = true;
        enableSshSupport = true;
        sshKeys = [ "6E818AFD37FF53D40D410CEED290B5EC7D476683" ];
        defaultCacheTtl = 720000; # 200 hours
        maxCacheTtl = 720000;
        defaultCacheTtlSsh = 720000;
        maxCacheTtlSsh = 720000;
        pinentryFlavor = "tty";
        extraConfig = ''
          allow-emacs-pinentry
        '';
      };
  };
#+end_src

Second, I enable ~epa~ package in ~emacs~.

#+begin_src emacs-lisp
  (use-package epa

    :custom
    (epg-pinentry-mode 'loopback)
    (epa-file-cache-passphrase-for-symmetric-encryption t)
    (epa-file-encrypt-to user-mail-address)
    (password-cache t)
    (password-cache-expiry 720000))
#+end_src

** password-store

~pass~ is an open source software that manages passwords secret management tool that builds on ~GPG~. ~password-store~ provides an ~emacs~ interface with ~pass~

First, install the ~pass~ package using ~home-manager~.

#+begin_src nix :noweb-ref home-manager
  programs.password-store = {
    enable = true;
    settings = {
      PASSWORD_STORE_DIR = "${homeDir}/.password-store";
    };
  };
#+end_src

Second, enable ~password-store~ package to interacting with ~pass~ inside ~emacs~.

#+begin_src emacs-lisp
  (use-package password-store)
#+end_src

Set the default password length to 16.

#+begin_src emacs-lisp
  (setq password-store-password-length 16)
#+end_src

The default setting in ~password-store~ do not check for potential duplicates when generating new secrets. I add the following function to make sure that I do not accidentally override an existing entry when generating new secrets.

#+begin_src emacs-lisp
  (defun gatsby:password-store-generate (entry &optional password-length)
    "Generate a new password for ENTRY with PASSWORD-LENGTH, checking for duplicates first."
    (interactive (list (read-string "Password entry: ")))
    (let ((password-length (or password-length password-store-password-length)))
      ;; (message (concat "~/.password-store/" entry ".gpg"))
      (when (file-exists-p (concat "~/.password-store/" entry ".gpg"))
        (unless (y-or-n-p (concat entry " already exists, override?"))
          (user-error "Aborting")))
      (password-store--run-generate entry password-length t)))
#+end_src

I also want to put the newly generated secret entry into the kill ring, which makes it easy to copy to other places that demand the secret (e.g., the password field of an account registration page)

#+begin_src emacs-lisp
  (advice-add #'password-store--run-generate
              :after (lambda (entry &rest args) (password-store-copy entry)))
#+end_src

Define the entry points for ~password-store~

#+begin_src emacs-lisp
  (general-define-key :keymaps '(normal visual motion) :prefix "SPC"
    "pc" 'password-store-copy
    "pg" 'gatsby:password-store-generate)
#+end_src

** sudo-edit

Sometimes I need to edit some file as ~root~. One way to do it is to close the file and re-open it with ~sudo~ in ~eshell~. I find this process suboptimal. So I use ~sudo-edit~, which allows me to become the ~root~ user and edit the current buffer.

#+begin_src emacs-lisp
  (use-package sudo-edit)
#+end_src

~sudo-edit~ also offers a global minor mode ~sudo-edit-indicator-mode~, which adds a banner on top of the current buffer to remind me that I am editing this file as ~root~.

#+begin_src emacs-lisp
  (add-hook 'after-init-hook #'sudo-edit-indicator-mode)
#+end_src

* Project Management
** Git

Register ~git~ with ~home-manager~ first.

#+begin_src nix :noweb-ref home-manager :noweb yes
  programs = {
    git = {
      enable = true;

      userName = realUser;
      userEmail =
        let
          defaultAcc = with builtins; head
            (filter (a: a.primary) (attrValues config.accounts.email.accounts));
        in
          defaultAcc.address;
      aliases = {
        st = "status";
        co = "checkout";
        log = "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit";
      };
      ignores = [
        <<gitignore>>
      ];
      extraConfig = {
        github = {
          user = "junyi-hou";
        };
      };
    };
  };

  home.packages = [ pkgs.gitAndTools.delta ];
#+end_src

*** global gitignore

I specify the list of files that need to be ignore in all git repositories. These includes

+ OS generated files

  #+begin_src conf :noweb-ref gitignore
    ".DS_Store"
    ".DS_Store?"
    "._*"
    ".Spotlight-V100"
    ".Trashes"
    "ehthumbs.db"
    "Thumbs.db"
  #+end_src

+ ~nix-direnv~ cache files

  #+begin_src conf :noweb-ref gitignore
    ".direnv/"
  #+end_src

+ latex image cache for ~org~ preview.

  #+begin_src conf :noweb-ref gitignore
    "**/.org-latex-imgcache/"
    "**/ltximg/"
  #+end_src

*** magit

~magit~ is one of the best ~git~ frontend. It embodies a fundamental strength of ~emacs~: utilizes the superior ability of ~emacs~ to provide an interface of an otherwise complicated software.

#+begin_src emacs-lisp
  (use-package magit)
#+end_src

~magit~ modes are modes displaying read-only information. So I put them in the motion state.

#+begin_src emacs-lisp
  (add-to-list 'evil-motion-state-modes 'magit-status-mode)
  (add-to-list 'evil-motion-state-modes 'magit-log-mode)
  (add-to-list 'evil-motion-state-modes 'magit-revision-mode)
#+end_src

On the other hand, I want to start in the insert state in ~git-commit-mode~, as ~git-commit-mode~ only responsible for writing commit message.

#+begin_src emacs-lisp
  (evil-set-initial-state 'git-commit-mode 'insert)
#+end_src

I don't want to accidentally push half baked commits to the remote branch. To avoid this, I add the following protections. This allows me to set the name of the protected branches in directory local variable ~magit-push-protected-branch~ and get a confirmation before pushing those protected branches.

#+begin_src emacs-lisp
  (defcustom magit-push-protected-branch nil
    "When set, ask for confirmation before pushing to this branch (e.g. master).  Set this in .dir-locals.el"
    :type 'list
    :safe 'listp
    :group 'magit)

  (defun magit-push--protected-branch (magit-push-fun &rest args)
    "Ask for confirmation before pushing a protected branch."
    (if (member (magit-get-current-branch) magit-push-protected-branch)
        ;; Arglist is (BRANCH TARGET ARGS)
        (if (yes-or-no-p (format "Push to protected branch %s? " (magit-get-current-branch)))
            (apply magit-push-fun args)
          (error "Push aborted by user"))
      (apply magit-push-fun args)))

  (advice-add 'magit-push-current-to-pushremote :around #'magit-push--protected-branch)
  (advice-add 'magit-push-current-to-upstream :around #'magit-push--protected-branch)
#+end_src

The following function allows me to quickly visit things at point in the magic buffer: be it a file, a commit, or a status.

#+begin_src emacs-lisp
  (defun gatsby:vcs-visit-thing-at-point ()
    "Get file at point in magit buffers."
    (interactive)
    (cond ((magit-section-match '([file] [hunk]))
           (let ((file (magit-file-at-point t)))
             (unless file
               (error "No file at point"))
             (magit-diff-visit-file--internal file nil #'switch-to-buffer-other-window)))
          ((magit-section-match [commit])
           ;; commits: show the commit details
           (call-interactively #'magit-show-commit))
          ((magit-section-match [* error])
           (magit-process-buffer))
          ((magit-section-match [stash])
           (call-interactively #'magit-ediff-show-stash))
          ((and (magit-section-match '(issue pullreq))
                (featurep 'forge))
           ;; for `forge-issue' and `forge-pullreq' block, visit corresponding issue
           (call-interactively #'forge-visit-topic))
          ;; fallback - `magit-visit-thing'
          (t 'magit-visit-thing)))

  (general-define-key :keymaps '(magit-status-mode-map magit-diff-mode-map magit-log-mode-map)
                      :states '(motion normal visual)
                      "RET" #'gatsby:vcs-visit-thing-at-point)
#+end_src

Now define keybindings that are consistent with other interfaces: ~<,>~ for moving up and down a section; ~zo,zc~ for open and close folds; and ~SPC r~ for refreshing the current buffer.. A special one for ~magit~ is ~`~, which I bind to show the dispatch menu.

#+begin_src emacs-lisp
  (general-define-key :keymaps '(magit-status-mode-map magit-diff-mode-map magit-log-mode-map)
                      :states '(motion normal visual)
                      "SPC" nil
                      "<" 'magit-section-forward-sibling
                      ">" 'magit-section-backward-sibling
                      "zo" 'magit-section-show
                      "zc" 'magit-section-hide
                      "`" 'magit-dispatch)

  (general-define-key :keymaps '(magit-status-mode-map
                                 magit-diff-mode-map
                                 magit-log-mode-map
                                 magit-revision-mode-map)
                      :states '(motion normal)
                      :prefix "SPC"
                      "r" (lambda () (interactive) (magit-refresh-buffer)))
#+end_src

The keybindings in the ~magit-status-mode~ are shadowed by the ~evil~ default bindings. I restore a subset of those bindings I use most frequently and not in the way of the usual evil movement bindings.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'magit-status-mode-map :states '(motion normal)
    "d" 'magit-discard
    "E" 'magit-ediff
    "c" 'magit-commit
    "p" 'magit-push
    "f" 'magit-fetch
    "F" 'magit-pull)
#+end_src

Finally, I set up the general keybindings to call up ~magit~.

#+begin_src emacs-lisp
  (general-define-key :keymaps '(motion normal visual) :prefix "SPC"
    "gg" #'magit-status
    "gd" #'magit-ediff-show-working-tree
    "gl" #'magit-log-buffer-file
    "gb" #'magit-blame)
#+end_src

*** magit-delta

~delta~ is a command line utility that makes git diff more readable. ~magit-delta~ allows ~magit~ to utilize ~delta~ to present diff information.

First enable ~delta~ with ~home-manager~.

#+begin_src nix :noweb-ref home-manager
  programs.git.delta.enable = true;
#+end_src

Then enable the ~magit-delta~ package.

#+begin_src emacs-lisp
  (use-package magit-delta)
#+end_src

Make sure I load ~magit-delta-mode~ when enter ~magit~.

#+begin_src emacs-lisp
  (add-hook 'magit-mode-hook #'magit-delta-mode)
#+end_src

The only customization I need is to pass the correct command line options to ~delta~

#+begin_src emacs-lisp
  (setq magit-delta-delta-args `("--max-line-distance" "0.6"
                                 "--24-bit-color" "always"
                                 "--minus-color=#420000"
                                 "--plus-color=#006910"
                                 "--plus-emph-color=#00b300"
                                 "--color-only"))
#+end_src

*** rebase

~git-rebase-mode~ provides a visual and interactive way to do rebase.

#+begin_src emacs-lisp
  (use-package git-rebase :straight (:type built-in))
#+end_src

Similar to ~magit~, I should not be modifying the ~git-rebase-mode~. Hence I put it in the ~motion~ state.

#+begin_src emacs-lisp
  (add-to-list 'evil-motion-state-modes 'git-rebase-mode)
#+end_src

I do not need to configure ~git-rebase-mode~ besides keybindings.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'git-rebase-mode-map :states 'motion
    "p" 'git-rebase-pick
    "e" 'git-rebase-edit
    "l" 'git-rebase-label
    "r" 'git-rebase-reword
    "s" 'git-rebase-squash
    "d" 'git-rebase-kill-line
    "M-j" 'git-rebase-move-line-down
    "M-k" 'git-rebase-move-line-up)
#+end_src

*** forge

~forge~ provides a ~magit~-like way to interact with github/gitlab features like issues, pull request, etc.

#+begin_src emacs-lisp
  (use-package forge)
#+end_src

~forge~ shows both opened and closed topics. I here turns off displaying closed topics.

#+begin_src emacs-lisp
  (setq forge-topic-list-limit '(60 . -1))
#+end_src

Making ~forge~ keybindings consistent with the ~magit~ keybindings.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'magit-status-mode-map
    "@" 'forge-dispatch)

  (general-define-key :keymaps 'forge-topic-mode-map :states '(normal visual motion)
    "<return>" 'gatsby:vcs-visit-thing-at-point
    "zo" 'magit-section-show
    "zc" 'magit-section-hide)

  (general-define-key :keymaps 'forge-topic-mode-map :states '(normal visual motion) :prefix "SPC"
    "re" 'magit-edit-thing
    "rr" 'forge-create-post)
#+end_src

*** ediff

~ediff~ is a builtin mode for comparing files and dealing with merge conflicts.

#+begin_src emacs-lisp
  (use-package ediff)
#+end_src

It is crucial that I do not modify ~ediff~ buffers. As always, I put such buffers in the ~motion~ state.

#+begin_src emacs-lisp
  (add-to-list 'evil-motion-state-modes 'ediff-mode)
#+end_src

By default, ~ediff~ uses a separate frame to hold the control panel. This causes problem in a tilting window manager. Hence I set it up for ~ediff~ to use the current frame to hold the control panel.

#+begin_src emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

As many other builtin packages, ~ediff~ does not play well with evil. I follow the guide in [[https://github.com/emacs-evil/evil-collection/blob/master/evil-collection-ediff.el][evil-collection]] to deal with this.

#+begin_src emacs-lisp
  (defun gatsby:vcs-ediff-scroll-left (&optional arg)
    "Scroll left."
    (interactive "P")
    (let ((last-command-event ?>))
      (ediff-scroll-horizontally arg)))

  (defun gatsby:vcs-ediff-scroll-right (&optional arg)
    "Scroll right."
    (interactive "P")
    (let ((last-command-event ?<))
      (ediff-scroll-horizontally arg)))

  (defun gatsby:vcs-ediff-scroll-up (&optional arg)
    "Scroll up by half of a page."
    (interactive "P")
    (let ((last-command-event ?V))
      (ediff-scroll-vertically arg)))

  (defun gatsby:vcs-ediff-scroll-down (&optional arg)
    "Scroll down by half of a page."
    (interactive "P")
    (let ((last-command-event ?v))
      (ediff-scroll-vertically arg)))

  (defun gatsby:vcs-ediff-scroll-down-1 ()
    "Scroll down by a line."
    (interactive)
    (let ((last-command-event ?v))
      (ediff-scroll-vertically 1)))

  (defun gatsby:vcs-ediff-scroll-up-1 ()
    "Scroll down by a line."
    (interactive)
    (let ((last-command-event ?V))
      (ediff-scroll-vertically 1)))

  (defun gatsby:vcs-ediff-first-difference ()
    "Jump to first difference."
    (interactive)
    (ediff-jump-to-difference 1))

  (defun gatsby:vcs-ediff-last-difference ()
    "Jump to last difference."
    (interactive)
    (ediff-jump-to-difference ediff-number-of-differences))

  (defun gatsby:vcs-ediff-modify-keys ()
    "Due to the wired way `ediff-mode' sets up its keymap, need to wrap this in a function and run it in `ediff-keymap-setup-hook'."
    (general-define-key
     :keymaps 'ediff-mode-map
     :states 'motion
     "SPC" nil
     "?" 'ediff-toggle-help
     "n" 'ediff-next-difference
     "N" 'ediff-previous-difference
     "G" 'ediff-jump-to-difference
     "gg" 'gatsby:vcs-ediff-first-difference

     "j" 'gatsby:vcs-ediff-scroll-down-1
     "k" 'gatsby:vcs-ediff-scroll-up-1
     "h" 'gatsby:vcs-ediff-scroll-left
     "l" 'gatsby:vcs-ediff-scroll-right
     "C-d" 'gatsby:vcs-ediff-scroll-down
     "C-u" 'gatsby:vcs-ediff-scroll-up

     "a" 'ediff-copy-A-to-B
     "b" 'ediff-copy-B-to-A

     "C-e" 'ediff-next-difference
     "C-y" 'ediff-previous-difference

     "q" 'ediff-quit)

    ;; fool-proving
    (general-define-key
     :keymaps 'ediff-mode-map
     :states 'motion
     :prefix "SPC"
     "q" 'ediff-quit)

    ;; if it is a three-window job
    (unless ediff-3way-comparison-job
      (general-define-key
       :keymaps 'ediff-mode-map
       :states 'motion
       "a" 'ediff-copy-A-to-C
       "b" 'ediff-copy-B-to-C
       "+" 'ediff-combine-diffs)))

  (add-hook 'ediff-keymap-setup-hook #'gatsby:vcs-ediff-modify-keys)
#+end_src

** ~emacs~ Interface

A project is defined by a directory tree whose root is identified using special files like ~.git~. I use mostly three functionalities based on project structure:
+ switch to existing/known projects
+ find file in a project
+ search text in projects

The first two are accomplished by my own small package ~project-plus~, which builds on the builtin ~project~ package.

#+begin_src emacs-lisp
  (use-package project
    :config
    (with-eval-after-load 'vc-hooks
      (setq vc-follow-symlinks t)))

  (use-package project-plus
    :straight (project-plus :repo "junyi-hou/project-plus.el" :host github)
  :config
  (project-plus-mode 1)
    :general
    (:keymaps '(normal motion visual)
     :prefix "SPC"
     "op" #'project-plus-switch-project
     "of" #'project-plus-find-file))
#+end_src

I use ~deadgrep~ to search for text in projects. ~deadgrep~ use ~ripgrep~ as the backend to search text in project based on regexp.

#+begin_src nix :noweb-ref home-manager
  home.packages = [ pkgs.ripgrep ];
#+end_src

#+begin_src emacs-lisp
  (use-package deadgrep)
#+end_src

~deadgrep~ has pretty sensible defaults. There are only two things that is missing. First, search visually selected text:

#+begin_src emacs-lisp
  (defun gatsby:visual-deadgrep (beg end)
    "use `deadgrep' to search visually selected text."
    (interactive "r")
    (deadgrep (buffer-substring-no-properties beg end)))
#+end_src

Second, refining existing searches:

#+begin_src emacs-lisp
  (defun gatsby:deadgrep-refine-search ()
    (interactive)
    (deadgrep--search-term 'ignore))
#+end_src

~deadgrep~ places all search results in a buffers, from which I can interact with using keyboard.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'deadgrep-mode-map :states 'emacs
    "j" #'deadgrep-forward
    "J" #'deadgrep-forward-filename
    "k" #'deadgrep-backward
    "K" #'deadgrep-backward-filename
    "r" #'deadgrep-restart
    "s" #'gatsby:deadgrep-refind-search)
#+end_src

Since the keybindings I define are in the motion state, make sure ~deadgrep~ starts in the motion state

#+begin_src emacs-lisp
  (add-to-list 'evil-emacs-state-modes 'deadgrep-mode)
#+end_src

Finally, define the entry points for ~deadgrep~.

#+begin_src emacs-lisp
  (general-define-key :keymaps '(normal motion) :prefix "SPC"
    "og" #'deadgrep)

  (general-define-key :keymaps 'visual :prefix "SPC"
    "og" #'gatsby:visual-deadgrep)
#+end_src

** Local Environment

An big advantage of ~nix~ is that it can create reproducible isolate production environments. At the system level, this is achieved by ~direnv~ and ~nix-direnv~, which will automatically build and run ~shell.nix~ (or ~default.nix/~flakes.nix~) once enter a project via shell. However, ~emacs~ inherits system information (~PATH~ and other environment variables) from the shell in which it starts. Therefore, it won't be able to pick up the local environment defined in ~shell.nix~ and friends. This posts considerable challenge for working in ~emacs~ with local environments.

To address this problem, I use ~envrc~, which makes ~process-environment~ a buffer-local variable. I first need to enable ~direnv~ and ~nix-direnv~ support in ~home-manager~.

#+begin_src nix :noweb-ref home-manager
  programs.direnv = {
    enable = true;
    enableNixDirenvIntegration = true;
    enableBashIntegration = true;
    config = {
      whitelist = {
        prefix = [ projectDir researchDir ];
      };
      global = {
        strict_env = false;
      };
    };
  };
#+end_src

Then register ~envrc~ within ~emacs~.

#+begin_src emacs-lisp
  (use-package envrc)
  (add-hook 'after-init-hook #'envrc-global-mode)
#+end_src

~envrc~ reads the current environment variable list and store it in ~envrc--cache~ when opening a buffer. There are two issues with this process:
+ If a environment is updated (e.g., because ~shell.nix~ is changed), but the directory has already a cached environment.
+ Some commands are called using the default ~process-environment~ rather than the local one. This may be caused by the use of ~with-temp-buffer~ or ~with-current-buffer~, which inherits the wrong ~process-environment~.

For the first issue, ~envrc~ can update the current environment by running ~envrc-reload~. However, this needs to be run manually. I can advice it to run after saving ~shell.nix~ and friends.

#+begin_src emacs-lisp
  (defun gatsby:envrc--maybe-reload ()
    "run `envrc-reload' if the current buffer name is one of \"shell.nix\", \"default.nix\", or \"flakes.nix\"."
    (when (member (f-filename (buffer-file-name)) '("shell.nix" "default.nix" "flakes.nix"))
      (envrc-reload)))

  (defun gatsby:envrc--setup-update-hook ()
    (add-hook 'after-save-hook #'gatsby:envrc--maybe-reload nil t))

  (add-hook 'nix-mode-hook #'gatsby:envrc--setup-update-hook)
#+end_src

For the second issue, ~envrc~ has a builtin function ~envrc-propagate-environment~ which can be use to wrap functions around to make sure they use the correct environment.

#+begin_src emacs-lisp
  (advice-add #'executable-find :around #'envrc-propagate-environment)
#+end_src

A lighter on the mode-line is useful to indicate the current status of ~direnv~. ~envrc~ does have a builtin lighter. However, it uses ~global-mode-string~, which I do not use in my customized [[mode-line]]. So I modify the ~envrc--lighter~ function to have it on my mode line.

#+begin_src emacs-lisp
  ;; mouse face for envrc-lighter
  (defun gatsby:envrc--envrc-lighter ()
    "`envrc--lighter' with mouse hover showing current root directory"
    (let ((root (or (f-traverse-upwards
                     (lambda (dir) (f-exists-p (format "%s/.envrc" dir))))
                    "no direnv environment")))
      `("[e:"
        (:propertize ,(symbol-name envrc--status)
         face
         ,(pcase envrc--status
            (`on 'envrc-mode-line-on-face)
            (`error 'envrc-mode-line-error-face)
            (`none 'envrc-mode-line-none-face))
         mouse-face mode-line-highlight
         help-echo ,root
         )
        "]")))

  (setq gatsby:right-mode-line `((:eval (gatsby:envrc--envrc-lighter)) " " ,@gatsby:right-mode-line))
#+end_src

I include the following functions to quickly modify or initialize a ~.envrc~ and a ~shell.nix~ file.

#+begin_src emacs-lisp
  (defun gatsby:envrc-edit-or-init ()
    "Update or init a nix-direnv environment in the current `default-directory'."
    (interactive)
    (if-let* ((root (envrc--find-env-dir)))
        (let ((shell (format "%sshell.nix" root))
              (default (format "%sdefault.nix" root))
              (flake (format "%sflake.nix" root)))
          (find-file-other-window (completing-read
                                   (format "direnv environment found at %s, openning: " root)
                                   (--filter (f-exists-p it) `(,shell ,default ,flake)))))
      (gatsby:envrc-init-direnv default-directory)))

  (defun gatsby:envrc-init-direnv (root)
    "Initialize a nix-direnv environment in ROOT directory."
    (interactive (list (read-file-name "Select the root directory: "
                                       default-directory
                                       nil
                                       nil
                                       nil
                                       'directory-name-p)))
    ;; 1. put use_nix in .envrc file
    (with-temp-buffer
      (insert "use_nix\n")
      (write-file (format "%s.envrc" root) nil))
    ;; 2. init (and open) a shell.nix file with basic structure
    (f-touch (format "%sshell.nix" root))
    ;; ask if want to allow
    (when (and (eq envrc--status 'error)
               (y-or-n-p (format "%s is not allowed by direnv, allowing it?")))
      (envrc-allow))
    (find-file-other-window (format "%sshell.nix" root))
    (yas-expand-snippet (yas-lookup-snippet "new-shell")))
#+end_src

I want to refer to the ~*envrc*~ buffer to check out direnv status.

#+begin_src emacs-lisp
  (defun gatsby:envrc-log-buffer ()
    "Switch to `*envrc*' buffer."
    (interactive)
    (with-current-buffer "*envrc*"
      (goto-char (point-max))
      (goto-char (or (re-search-backward "^====" nil t) (point-min))))
    (switch-to-buffer-other-window "*envrc*"))
#+end_src

Also make ~*envrc*~ unkillable.

#+begin_src emacs-lisp
  (defun gatsby:envrc--unkillable-log-buffer ()
    (if (string= (buffer-name (current-buffer)) "*envrc*")
        (progn
          (delete-window (get-buffer-window "*envrc*"))
          nil)
      t))

  (add-hook 'kill-buffer-query-functions #'gatsby:envrc--unkillable-log-buffer)
#+end_src

~*envrc*~ is in ~special-mode~. Make sure it is in ~motion~ mode. And define some quick key bindings.

#+begin_src emacs-lisp
  (add-to-list 'evil-motion-state-modes 'special-mode)

  (general-define-key :keymaps 'special-mode-map :states 'motion
    "q" 'delete-window)
#+end_src

Finally, key binding.

#+begin_src emacs-lisp
  (general-define-key :keymaps '(normal visual motion) :prefix "SPC"
    "ne" #'gatsby:envrc-edit-or-init
    "nn" #'envrc-reload
    "nd" #'envrc-deny
    "na" #'envrc-allow
    "nl" #'gatsby:envrc-log-buffer)
#+end_src

** dired

~dired~ is a builtin file management package that offers keyboard-oriented interface like ~ranger~. Although I manipulate files mostly in command line, it is nice to have a graphic file manager.

I want each line to represent a file. So I need to turn off ~visual-line-mode~ when starting ~dired~ mode.

#+begin_src emacs-lisp
  (defun gatsby:dired--turn-off-line-break ()
    (visual-line-mode -1)
    (setq truncate-lines t))

  (add-hook 'dired-mode-hook #'gatsby:dired--turn-off-line-break)
#+end_src

Since ~dired~ buffers are not really text buffer, it should be readonly. I put ~dired-mode~ in ~motion~ mode by default.

#+begin_src emacs-lisp
  (add-to-list 'evil-motion-state-modes 'dired-mode)
#+end_src

#+begin_src emacs-lisp
  (use-package dired :straight (:type built-in))
#+end_src

~dired~ supports customizing the ~ls~ switches.

#+begin_src emacs-lisp
  (setq dired-listing-switches "-lh")
#+end_src

Furthermore, I define the following function that allows me to toggle displaying hidden files and refresh ~dired~ buffer.

#+begin_src emacs-lisp
  (defun gatsby:dired-toggle-hide ()
    "Toggle whether to show hidden files."
    (interactive)
    (let* ((switches dired-actual-switches)
           (new-switches (if (string-match "a" dired-actual-switches)
                             (replace-regexp-in-string "a" "" dired-actual-switches)
                           (concat dired-actual-switches "a"))))
      (setq-local dired-actual-switches new-switches)
      (revert-buffer)))

  (general-define-key :keymaps 'dired-mode-map :states 'motion
    "h" #'gatsby:dired-toggle-hide
    "r" #'revert-buffer)
#+end_src

Like other builtin packages, ~dired~ does not optimize for ~evil~ keybindings. I revise some of the keybindings.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'dired-mode-map :states 'motion
    ;; sort
    "s" 'dired-sort-toggle-or-edit

    ;; movement
    "j" 'dired-next-line
    "k" 'dired-previous-line
    "J" (lambda () (interactive) (dired-next-line 3))
    "K" (lambda () (interactive) (dired-previous-line 3))
    "<backspace>" 'dired-up-directory

    ;; files
    "<return>" 'dired-find-file
    "<M-return>" 'dired-find-file-other-window
    "f" 'find-file
    "F" 'dired-create-directory
    "t" 'dired-show-file-type
    "y" 'dired-copy-filename-as-kill)
#+end_src

Now define the entry point of ~dired~.

#+begin_src emacs-lisp
  (general-define-key :keymaps '(motion normal visual) :prefix "SPC"
    "od" (lambda () (interactive) (dired default-directory)))
#+end_src

The builtin ~dired~ mode lacks some aesthetic features, like marking different types of files with different colors, and collapse directories with only 1 file/subdirectory. I accomplish these by using ~dired-rainbow~ and ~dired-collapse~ packages.

#+begin_src emacs-lisp
  (use-package dired-rainbow
    :after dired
    :config
    (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
    (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
    (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
    (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
    (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
    (dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
    (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
    (dired-rainbow-define log "#c17d11" ("log"))
    (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
    (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
    (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
    (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
    (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
    (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
    (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
    (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
    (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
    (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
    (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*")
    (dired-rainbow-define-chmod directory "#6cb2eb" "d.*"))

  (use-package dired-collapse :hook (dired-mode . dired-collapse-mode))
#+end_src

* Message Management

This section showcases the potential of ~emacs~ being the integrated interface between the user and various tools, as long as the content of the interaction depends on displaying and reading text. I rely on ~emacs~ to
+ schedule my events, manage my calendar via ~org-gcal~ and ~calfw~;
+ receive, read and reply my email via ~notmuch~;
+ handle my slack messages via ~emacs-slack~.

** Email Client

To receive and send emails from the comfort in ~emacs~, I use

+ ~mbsync~ (registered as ~isync~ in many package managers) to fetch and sync maildir with the remote server.

  #+begin_src nix :noweb home-manager
    programs.mbsync.enable = true;
  #+end_src

  To deal with the security requirement of GMail, I use a ~xoauth2~ plugins for ~cryus~ library. [[http://blog.onodera.asia/2020/06/how-to-use-google-g-suite-oauth2-with.html][This blog]] provides a good summary on how to enable ~xoauth2~ for ~mbsync~, which involves installing a ~cryus~ plugin. ~cryus~ requires all plugins to live in the same directory, which is difficult for a ~nix~-based system, as ~cryus~ plugins lives in different ~nix~ storage. I use a hack which consists of three steps:

  1. build a copy of ~cyrus_sasl~ since it is a dependency of xoauth2 plugin

  2. build ~xoauth2~ plugin (I use [[https://github.com/robn/sasl2-oauth][robn's sasl2-oauth plugin]])

  3. add an overlay of ~cyrus_sasl~ with ~xoauth2~ libraries symlinking to ~${cyruss_sasl}/lib/sasl2~

    Until [[https://github.com/NixOS/nixpkgs/issues/108480][the upstream]] figured out some ways to deal with this, I will use my hack to allow ~mbsync~ retrieve emails from google.

    #+begin_src nix :noweb-ref home-manager
      nixpkgs.overlay = let
        gmail-oauth2-tools = with pkgs; stdenv.mkDerivation {
          name = "gmail-oauth2-tools";
          src = fetchFromGitHub {
            owner = "google";
            repo = "gmail-oauth2-tools";
            rev = "e3229155a4037267ce40f1a3a681f53221aa4d8d";
            sha256 = "1cxpkiaajhq1gjsg47r2b5xgck0r63pvkyrkm7af8c8dw7fyn64f";
          };
          buildInputs = [ python27 pass oauth2Lib ];
          installPhase = ''
            mkdir -p $out/bin
            cp python/oauth2.py $out/bin/gmail-oauth2-tools
            chmod +x $out/bin/gmail-oauth2-tools

            # authorization script
            cat > $out/bin/gmail-get-token <<EOF
            #! /usr/bin/env bash
            ID=\$(${pass}/bin/pass google-api/id)
            SECRET=\$(${pass}/bin/pass google-api/secret)
            TOKEN=\$(${pass}/bin/pass google-api/\$1)
            ACCOUNT=\$1

            $out/bin/gmail-oauth2-tools --user=\$ACCOUNT --client_id=\$ID --client_secret=\$SECRET --refresh_token=\$TOKEN --generate_oauth2_token | awk -F" " '{if(NR==1)print \$3}'
            EOF

            chmod +x $out/bin/gmail-get-token
          '';
        };

        cyrus = import <nixpkgs/pkgs/development/libraries/cyrus-sasl/default.nix> {
          inherit (pkgs) lib stdenv fetchurl openssl openldap kerberos db gettext
            pam fixDarwinDylibNames autoreconfHook buildPackages pruneLibtoolFiles fetchpatch;
        };

        oauth2Lib = with pkgs; stdenv.mkDerivation {
          name = "sasl2-oauth";
          src = fetchFromGitHub {
            owner = "robn";
            repo = "sasl2-oauth";
            rev = "4236b6fb904d836b85b55ba32128b843fd8c2362";
            sha256 = "17c1131yy41smz86fkb6rywfqv3hpn0inqk179a4jcr1snsgr891";
          };
          nativeBuildInputs = [ autoreconfHook cyrus ];
        };

      in
        [
          (
            self: super:
            {
              cyrus_sasl = super.cyrus_sasl.overrideAttrs (div: rec {
                postInstall = ''
                for lib in ${oauth2Lib}/lib/sasl2/*; do
                  ln -sf $lib $out/lib/sasl2/
                done
              '';
              });
            }
          )
        ];

      home.packages = [ pkgs.mbsync gmail-oauth2-tools ];

      services = {
        mbsync = {
          enable = true;
          # sync every 5 minutes, but alerts can be less frequent
          frequency = "*:0/5";
          postExec = ''${pkgs.notmuch}/bin/notmuch new'';
        };
      };
  #+end_src

+ ~notmuch~ to index and search emails based on tag and other maildir attributes. It also provides a great ~emacs~ package to interact and manipulate its database.

  #+begin_src nix :noweb-ref home-manager
    programs.notmuch = {
      enable = true;
      maildir.synchronizeFlags = true;
      new = {
        tags = [ "new" ]; # to be used together with afew
      };
      hooks = {
        postNew = ''
              ${pkgs.afew}/bin/afew --new --tag
            '';
      };
      search.excludeTags = [ "trash" "spam" ];
      extraConfig = {
        index = {
          header = "List List-Id";
        };
      };
    };
#+end_src

+ on its own, ~notmuch~ do not associate the maildir of mails with their tags. For example, mails tagged with ~trash~ are not moved to the ~trash~ maildir. ~afew~ deals with this problem by providing a "mover" command to move mails according to their tags. In addition, it provides an easy way to setup initial tagging.

  First, the mail mover. I move mails
  - with "inbox" tag to inbox, without "inbox" tag to archive;
  - mails with "spam" tag to spam, without "spam" tag to archive or inbox, depending on whether they have "inbox" tags;
  - mails with "trash" tag to trash, without "trash" tag to archive or inbox, depending on whether they have "inbox" tags;

    #+begin_src nix :noweb-ref home-manager
      programs.afew.enable = true;

      programs.afew.extraConfig = with builtins;
        let
          folder-fn = mailboxes: account: with account;
            concatStringsSep " " (map (box: "${name}/${box}") mailboxes);

          rule-fn = account: with account;
            ''
              ${name}/inbox   = 'tag:spam':${name}/spam                       'NOT tag:inbox':${name}/archive 'tag:trash':${name}/trash
              ${name}/archive = 'tag:inbox':${name}/inbox                     'tag:spam':${name}/spam         'tag:trash':${name}/trash
              ${name}/spam    = 'NOT tag:spam AND tag:inbox':${name}/inbox    'NOT tag:spam':${name}/archive
              ${name}/trash   = 'tag:inbox AND (NOT tag:trash)':${name}/inbox 'NOT tag:trash':${name}/archive
              '';

          move-folders = "folders = " + concatStringsSep " "
            (map (folder-fn [ "inbox" "spam" "archive" "trash" ])
              (attrValues config.accounts.email.accounts));

          move-rules = concatStringsSep
            "\n" (map rule-fn (attrValues config.accounts.email.accounts));
        in
          ''
            [MailMover]
            rename = True
          '' + move-folders + "\n" + move-rules;
  #+end_src

  Second, I add the following initial filters:

  - move spam to the spam folder;
  - move mails I send to the send folder;
  - move mails that I already archived (i.e., not in the inbox folder) to the archive folder;
  - for mails from ~github~, add ~github~ tag and move it to the archive folder;
  - for mails sent to a mailing list, add ~list~ tag and a tag indicating which mailing list the mail belongs to. Furthermore, archive mails from mailing list that are not on my "allow list".

    To define the last filter, I utilize the ~python~ interface ~afew~ offers:

    #+begin_src jupyter-python :noweb-ref OnlyAllowListFilter
      import os
      import json

      from afew.filters.HeaderMatchingFilter import HeaderMatchingFilter
      from afew.FilterRegistry import register_filter


      AFEW_CONFIG_DIR = os.path.expanduser("~/.config/afew")

      with open("{}/allow_list".format(AFEW_CONFIG_DIR)) as f:
          ALLOW_LIST = json.load(f)


      @register_filter
      class OnlyAllowListFilter(HeaderMatchingFilter):
          message = 'Remove the "new" tag for all messages with field `List-Id` that is not in the ALLOW_LIST'
          query = 'tag:new'
          pattern = r"<(?P<list_id>[a-z0-9!#$%&'*+/=?^_`{|}~-]+)\."

          # overriding the `handle_message` method to remove inbox tag conditionally
          def handle_message(self, message):
              if not self._tag_blacklist.intersection(message.get_tags()):
                  value = message.get_header('List-Id')
                  match = self.pattern.search(value)
                  if match:
                      list_id = match.group('list_id').lower()
                      self.add_tags(message, 'lists', list_id)
                      if list_id not in ALLOW_LIST:
                          self.remove_tags(message, 'new')
    #+end_src

    And also the "allow list":

    #+begin_src conf :noweb-ref AllowList
      [
      "egrads",
      "econseminars",
      "placement20-21",
      "devlunch",
      "mrg2016f",
      "seminar281"
      ]
    #+end_src

    Putting them together:

    #+begin_src nix :noweb-ref home-manager :noweb yes
      programs.afew.extraConfig = ''
        [SpamFilter]
        [ArchiveSentMailsFilter]
        [OnlyAllowListFilter]
        [Filter.1]
        query = NOT path:"/.*/inbox/**/"
        tags = -new
        message = remove the "new" tag for message not found in the inbox folder
        [Filter.2]
        query = from:github.com AND tag:new
        tags = -new +github
        [InboxFilter]
      '';

      home.file = {
        ".config/afew/OnlyAllowListFilter.py" = {
          text = ''
      <<OnlyAllowListFilter>>
          '';
        };
        ".config/afew/allow_list" = {
          text = ''
      <<AllowList>>
          '';
        };
      };

      home.activation = {
        removeAfewFilterCache = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
          if [ -d ~/.config/afew/__pycache__ ]; then
              $DRY_RUN_CMD rm -r $VERBOSE_ARG ~/.config/afew/__pycache__
          fi
        '';
      };
    #+end_src

+ finally, I use ~msmtp~ to send emails. ~msmtp~ has nice multi account supports so I won't send the email from the wrong address.

  #+begin_src nix :noweb-ref home-manager
    programs.msmtp.enable = true;
  #+end_src

*** accounts

I include my email accounts here. I have two accounts. A personal one ([[junyi.yi.hou@gmail.com]]), and one that I got from my school ([[junyi.hou@berkeley.edu]]). I set my personal account as my default email account.

#+begin_src nix :noweb yes :noweb-ref home-manager
  accounts.email = {
    maildirBasePath = mailDir;
    accounts = let
      mbsyncExtraConf = {
        Create = "Slave";
        Expunge = "Both";
        SyncState = "*";
        Sync = "all";
      };
    in
      {
        <<personal-account>>

        <<uc-berkeley-account>>
      };
  };

  home.activation = {
    initMailDir =
      let
        mkAccountDir = with builtins; concatStringsSep "\n"
          (map (account: ''$DRY_RUN_CMD mkdir -p $VERBOSE_ARG ${mailDir}/${account.name}'')
            (attrValues config.accounts.email.accounts));
      in
        lib.hm.dag.entryAfter [ "writeBoundary" ] mkAccountDir;
  };
#+end_src

I then export my account information to ~emacs~.

#+begin_src nix :noweb-ref home-manager
  home.file = {
    "${lispDir}/gatsby:accounts.el" =
      let
        defaultAcc = with builtins; head (
          filter (a: a.primary) (attrValues config.accounts.email.accounts));
        allAccounts = with builtins;
          concatStringsSep " "
            (map (a: ''"'' + a + ''"'')
              (catAttrs "address"
                (filter (a: a.flavor == "gmail.com")
                  (sort (a1: a2: if a1.primary then true else false)
                    (attrValues config.accounts.email.accounts)))));
      in
        {
          text = ''
              ;;; gatsby:accounts.el -*- lexical-binding: t; -*-

              ;; the default account
              (setq user-full-name "${defaultAcc.realName}"
                    user-mail-address "${defaultAcc.address}")

              ;; record all accounts
              (defconst user-all-mail-addresses '(${allAccounts}) "All registered email addresses")

              ;; smtpmail settings
              (setq smtpmail-queue-mail nil
                    smtpmail-queue-dir (let* ((dir "${mailDir}/queue"))
                                         (unless (file-exists-p dir)
                                           (make-directory dir))
                                         (format "%s/cur" dir)))

              (provide 'gatsby:accounts)
              ;;; gatsby:accounts.el ends here
            '';
        };
  };
#+end_src

**** personal account

#+begin_src nix :noweb-ref personal-account
  personal = {
    realName = realUser;
    userName = "junyi.yi.hou@gmail.com";
    address = "junyi.yi.hou@gmail.com";
    flavor = "gmail.com";
    folders = {
      drafts = "drafts";
      inbox = "inbox";
      sent = "sent";
      trash = "trash";
    };
    mbsync = {
      enable = true;
      extraConfig.account = {
        AuthMechs = "XOAUTH2";
        PipelineDepth = 1;
        TimeOut = 60;
      };
      groups = {
        "personal".channels = {
          "inbox" = {
            patterns = [ "INBOX" ];
            extraConfig = mbsyncExtraConf;
          };
          "sent" = {
            masterPattern = "[Gmail]/Sent Mail";
            slavePattern = "sent";
            extraConfig = mbsyncExtraConf;
          };
          "archive" = {
            masterPattern = "[Gmail]/All Mail";
            slavePattern = "archive";
            extraConfig = mbsyncExtraConf;
          };
          "drafts" = {
            masterPattern = "[Gmail]/Drafts";
            slavePattern = "drafts";
            extraConfig = mbsyncExtraConf;
          };
          "trash" = {
            masterPattern = "[Gmail]/Bin";
            slavePattern = "trash";
            extraConfig = mbsyncExtraConf;
          };
          "spam" = {
            masterPattern = "[Gmail]/Spam";
            slavePattern = "spam";
            extraConfig = mbsyncExtraConf;
          };
        };
      };
    };
    msmtp = {
      enable = true;
      extraConfig = {
        auth = "oauthbearer";
      };
    };
    notmuch.enable = true;
    passwordCommand = "${gmail-oauth2-tools}/bin/gmail-get-token junyi.yi.hou@gmail.com";

    primary = true;
  };
#+end_src

**** UC Berkeley account

#+begin_src nix :noweb-ref uc-berkeley-account
  uc-berkeley = {
    realName = realUser;
    userName = "junyi.hou@berkeley.edu";
    address = "junyi.hou@berkeley.edu";
    flavor = "gmail.com";
    folders = {
      drafts = "drafts";
      inbox = "inbox";
      sent = "sent";
      trash = "trash";
    };
    mbsync = {
      enable = true;
      extraConfig.account = {
        AuthMechs = "XOAUTH2";
        PipelineDepth = 1;
        TimeOut = 60;
      };
      groups = {
        "berkeley".channels = {
          "inbox" = {
            patterns = [ "INBOX" ];
            extraConfig = {
              Create = "Slave";
              Expunge = "Both";
              SyncState = "*";
              Sync = "all";
            };
          };
          "sent" = {
            masterPattern = "[Gmail]/Sent Mail";
            slavePattern = "sent";
            extraConfig = mbsyncExtraConf;
          };
          "archive" = {
            masterPattern = "[Gmail]/All Mail";
            slavePattern = "archive";
            extraConfig = mbsyncExtraConf;
          };
          "drafts" = {
            masterPattern = "[Gmail]/Drafts";
            slavePattern = "drafts";
            extraConfig = mbsyncExtraConf;
          };
          "trash" = {
            masterPattern = "[Gmail]/Trash";
            slavePattern = "trash";
            extraConfig = mbsyncExtraConf;
          };
          "spam" = {
            masterPattern = "[Gmail]/Spam";
            slavePattern = "spam";
            extraConfig = mbsyncExtraConf;
          };
        };
      };
    };
    msmtp = {
      enable = true;
      extraConfig = {
        auth = "oauthbearer";
      };
    };
    notmuch.enable = true;
    passwordCommand = "${gmail-oauth2-tools}/bin/gmail-get-token junyi.hou@berkeley.edu";
  };
#+end_src

*** notmuch

#+begin_src emacs-lisp
  (use-package notmuch

    :init
    (add-to-list 'evil-motion-state-modes 'notmuch-search-mode)

    :config
    (defun gatsby:notmuch-update ()
      "run mbsync -a && notmuch new"
      (interactive)
      (let ((display-buffer-overriding-action
             '(display-buffer-no-window (allow-no-window . t))))
        (async-shell-command "mbsync -a && notmuch new"))
      ;; update lighter
      (gatsby:notmuch--update-new-mails))

    :general
    (:keymaps '(normal motion)
     :prefix "SPC"
     "ms" #'notmuch-search
     "mt" #'notmuch-search-by-tag
     "mu" #'gatsby:notmuch-update
     "mc" #'notmuch-mua-new-mail))
#+end_src

It is useful to put an email lighter to the mode line to remind me of any new messages.

#+begin_src emacs-lisp
  (defvar gatsby:notmuch-new-mails 0 "number of unread mails")
  (defun gatsby:notmuch--update-new-mails (&rest _)
    "Update `gatsby:notmuch-new-mails' by calling \"notmuch count\"."
    (setq gatsby:notmuch-new-mails
          (string-to-number (shell-command-to-string
                             "notmuch count 'tag:inbox AND tag:unread'"))))

  (defface gatsby:notmuch-mode-line-face '((t :inherit error))
    "Face used in mode line to indicate new mails.")

  (defun gatsby:notmuch--lighter ()
    (let ((mails (if (> gatsby:notmuch-new-mails 9)
                     "10+"
                   (format "%d" gatsby:notmuch-new-mails))))
      `("[M:"
        (:propertize ,mails
         face
         ,(if (zerop gatsby:notmuch-new-mails)
              nil
            'gatsby:notmuch-mode-line-face))
        "] ")))
  (setq gatsby:right-mode-line `((:eval (gatsby:notmuch--lighter)) ,@gatsby:right-mode-line))
#+end_src

I do not want to update my email status too frequently to keep possible distraction to a minimum level. Therefore I set the update interval to 15 minutes (900 seconds)

#+begin_src emacs-lisp
  (run-at-time nil 900 #'gatsby:notmuch--update-new-mails)
#+end_src

Also, I want to manually update the count when I close any ~notmuch~ buffer.

#+begin_src emacs-lisp
  (advice-add #'notmuch-bury-or-kill-this-buffer :after #'gatsby:notmuch--update-new-mails)
#+end_src

Further more, I want to sync maildir with the tag as soon as I make any changes to tags. To do so, I call ~afew~ each time when refreshing or leaving a ~notmuch~ buffer. However, ~afew~ mail mover can run for a long time if there are too many mails to be moved. So I define a variable ~gatsby:notmuch-moving-in-process~ and run ~afew~ mail mover only when this variable is non-nil.

#+begin_src emacs-lisp
  (defvar gatsby:notmuch-moving-in-process nil
    "Non-nil means that there is another moving process running")

  (defun gatsby:notmuch-move (&rest _)
    "call afew -a -m to move mails to their designation."
    (interactive)
    (unless gatsby:notmuch-moving-in-process
      (setq gatsby:notmuch-moving-in-process t)
      (make-process
       :name "notmuch-move"
       :buffer nil
       :noquery t
       :command '("afew" "-a" "-m")
       :sentinel (lambda (process msg)
                   (unless (eq (process-status process) 'run)
                     (setq gatsby:notmuch-moving-in-process nil)
                     (let ((exit-code (process-exit-status process)))
                       (if (zerop exit-code)
                           (message "afew successfully moved mails!")
                         (message "afew exit with code %d" exit-code))))))))

  (advice-add #'notmuch-refresh-this-buffer :after #'gatsby:notmuch-move)
  (advice-add #'notmuch-bury-or-kill-this-buffer :after #'gatsby:notmuch-move)
#+end_src

*** notmuch search

~notmuch-search~ mode is a way to present search results. I first turn off ~visual-line-mode~ to prevent wrapping an email entry with long title. So each entry is exactly one line.

#+begin_src emacs-lisp
  (defun gatsby:notmuch--turn-off-visual-line-mode ()
    (visual-line-mode -1))

  (add-hook 'notmuch-search-hook #'gatsby:notmuch--turn-off-visual-line-mode)
  (add-hook 'notmuch-notmuch-tree-mode #'gatsby:notmuch--turn-off-visual-line-mode)
#+end_src

When displaying the search results, list the most recent message first.

#+begin_src emacs-lisp
  (setq-default notmuch-search-oldest-first nil)
#+end_src

~notmuch~ has good builtin support for archiving emails (i.e., removing the "inbox" tag), but not deleting emails. I implement a simple function to remove the "inbox" tag and add the "trash" tag (so to move the email to the trash folder).

#+begin_src emacs-lisp
  (defun gatsby:notmuch-search-trash (&optional arg)
    "Add trash tag to the current messages."
    (interactive "P")
    (let ((flag-change (if arg '("+inbox" "-trash") '("-inbox" "+trash")))
          beg end)
      (if (region-active-p)
          (setq beg (region-beginning)
                end (region-end))
        (setq beg (point)
              end (point)))
      (notmuch-search-tag flag-change beg end))
    (when (region-active-p)
      (deactivate-mark)))

  (defun gatsby:notmuch-tree-trash (&optional arg)
    "Add trash tag to the current messages."
    (interactive "P")
    (let ((flag-change (if arg '("+inbox" "-trash") '("-inbox" "+trash"))))
      (notmuch-tree-tag flag-change)
      (notmuch-tree-next-matching-message)))

  (defun gatsby:notmuch-show-trash (&optional arg)
    "Add trash tag to the current message."
    (interactive)
    (let ((flag-change (if arg '("+inbox" "-trash") '("-inbox" "+trash"))))
      (notmuch-show-tag flag-change)))
#+end_src

~notmuch~ uses ~emacs~ style keybindings by default. I need to change it to ~evil~ style binding.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'notmuch-search-mode-map :states 'motion
    ;; tag
    "a" #'notmuch-search-archive-thread
    "+" #'notmuch-search-add-tag
    "-" #'notmuch-search-remove-tag
    "'" #'notmuch-search-tag-all
    "DEL" #'gatsby:notmuch-search-trash

    "c" 'notmuch-search-stash-map

    ;; filter
    "s" #'notmuch-search-filter
    "t" #'notmuch-search-filter-by-tag

    "<tab>" #'notmuch-tree-from-search-current-query
    "q" #'notmuch-bury-or-kill-this-buffer

    ;; message related
    "<return>" #'notmuch-search-show-thread
    "r" #'notmuch-search-reply-to-thread
    "R" #'notmuch-search-reply-to-thread-sender
    "f" #'notmuch-show-forward-message)

  (general-define-key :keymaps 'notmuch-search-mode-map :states 'visual
    "a" #'notmuch-search-archive-thread
    "+" #'notmuch-search-add-tag
    "-" #'notmuch-search-remove-tag
    "'" #'notmuch-search-tag-all
    "DEL" #'gatsby:notmuch-search-trash)

  (general-define-key :keymaps 'notmuch-search-mode-map :states 'motion :prefix "SPC"
    "r" #'notmuch-refresh-this-buffer
    "R" #'notmuch-poll-and-refresh-this-buffer
    "q" #'notmuch-bury-or-kill-this-buffer)
#+end_src

*** notmuch-tree

~notmuch-tree~ is an interface to display and interact with email threads. First, since this is a read-only buffer, I use ~motion-state~ as the default state.

#+begin_src emacs-lisp
  (add-to-list 'evil-motion-state-modes 'notmuch-tree-mode)
#+end_src

~notmuch-tree~ offers a "split-view" option to show message and the thread panels in the same frame. I like the ability to skim through emails while keeping focus in the thread panel that allows me to move across emails/threads. To be able to do so, I wrote a few small helper functions.

#+begin_src emacs-lisp
  (defun gatsby:notmuch-tree-scroll-down-show ()
    (interactive)
    (when notmuch-tree-message-window
      (with-selected-window notmuch-tree-message-window
        (scroll-up 10))))

  (defun gatsby:notmuch-tree-scroll-up-show ()
    (interactive)
    (when notmuch-tree-message-window
      (with-selected-window notmuch-tree-message-window
        (scroll-down 10))))
#+end_src

The builtin ~notmuch-tree-next-thread~ will exit the current tree mode and return to the parent search mode if the "next" thread is the first or the last thread. However, I want it to stay in the ~tree~ buffer and instead move to the first or the last thread.

#+begin_src emacs-lisp
  (defun gatsby:notmuch-tree-next-thread (&optional previous)
    "Move to the next tree in the tree view. If PREVIOUS is non-nil, move to the previous one."
    (interactive)
    (if previous
        (unless (notmuch-tree-prev-thread-in-tree)
          (forward-line 1))
      (unless (notmuch-tree-next-thread-in-tree)
        (goto-char (point-max))
        (notmuch-tree-prev-thread-in-tree))))

  (defun gatsby:notmuch-tree-prev-thread ()
    (interactive)
    (gatsby:notmuch-tree-next-thread t))
#+end_src

Improve ~notmuch-tree-show-message-in~ to allow switching focus to the message
buffer if I call it twice in a row.

#+begin_src emacs-lisp
  (defun gatsby:notmuch-tree-show-message ()
    (interactive)
    (if (eq this-command last-command)
        ;; now the pane is split and the tree buffer has the focus
        ;; simply delete window will let the message view to have the focus
        (progn
          (setq-local notmuch-tree-message-buffer nil
                      notmuch-tree-message-window nil)
          (delete-window))
      (call-interactively #'notmuch-tree-show-message-in)))

  (general-define-key :keymaps 'notmuch-tree-mode-map :states 'motion
    "<return>" #'gatsby:notmuch-tree-show-message)
#+end_src

Now apply evil style key binding to ~notmuch-tree~ mode.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'notmuch-tree-mode-map :states 'motion
    "a" #'notmuch-tree-archive-message-then-next
    "A" #'notmuch-tree-archive-thread-then-next
    "+" #'notmuch-tree-add-tag
    "-" #'notmuch-tree-remove-tag
    "'" #'notmuch-tree-tag-thread
    "DEL" #'gatsby:notmuch-tree-trash

    "c" 'notmuch-show-stash-map

    "j" #'notmuch-tree-next-message
    "k" #'notmuch-tree-prev-message
    "J" #'gatsby:notmuch-tree-next-thread
    "K" #'gatsby:notmuch-tree-prev-thread

    "C-d" #'gatsby:notmuch-tree-scroll-down-show
    "C-u" #'gatsby:notmuch-tree-scroll-up-show
    "C-e" #'gatsby:notmuch-tree-scroll-down-show
    "C-y" #'gatsby:notmuch-tree-scroll-up-show

    "q" #'notmuch-bury-or-kill-this-buffer

    ;; message related
    "r" #'notmuch-tree-reply
    "R" #'notmuch-tree-reply-sender
    "f" #'notmuch-tree-forward-message)

  (general-define-key :keymaps 'notmuch-tree-mode-map :states 'motion :prefix "SPC"
    "r" #'notmuch-refresh-this-buffer)
#+end_src

*** notmuch-show

~notmuch-show~ is an interface with individual messages. First, since this is a read-only buffer, I use ~motion-state~ as the default state.

#+begin_src emacs-lisp
  (add-to-list 'evil-motion-state-modes 'notmuch-show-mode)
#+end_src

The builtin ~shr~ html renderer is bare-bones. To improve the html rendering quality, I use the external ~w3m~ program to render html emails.

#+begin_src nix :noweb-ref home-manager
  home.packages = [ pkgs.w3m ];
#+end_src

#+begin_src emacs-lisp
  (setq mm-text-html-renderer 'gnus-w3m)
#+end_src

The builtin ~return~ key cannot open url at point in ~notmuch-show~ buffer, which is a major inconvenience for me. I override it with my own function:

#+begin_src emacs-lisp
  (defun gatsby:notmuch-show-ret ()
    "Synthetic <return> key.
  If there is a button under `point', push it;
  If there is an url under `point', visit it;
  Otherwise just <return>."
    (interactive)
    (cond ((get-char-property (point) 'button) (call-interactively 'push-button))
          ((goto-address-find-address-at-point) (call-interactively 'goto-address-at-point))
          ((re-search-backward goto-address-url-regexp (line-beginning-position) t)
           (call-interactively 'goto-address-at-point))
          (t (call-interactively 'evil-ret))))
#+end_src

And the key binding.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'notmuch-show-mode-map :states 'motion
    "a" #'notmuch-show-archive-message-then-next-or-next-thread
    "A" #'notmuch-show-archive-thread-then-next
    "+" #'notmuch-show-add-tag
    "-" #'notmuch-show-remove-tag
    "'" #'notmuch-show-tag-all
    "c" 'notmuch-show-stash-map

    "r" #'notmuch-show-reply
    "R" #'notmuch-show-reply-sender
    "f" #'notmuch-show-forward-open-message

    "<" #'notmuch-show-rewind
    ">" #'notmuch-show-advance
    "DEL" #'gatsby:notmuch-show-trash
    "<return>" #'gatsby:notmuch-show-ret
    "`" #'notmuch-tree-from-show-current-query

    "u" #'notmuch-show-browse-urls
    "\\" #'toggle-truncate-lines

    "q" #'notmuch-bury-or-kill-this-buffer)

  (general-define-key :keymaps 'notmuch-show-mode-map :states 'motion :prefix "SPC"
    "e" #'notmuch-show-resume-message
    "r" #'notmuch-refresh-this-buffer
    "R" #'notmuch-poll-and-refresh-this-buffer
    "q" #'notmuch-bury-or-kill-this-buffer)
#+end_src

*** composing emails

The builtin ~message~ mode can be used to compose and send email. To use ~msmtp~ as the backend, I need the following configuration.

#+begin_src emacs-lisp
  (setq send-mail-function 'sendmail-send-it
        sendmail-program "msmtp"
        smtpmail-debug-verbose t
        smtpmail-debug-info t
        message-sendmail-envelope-from 'header
        mail-specify-envelope-from t)
#+end_src

Furthermore, I want to
+ include "CC" and "BCC" as the headers when I compose emails;
+ include the forwarding message in the email itself, not as an attachment

#+begin_src emacs-lisp
  (setq message-default-headers "Cc: \nBcc: \n"
        message-forward-as-mime nil
        message-make-forward-subject-function 'message-forward-subject-fwd)
#+end_src

Use the Gmail style citation style.

#+begin_src emacs-lisp
  (setq message-citation-line-format "On %e %B %Y %R, %f wrote:\n"
        message-citation-line-function #'message-insert-formatted-citation-line)
#+end_src

Sometimes it is convenient to write email using ~org-mode~ and send it. This is especially true if I want to include attachments. ~org-mime~ package does exactly this for me.

#+begin_src emacs-lisp
  (use-package org-mime

    :general
    (:keymaps 'notmuch-message-mode-map
     :states '(normal visual motion insert emacs)
     :prefix "C-c"
     "'" #'org-mime-edit-mail-in-org-mode)

    (:keymaps 'org-mime-src-mode-map
     :prefix "C-c"
     "C-k" #'kill-buffer-and-window))
#+end_src

An inconvenience of the ~org-mime~ mode is that I will need to manually run ~org-mime-htmlize~ in the message buffer to convert the org syntax into html syntax. Since I always want to convert the org syntax into html syntax, I advice the ~org-mime-edit-src-exit~ function to automatically run ~org-mime-htmlize~ afterwards.

#+begin_src emacs-lisp
  (defun gatsby:org-mime-auto-htmlize (fn &rest _)
    "Automatically apply `org-mime-htmlize' in the source buffer."
    (let ((source-buffer (marker-buffer org-mime-src--beg-marker)))
      (call-interactively fn)
      (with-current-buffer source-buffer
        (call-interactively 'org-mime-htmlize))))

  (advice-add #'org-mime-edit-src-exit :around #'gatsby:org-mime-auto-htmlize)
#+end_src

Finally, just to make sure that I send the email using the right account, I force myself to specific the sender address when I ever compose an email.

#+begin_src emacs-lisp
  (defun gatsby:notmuch--always-prompt-for-sender (fn &rest _)
    "When composing messages, always prompt for sender to make sure."
    (let ((current-prefix-arg 4))
      (call-interactively fn)))

  (advice-add #'notmuch-mua-new-mail :around #'gatsby:notmuch--always-prompt-for-sender)
  (advice-add #'notmuch-search-reply-to-thread :around #'gatsby:notmuch--always-prompt-for-sender)
  (advice-add #'notmuch-search-reply-to-thread-sender :around #'gatsby:notmuch--always-prompt-for-sender)
  (advice-add #'notmuch-tree-reply :around #'gatsby:notmuch--always-prompt-for-sender)
  (advice-add #'notmuch-tree-reply-sender :around #'gatsby:notmuch--always-prompt-for-sender)
  (advice-add #'notmuch-show-reply :around #'gatsby:notmuch--always-prompt-for-sender)
  (advice-add #'notmuch-show-reply-sender :around #'gatsby:notmuch--always-prompt-for-sender)
  (advice-add #'notmuch-show-forward-message :around #'gatsby:notmuch--always-prompt-for-sender)
#+end_src

** Calendar Client

*** backend: org-gcal

Both my personal and work calendars are managed by Google. I use ~org-gcal~ to sync my local event list (in several ~org-mode~ files) with Google Calendar.

#+begin_src emacs-lisp
  (use-package org-gcal)
#+end_src

~org-gcal~ requires setting ~org-gcal-client-id~ and ~org-gcal-client-secret~ to pass the Google authentication process. I do not feel comfortable putting those in plain text, so I save them and retrieve those secrets using ~password-store-get~ function.

When starting up ~emacs~ for the first time, the ~password-store~ will ask me for passphrase to decrypt the secret. Since I use ~emacs-server~, I want to defer this process until I start ~emacs~ GUI. So instead of setting those variable directly, I hook them onto the ~server-after-make-frame-hook~.

#+begin_src emacs-lisp
  (defvar gatsby:gcal-started-p nil
    "Non-nil if `org-gcal-client-id' and `org-gcal-client-secret' are set")

  (defun gatsby:gcal--init (&rest _)
    (when (and (not gatsby:gcal-started-p)
               (server-running-p))
      (setq gatsby:gcal-started-p t
            org-gcal-client-id (password-store-get "google-api/id")
            org-gcal-client-secret (password-store-get "google-api/secret")
            org-gcal-file-alist (--map
                                 `(,it . ,(expand-file-name it (format "%s/.cal" (getenv "HOME"))))
                                 user-all-mail-addresses))))

  (add-hook 'server-after-make-frame-hook #'gatsby:gcal--init)
#+end_src

Makes sure that the calendar directory (~$HOME/.cal~) exists.

#+begin_src nix :noweb-ref home-manager
  home.activation = {

    initCalDir = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
          $DRY_RUN_CMD mkdir -p $VERBOSE_ARG $HOME/.cal
        '';
  };
#+end_src

By default, ~org-gcal~ will place each occurrence of recurring events as a top level entry. This can be improved by setting ~org-gcal-recurring-events-mode~ to ~nested~, which will collect recurring events into one entry.

#+begin_src emacs-lisp
  (setq org-gcal-recurring-events-mode 'nested)
#+end_src

The builtin scheduling function of ~gcal~ relies on ~org-capture~. While I do not have any issue with using ~org-capture~ itself, I do want to simplify how I choose time and date when scheduling events. Therefore, I separate the function that actually schedules the event using ~org-capture~ with the function(s) that allow me to specify the time and date of the event.

#+begin_src emacs-lisp
  (cl-defun gatsby:gcal--schedule (account start-time end-time &key title desc)
    "Schedule an event.
  ACCOUNT is the calendar account this event is registered under.
  START-TIME is the start time list of the event (see `decode-time' for the input format).
  END-TIME is the end time list of the event (see `decode-time' for the input format).
  TITLE is the event title. If it is nil, put the initial cursor at the title field of the event.
  DESC is the event description. If the title field is non-nil, put the initial cursor at the description field of the event."
    (let* ((org-file (cdr (assoc account org-gcal-file-alist)))
           (desc (or desc ""))
           (desc-field (if title (concat desc "%?") desc))
           (title (or title "%?"))
           (org-tamplate-text (concat "* " title
                                      "\n:PROPERTIES:\n"
                                      ":calendar-id:\t" account
                                      "\n:END:\n:org-gcal:\n"
                                      (format-time-string "<%Y-%m-%d %H:%M>"
                                                          (apply #'encode-time start-time))
                                      "--"
                                      (format-time-string "<%Y-%m-%d %H:%M>"
                                                          (apply #'encode-time end-time))
                                      "\n\n"
                                      desc-field
                                      "\n:END:"))
           (org-capture-templates
            `(("a" "appointment"
               entry (file ,org-file)
               ,org-tamplate-text
               :empty-lines 1))))
      (org-capture t "a")))
#+end_src

To query the date and time of an event, I take advantage of ~selectrum~ framework, and use ~completing-read~ function.

#+begin_src emacs-lisp
  (defun gatsby:gcal--parse-time (time-string)
    "parse TIME-STRING of format %H:%M(pm). Return (sec min hour 0 0 0)."
    (let* ((H-offset (if (string-match ".+\\(pm\\|PM\\|pM\\|Pm\\)" time-string) '(0 12) '(0 0)))
           (raw-time (->> time-string
                          (s-split ":")
                          (seq-reverse)
                          (--map (replace-regexp-in-string "[a-zA-Z]+" "" it))
                          (-map 'string-to-number))))
      `(0 ,@(cl-map 'list '+ raw-time H-offset) 0 0 0)))

  (defun gatsby:gcal-select-time ()
    "Read time from the minibuffer. Return (sec min hour) of the selected time."
    (interactive)
    (let ((selectrum-should-sort-p nil))
      (gatsby:gcal--parse-time
       (completing-read "Select time: " (-interleave (--map (format "%s:00" it) (-iota 24))
                                                     (--map (format "%s:30" it) (-iota 24)))))))

  (defun gatsby:gcal-select-duration (&optional start-time)
    "Read duration from the minibuffer. If START-TIME is non-nil, return the end-time (start-time + duration)."
    (interactive)
    (let* ((selectrum-should-sort-p nil)
           (duration (gatsby:gcal--parse-time
                      (completing-read "Duration: "
                                       (-interleave (--map (format "%s:15" it) (-iota 10))
                                                    (--map (format "%s:30" it) (-iota 10))
                                                    (--map (format "%s:45" it) (-iota 10))
                                                    (--map (format "%s:00" it) (-iota 10 1)))))))
      (if start-time
          (cl-map 'list '+ start-time duration)
        duration)))

  (defun gatsby:gcal-select-date ()
    "Select a date from a list of next 7 dates. Return (0 0 0 day month year) of the selected time."
    (interactive)
    (let* ((selectrum-should-sort-p nil)
           (date-alist
            (--map
             (let ((emacs-time (time-add (current-time) (days-to-time it))))
               `(,(format-time-string "%Y-%m-%d %A" emacs-time) . ,emacs-time))
             (-iota 30)))
           (date (completing-read "Select Date: " date-alist))
           (date-sec (cdr (assoc date date-alist))))
      (if date-sec
          `(0 0 0 ,@(-select-by-indices '(3 4 5) (decode-time date-sec)))
        `(0 0 0 ,@(-map 'string-to-number (s-split "[- ]" date))))))

#+end_src

There is also an issue about scheduling an event in a different timezone. (e.g., I want to schedule an event at 4:00 PM EST rather than my local timezone PST). This is easy to deal with, as:

+ Google Calendar will automatically adjust the time zone difference and register the event in the local time. So there is no need for adjusting for timezone when fetching from remote.
+ If I can do the same thing when scheduling locally and convert the event time to local time before pushing to remote, this problem can be solved.

To address the last point, I need to have a function ~gatsby:gcal-select-timezone~ which takes in a timezone name and convert it into localtime, and then made the adjustment to any timestamp.

#+begin_src emacs-lisp
  (defconst gatsgy:local-timezone-offset '(0 0 8 0 0 0)
    "Transformation from UTC +0 to the local time zone.")

  (defconst gatsby:timezone-alist
    '(("UTC (Africa): Ouagadougou, Abidjan, Banjul, Accra, Conakry, Bissau, Monrovia, Bamako, Nouakchott, Sao_Tome, Dakar, Freetown, Lome" . (0 0 0 0 0 0))
      ("UTC (America): Danmarkshavn" . (0 0 0 0 0 0))
      ("UTC (Antarctica): Troll" . (0 0 0 0 0 0))
      ("UTC (Atlantic): Faroe, Reykjavik, Madeira, St_Helena, Canary" . (0 0 0 0 0 0))
      ("UTC (Europe): Guernsey, Dublin, Isle_of_Man, Jersey, Lisbon, London" . (0 0 0 0 0 0))
      ("UTC +01:00 (Africa): Algiers, Luanda, Porto-Novo, Douala, Bangui, Ndjamena, Brazzaville, Kinshasa, Malabo, Libreville, Casablanca, Niamey, Lagos, Ceuta, Tunis, El_Aaiun" . (0 0 1 0 0 0))
      ("UTC +01:00 (Arctic): Longyearbyen" . (0 0 1 0 0 0))
      ("UTC +01:00 (Europe): Tirane, Andorra, Vienna, Brussels, Sarajevo, Zagreb, Prague, Copenhagen, Paris, Berlin, Busingen, Gibraltar, Vatican, Budapest, Rome, Vaduz, Luxembourg, Skopje, Malta, Monaco, Podgorica, Amsterdam, Oslo, Warsaw, San_Marino, Belgrade, Bratislava, Ljubljana, Madrid, Stockholm, Zurich" . (0 0 1 0 0 0))
      ("UTC +02:00 (Africa): Gaborone, Bujumbura, Lubumbashi, Cairo, Maseru, Tripoli, Blantyre, Maputo, Windhoek, Kigali, Johannesburg, Juba, Khartoum, Mbabane, Lusaka, Harare" . (0 0 2 0 0 0))
      ("UTC +02:00 (Asia): Famagusta, Nicosia, Jerusalem, Amman, Beirut, Gaza, Hebron, Damascus" . (0 0 2 0 0 0))
      ("UTC +02:00 (Europe): Sofia, Tallinn, Helsinki, Athens, Riga, Vilnius, Chisinau, Bucharest, Kaliningrad, Kiev, Uzhgorod, Zaporozhye, Mariehamn" . (0 0 2 0 0 0))
      ("UTC +03:00 (Africa): Djibouti, Asmara, Addis_Ababa, Nairobi, Mogadishu, Dar_es_Salaam, Kampala" . (0 0 3 0 0 0))
      ("UTC +03:00 (Antarctica): Syowa" . (0 0 3 0 0 0))
      ("UTC +03:00 (Asia): Bahrain, Baghdad, Kuwait, Qatar, Riyadh, Aden" . (0 0 3 0 0 0))
      ("UTC +03:00 (Europe): Minsk, Kirov, Moscow, Volgograd, Istanbul, Simferopol" . (0 0 3 0 0 0))
      ("UTC +03:00 (Indian): Comoro, Antananarivo, Mayotte" . (0 0 3 0 0 0))
      ("UTC +03:30 (Asia): Tehran" . (0 30 3 0 0 0))
      ("UTC +04:00 (Asia): Yerevan, Baku, Tbilisi, Muscat, Dubai" . (0 0 4 0 0 0))
      ("UTC +04:00 (Europe): Astrakhan, Samara, Saratov, Ulyanovsk" . (0 0 4 0 0 0))
      ("UTC +04:00 (Indian): Mauritius, Reunion, Mahe" . (0 0 4 0 0 0))
      ("UTC +04:30 (Asia): Kabul" . (0 30 4 0 0 0))
      ("UTC +05:00 (Antarctica): Mawson" . (0 0 5 0 0 0))
      ("UTC +05:00 (Asia): Aqtau, Aqtobe, Atyrau, Oral, Qyzylorda, Karachi, Yekaterinburg, Dushanbe, Ashgabat, Samarkand, Tashkent" . (0 0 5 0 0 0))
      ("UTC +05:00 (Indian): Kerguelen, Maldives" . (0 0 5 0 0 0))
      ("UTC +05:30 (Asia): Kolkata, Colombo" . (0 30 5 0 0 0))
      ("UTC +05:45 (Asia): Kathmandu" . (0 45 5 0 0 0))
      ("UTC +06:00 (Antarctica): Vostok" . (0 0 6 0 0 0))
      ("UTC +06:00 (Asia): Dhaka, Thimphu, Urumqi, Almaty, Qostanay, Bishkek, Omsk" . (0 0 6 0 0 0))
      ("UTC +06:00 (Indian): Chagos" . (0 0 6 0 0 0))
      ("UTC +06:30 (Asia): Yangon" . (0 30 6 0 0 0))
      ("UTC +06:30 (Indian): Cocos" . (0 30 6 0 0 0))
      ("UTC +07:00 (Antarctica): Davis" . (0 0 7 0 0 0))
      ("UTC +07:00 (Asia): Phnom_Penh, Jakarta, Pontianak, Vientiane, Hovd, Barnaul, Krasnoyarsk, Novokuznetsk, Novosibirsk, Tomsk, Bangkok, Ho_Chi_Minh" . (0 0 7 0 0 0))
      ("UTC +07:00 (Indian): Christmas" . (0 0 7 0 0 0))
      ("UTC +08:00 (Asia): Brunei, Shanghai, Hong_Kong, Makassar, Macau, Kuala_Lumpur, Kuching, Choibalsan, Ulaanbaatar, Manila, Irkutsk, Singapore, Taipei" . (0 0 8 0 0 0))
      ("UTC +08:00 (Australia): Perth" . (0 0 8 0 0 0))
      ("UTC +08:45 (Australia): Eucla" . (0 45 8 0 0 0))
      ("UTC +09:00 (Asia): Jayapura, Tokyo, Pyongyang, Seoul, Chita, Khandyga, Yakutsk, Dili" . (0 0 9 0 0 0))
      ("UTC +09:00 (Pacific): Palau" . (0 0 9 0 0 0))
      ("UTC +09:30 (Australia): Darwin" . (0 30 9 0 0 0))
      ("UTC +10:00 (Antarctica): DumontDUrville" . (0 0 10 0 0 0))
      ("UTC +10:00 (Asia): Ust-Nera, Vladivostok" . (0 0 10 0 0 0))
      ("UTC +10:00 (Australia): Brisbane, Lindeman" . (0 0 10 0 0 0))
      ("UTC +10:00 (Pacific): Guam, Chuuk, Saipan, Port_Moresby" . (0 0 10 0 0 0))
      ("UTC +10:30 (Australia): Adelaide, Broken_Hill" . (0 30 10 0 0 0))
      ("UTC +11:00 (Antarctica): Casey, Macquarie" . (0 0 11 0 0 0))
      ("UTC +11:00 (Asia): Magadan, Sakhalin, Srednekolymsk" . (0 0 11 0 0 0))
      ("UTC +11:00 (Australia): Hobart, Lord_Howe, Melbourne, Sydney" . (0 0 11 0 0 0))
      ("UTC +11:00 (Pacific): Kosrae, Pohnpei, Noumea, Bougainville, Guadalcanal, Efate" . (0 0 11 0 0 0))
      ("UTC +12:00 (Asia): Anadyr, Kamchatka" . (0 0 12 0 0 0))
      ("UTC +12:00 (Pacific): Fiji, Tarawa, Kwajalein, Majuro, Nauru, Norfolk, Funafuti, Wake, Wallis" . (0 0 12 0 0 0))
      ("UTC +13:00 (Antarctica): McMurdo" . (0 0 13 0 0 0))
      ("UTC +13:00 (Pacific): Enderbury, Auckland, Fakaofo, Tongatapu" . (0 0 13 0 0 0))
      ("UTC +13:45 (Pacific): Chatham" . (0 45 13 0 0 0))
      ("UTC +14:00 (Pacific): Kiritimati, Apia" . (0 0 14 0 0 0))
      ("UTC -01:00 (America): Scoresbysund" . (0 0 -1 0 0 0))
      ("UTC -01:00 (Atlantic): Cape_Verde, Azores" . (0 0 -1 0 0 0))
      ("UTC -02:00 (America): Noronha" . (0 0 -2 0 0 0))
      ("UTC -02:00 (Atlantic): South_Georgia" . (0 0 -2 0 0 0))
      ("UTC -03:00 (America): Argentina/Buenos_Aires, Argentina/Catamarca, Argentina/Cordoba, Argentina/Jujuy, Argentina/La_Rioja, Argentina/Mendoza, Argentina/Rio_Gallegos, Argentina/Salta, Argentina/San_Juan, Argentina/San_Luis, Argentina/Tucuman, Argentina/Ushuaia, Araguaina, Bahia, Belem, Fortaleza, Maceio, Recife, Santarem, Sao_Paulo, Punta_Arenas, Santiago, Cayenne, Nuuk, Asuncion, Miquelon, Paramaribo, Montevideo" . (0 0 -3 0 0 0))
      ("UTC -03:00 (Antarctica): Palmer, Rothera" . (0 0 -3 0 0 0))
      ("UTC -03:00 (Atlantic): Stanley" . (0 0 -3 0 0 0))
      ("UTC -03:30 (America): St_Johns" . (0 -30 -3 0 0 0))
      ("UTC -04:00 (America): Anguilla, Antigua, Aruba, Barbados, La_Paz, Kralendijk, Boa_Vista, Campo_Grande, Cuiaba, Manaus, Porto_Velho, Blanc-Sablon, Glace_Bay, Goose_Bay, Halifax, Moncton, Curacao, Dominica, Santo_Domingo, Thule, Grenada, Guadeloupe, Guyana, Martinique, Montserrat, Puerto_Rico, St_Barthelemy, St_Kitts, St_Lucia, Marigot, St_Vincent, Lower_Princes, Port_of_Spain, Caracas, Tortola, St_Thomas" . (0 0 -4 0 0 0))
      ("UTC -04:00 (Atlantic): Bermuda" . (0 0 -4 0 0 0))
      ("UTC -05:00 (America): Nassau, Eirunepe, Rio_Branco, Atikokan, Iqaluit, Nipigon, Pangnirtung, Thunder_Bay, Toronto, Cayman, Bogota, Havana, Guayaquil, Port-au-Prince, Jamaica, Cancun, Panama, Lima, Grand_Turk, Detroit, Indiana/Indianapolis, Indiana/Marengo, Indiana/Petersburg, Indiana/Vevay, Indiana/Vincennes, Indiana/Winamac, Kentucky/Louisville, Kentucky/Monticello, New_York" . (0 0 -5 0 0 0))
      ("UTC -05:00 (Pacific): Easter" . (0 0 -5 0 0 0))
      ("UTC -06:00 (America): Belize, Rainy_River, Rankin_Inlet, Regina, Resolute, Swift_Current, Winnipeg, Costa_Rica, El_Salvador, Guatemala, Tegucigalpa, Bahia_Banderas, Matamoros, Merida, Mexico_City, Monterrey, Managua, Chicago, Indiana/Knox, Indiana/Tell_City, Menominee, North_Dakota/Beulah, North_Dakota/Center, North_Dakota/New_Salem" . (0 0 -6 0 0 0))
      ("UTC -06:00 (Pacific): Galapagos" . (0 0 -6 0 0 0))
      ("UTC -07:00 (America): Cambridge_Bay, Creston, Dawson, Dawson_Creek, Edmonton, Fort_Nelson, Inuvik, Whitehorse, Yellowknife, Chihuahua, Hermosillo, Mazatlan, Ojinaga, Boise, Denver, Phoenix" . (0 0 -7 0 0 0))
      ("UTC -08:00 (America): Vancouver, Tijuana, Los_Angeles" . (0 0 -8 0 0 0))
      ("UTC -08:00 (Pacific): Pitcairn" . (0 0 -8 0 0 0))
      ("UTC -09:00 (America): Anchorage, Juneau, Metlakatla, Nome, Sitka, Yakutat" . (0 0 -9 0 0 0))
      ("UTC -09:00 (Pacific): Gambier" . (0 0 -9 0 0 0))
      ("UTC -09:30 (Pacific): Marquesas" . (0 -30 -9 0 0 0))
      ("UTC -10:00 (America): Adak" . (0 0 -10 0 0 0))
      ("UTC -10:00 (Pacific): Rarotonga, Tahiti, Honolulu" . (0 0 -10 0 0 0))
      ("UTC -11:00 (Pacific): Pago_Pago, Niue, Midway" . (0 0 -11 0 0 0)))
    "An alist of (time zone representation . time offset). The format of time offset should confirm with the output format from `decode-time'.")
#+end_src

#+begin_src emacs-lisp
  (defun gatsby:gcal-select-timezone ()
    "Select a time zone from `gatsby:timezone-alist', return its offset with respect to `gatsby:local-timezone-offset'."
    (interactive)
    (let* ((selectrum-should-sort-p nil)
           (tz (completing-read "Select TZ: " gatsby:timezone-alist)))
      (cl-map 'list '+ (cdr (assoc tz gatsby:timezone-alist)) gatsgy:local-timezone-offset)))
#+end_src

Now combine these parts into a new scheduling portal.

#+begin_src emacs-lisp
  (defun gatsby:gcal-schedule (tz)
    "Schedule an event.
  If TZ is non-nil or called with a prefix argument, schedule the event at a different time zone.
  If region is active, use the selected text as the event description."
    (interactive (if current-prefix-arg
                     `(,(gatsby:gcal-select-timezone)) '((0 0 0 0 0 0))))
    (let* ((account (completing-read "Schedule an event for: " org-gcal-file-alist))
           (date (cl-map 'list '+ tz (gatsby:gcal-select-date)))
           (start-time (cl-map 'list '+ date (gatsby:gcal-select-time)))
           (end-time (gatsby:gcal-select-duration start-time))
           (desc (when (region-active-p)
                   (buffer-substring-no-properties
                    (region-beginning) (region-end)))))
      (gatsby:gcal--schedule account start-time end-time :desc desc)))

  (general-define-key :keymaps '(normal motion visual) :prefix "SPC"
    "ma" #'gatsby:gcal-schedule)
#+end_src

I also use the following function to visit the org file for viewing the calendar events.

#+begin_src emacs-lisp
  (defun gatsby:gcal-visit-file (account)
    "Visit the org file with the calendar ACCOUNT."
    (interactive (list (completing-read "Select account: " user-all-mail-addresses)))
    (find-file (expand-file-name  (format "~/.cal/%s" account))))

  (general-define-key :keymaps '(normal visual motion) :prefix "SPC"
    "mf" #'gatsby:gcal-visit-file)
#+end_src

~org-gcal~ asks too many questions when deleting events. First, there is an option ~org-gcal-remove-api-cancelled-events~, which is default to ~'ask~ to ask whether I want to remove the local event when the remote event is canceled. I set this variable to ~t~ to always remove those event without asking.

Second, ~org-gcal~ really like using multi-line prompts. This does not work for me as I fixed my minibuffer height to 1, so I need to advice the delete function to remove the newline character.

#+begin_src emacs-lisp
  (setq org-gcal-remove-api-cancelled-events t)

  (defun gatsby:gcal--confirm-delete-event (fn)
    "Do not bother me with answering that I really want to delete this event"
    (cl-letf (((symbol-function 'y-or-n-p)
               (lambda (prompt)
                 (defvar empty-history)
                 (let* ((prompt (->> prompt
                                     (replace-regexp-in-string "?\n\n" ": *")
                                     (replace-regexp-in-string "\n\n" "* (y or n) ")))
                        (empty-history '())
                        (enable-recursive-minibuffers t)
                        (msg help-form)
                        (keymap (let ((map (make-composed-keymap
                                            y-or-n-p-map query-replace-map)))
                                  (when help-form
                                    ;; Create a new map before modifying
                                    (setq map (copy-keymap map))
                                    (define-key map (vector help-char)
                                      (lambda ()
                                        (interactive)
                                        (let ((help-form msg)) ; lexically bound msg
                                          (help-form-show)))))
                                  map))
                        (this-command this-command)
                        (str (read-from-minibuffer
                              prompt nil keymap nil
                              (or y-or-n-p-history-variable 'empty-history))))
                   (if (member str '("y" "Y")) t nil)))))
      (call-interactively fn)))

  (advice-add #'org-gcal-delete-at-point :around #'gatsby:gcal--confirm-delete-event)
#+end_src

~org-gcal~ sends a lot of useless alerts (e.g., when (un)successfully fetched/sync with remote), but do not have send any reminder e.g., 10 minutes before events.

I first use the echo area (instead of ~alert~) to display message in ~org-gcal~.

#+begin_src emacs-lisp
  (defun gatsby:gcal--notify (title msg)
    (let ((msg (replace-regexp-in-string "\n" " " msg)))
      (message "%s: %s" title msg)))

  (advice-add #'org-gcal--notify :override #'gatsby:gcal--notify)
#+end_src

To setup reminder, I use the builtin ~appt~ package, overriding sending reminder using ~alert~. The method is first documented in [[https://emacs.stackexchange.com/questions/3844/good-methods-for-setting-up-alarms-audio-visual-triggered-by-org-mode-events][here]].

~appt~ extracts event information from ~org-agenda~. Therefore I need to first register my calendar file with ~org-agenda~.

#+begin_src emacs-lisp
  (setq org-agenda-files (f-glob (expand-file-name "~/.cal/*")))
#+end_src

The ~appt-time-msg-list~ variable contains a list of appointments to send reminders for. Use ~org-agenda-to-appt~ function can update this variable for any new reminders that should be setup.

#+begin_src emacs-lisp
  (defun gatsby:gcal--update-reminders (&rest _)
    (cl-letf (((symbol-function 'message) #'ignore))
      (setq appt-time-msg-list nil)
      (org-agenda-to-appt)))
#+end_src

I want to update the reminder list
+ when starting ~emacs~.
+ when fetching/synchronizing calendars from remote.
+ when scheduling new events.
+ at 0:01 every day to fetch new reminder list of the day

#+begin_src emacs-lisp
  ;; at start up
  (gatsby:gcal--update-reminders)

  ;; when scheduling events
  (advice-add #'org-gcal-post-at-point :after #'gatsby:gcal--update-reminders)
  (advice-add #'org-gcal-delete-at-point :after #'gatsby:gcal--update-reminders)

  ;; at 00:01 every day
  (run-at-time "12:01am" (* 24 3600) #'gatsby:gcal--update-reminders)
#+end_src

Updating the reminder after fetching/synchronizing requires using ~emacs-deferred~ package to append a sentinel function at the end of a successful fetching/synchronizing attempt. I can also take advantage to ask ~org-gcal~ automatically save the local calendar files when finishing fetching/synchronizing and close the relevant buffer.

#+begin_src emacs-lisp
  (defun gatsby:org-gcal-sync (&optional skip-export silent)
    "Sync local and remote calendar(s).  If SKIP-EXPORT is non-nil, only fetch.
  Set SILENT to non-nil to inhibit notifications."
    (interactive)
    (org-gcal--ensure-token)
    (when org-gcal-auto-archive
      (dolist (i org-gcal-fetch-file-alist)
        (with-current-buffer
            (find-file-noselect (cdr i))
          (org-gcal--archive-old-event))))
    (let ((up-time (org-gcal--up-time))
          (down-time (org-gcal--down-time)))
      (deferred:loop org-gcal-fetch-file-alist
        (lambda (calendar-id-file)
          (deferred:$
            (org-gcal--sync-calendar calendar-id-file skip-export silent
                                     up-time down-time)
            (deferred:nextc it
              (lambda (_)
                (unless silent
                  (org-gcal--notify "Completed event fetching ."
                                    (concat "Events fetched into\n"
                                            (cdr calendar-id-file))))))

            ;; update appt.
            (deferred:nextc it
              (lambda (_)
                (gatsby:gcal--update-reminders)))

            ;; save and close file
            (deferred:nextc it
              (lambda (_)
                (with-current-buffer (car calendar-id-file)
                  (save-buffer)
                  (kill-buffer))
                (deferred:succeed nil))))))))

  (advice-add #'org-gcal-sync :override #'gatsby:org-gcal-sync)
#+end_src

Now load ~appt~ package and overrides how to show reminder.

#+begin_src emacs-lisp
  (use-package appt :straight (:type built-in))
#+end_src

~appt~ supports customize how many minutes before the event starts to send the reminder, as well as how many reminders to send for one event. I want a 5 minute buffer time between the reminder and the event, and display the reminder only once.

#+begin_src emacs-lisp
  (setq appt-message-warning-time 5
        appt-display-interval appt-message-warning-time)
#+end_src

I override the way ~appt~ sends reminder by setting ~appt-disp-window-function~, which is a function automatically called when we are ~appt-message-warning-time~ minutes away from an event if ~appt-display-format~ is set to ~'window~.

#+begin_src emacs-lisp
  (defun gatsby:gcal--reminder (min-to-app _new-time msg)
    (unless (listp min-to-app)
      (setq min-to-app (list min-to-app)
            msg (list msg)))
    (--each (-zip min-to-app msg)
      (alert (format "%s in %s minutes" (cdr it) (car it)) :title "Upcoming Event")))

  (setq appt-display-format 'window
        appt-disp-window-function 'gatsby:gcal--reminder)
#+end_src

Schedule ~org-cal~ to sync with the remote calendar every 30 minutes and start ~appt~ "daemon" to watch for reminder.

#+begin_src emacs-lisp
  (run-at-time nil 3600 #'org-gcal-sync)
  (appt-activate 1)
#+end_src

*** frontend: calfw

Although the builtin ~org-agenda~ can serve as the frontend for displaying calendar events. It is less intuitive. ~calfw~ offers a TUI-like interface to display calendar events.

Three other comments on configuring ~calfw~:

+ ~calfw~ is an old package that likes to define its own faces. Oftentimes, these faces are inconsistent with the theme I use. To correct this, I redefine ~calfw~ faces to inherit from builtin faces.
+ ~calfw~ uses the builtin ~emacs~ style keybindings. I need to change it to
  ~evil~ style.

#+begin_src emacs-lisp
  (use-package calfw
    :straight (:host github :repo "tumashu/emacs-calfw" :files ("calfw-org.el" "calfw.el"))
    :custom-face
    (calfw-face-title ((t (:inherit default :height 2.0))))
    (calfw-face-toolbar ((t (:inherit default))))
    (calfw-face-toolbar-button-off ((t (:inherit button))))
    (calfw-face-toolbar-button-on ((t (:inherit default :foreground "Gray50"))))

    (calfw-face-header ((t (:inherit bold))))
    (calfw-face-sunday ((t (:inherit calfw-face-header))))
    (calfw-face-saturday ((t (:inherit calfw-face-header))))
    (calfw-face-holiday ((t (:inherit italic))))
    (calfw-face-day-title ((t (:inherit default))))
    (calfw-face-select ((t (:inherit holiday))))
    (calfw-face-today ((t (:inherit highlight))))
    (calfw-face-today-title ((t (:inherit highlight))))

    :general
    (:keymaps 'calfw-calendar-mode-map
     :states 'normal
     "q" #'bury-buffer
     "r" #'calfw-refresh-calendar-buffer

     "H" #'calfw-navi-goto-week-begin-command
     "L" #'calfw-navi-goto-week-end-command
     "K" #'calfw-navi-previous-week-command
     "J" #'calfw-navi-next-week-command

     ">" #'calfw-navi-next-month-command
     "<" #'calfw-navi-previous-month-command

     "h" #'calfw-navi-previous-day-command
     "l" #'calfw-navi-next-day-command
     "b" #'calfw-navi-previous-day-command
     "w" #'calfw-navi-next-day-command
     "k" #'calfw-navi-prev-item-command
     "j" #'calfw-navi-next-item-command

     "d" #'calfw-show-details-command
     "RET" #'calfw-show-details-command
     "M" #'calfw-change-view-month
     "W" #'calfw-change-view-week
     "D" #'calfw-change-view-day
     "t" #'calfw-navi-goto-today-command
     "TAB" #'calfw-navi-next-item-command
     "<backtab>" #'calfw-navi-prev-item-command)

    (:keymaps 'calfw-details-mode-map
     :states 'normal
     "q" #'calfw-details-kill-buffer-command
     "TAB" #'calfw-details-navi-next-item-command
     "<backtab>" #'calfw-details-navi-prev-item-command))
#+end_src

I mainly use ~calfw~ to display events in org format. So I need to load the ~calfw-org~ library.

#+begin_src emacs-lisp
  (use-package calfw-org :straight (:type built-in))
#+end_src

To put events onto ~calfw~ calendar, I need to first register it using ~calfw-create-calendar-component-buffer~. To register a set of events, I need to

+ assign a name;
+ associate the name with an org file that holds the events;
+ assign a color.

The first two step can be read from ~org-cal-file-alist~, whose ~car~ and ~cdr~ are the account address (which can be used as the calendar name) and the org file path, respectively. I only need to assign a color to each one of them for it to work.

#+begin_src emacs-lisp
  (defconst gatsby:calfw-candidate-colors
    '("#268bd2" "#8DC85F" "#e06c75" "#e5c07b" "#ECA964" "#FF96B3" "#D1A5FF")
    "The color used in calfw to differentiate between different calendars.")

  (defun gatsby:calfw-open-calendar ()
    (interactive)
    (when (functionp 'org-gcal-sync)
      (org-gcal-sync nil t))
    (let ((cp
           (calfw-create-calendar-component-buffer
            :view 'week
            :contents-sources
            (--map (calfw-org-create-file-source (caar it) (cdar it) (cdr it))
                   (-zip org-gcal-file-alist gatsby:calfw-candidate-colors)))))
      (switch-to-buffer (calfw-cp-get-buffer cp))))

  (general-define-key :keymaps '(normal visual motion) :prefix "SPC"
    "mo" #'gatsby:calfw-open-calendar)
#+end_src

There are several small improvements I add to the stock ~calfw~ packages. First, I advice the ~calfw-show-detail-command~ to always split the window vertically (top/down) so that it would not mess up with the line wrapping of the calendar.

#+begin_src emacs-lisp
  (defun gatsby:calfw--split-vertically (fn &rest _)
    (let ((split-window-preferred-function (lambda (&rest _) (split-window-below))))
      (call-interactively fn)))

  (advice-add #'calfw-show-details-command :around #'gatsby:calfw--split-vertically)
#+end_src

Second, I want to be able to schedule events from ~calfw~ calendar views.

#+begin_src emacs-lisp
  (defun gatsby:calfw-schedule (&optional tz)
    "Schedule an event using `calfw-cursor-to-nearest-date' for date."
    (interactive "p")
    (let* ((account (completing-read "Schedule an event for: " org-gcal-file-alist))
           (tz (if tz (gatsby:gcal-select-timezone) '(0 0 0 0 0 0)))
           (date (cl-map 'list '+ (calfw-cursor-to-nearest-date) tz))
           (start-time (cl-map 'list '+ date (gatsby:gcal-select-time)))
           (end-time (gatsby:gcal-select-duration start-time)))
      (gatsby:gcal--schedule account start-time end-time)))

  (general-define-key :keymaps 'calfw-calendar-mode-map :states 'normal
    "n" #'gatsby:calfw-schedule)
#+end_src

Scheduling an event from ~calfw~ detail views is a little bit more tricky. Since the detail view does not contain any meta data (just formatted text), I can either extract the ~date~ information from formatted text, or advice ~calfw-show-details-command~ to store some meta data to the detail buffer. I implement the former since it is less intrusive.

#+begin_src emacs-lisp
  (defun gatsby:calfw-schedule-from-detail (&optional tz)
    "Schedule an event from `calfw-details-buffer' using the date of the detail buffer."
    (interactive "p")
    (let* ((account (completing-read "Schedule an event for: " org-gcal-file-alist))
           (tz (if tz (gatsby:gcal-select-timezone) '(0 0 0 0 0 0)))
           (date (save-excursion
                   (goto-char (point-min))
                   `(0 0 0 ,@(->> (thing-at-point 'line)
                                  (s-split "/")
                                  seq-reverse
                                  (--map (replace-regexp-in-string "[a-zA-Z]+" "" it))
                                  (-map 'string-to-number)))))
           (date-with-tz (cl-map 'list '+ tz (gatsby:gcal-select-date)))
           (start-time (cl-map 'list '+ date-with-tz (gatsby:gcal-select-time)))
           (end-time (gatsby:gcal-select-duration start-time)))
      (gatsby:gcal--schedule account start-time end-time)))

  (general-define-key :keymaps 'calfw-details-mode-map :states 'normal
    "n" #'gatsby:calfw-schedule)
#+end_src

Finally, the builtin ~calfw-detail-mode~ is a ascii text mode. This is not ideal as my event details are all in org-mode, which supports links, etc. I would like to make ~calfw-detail-mode~ to inherit ~org-mode~'s font lock so that my event details has properly highlights.

#+begin_src emacs-lisp
  (advice-add #'calfw-details-mode :after #'org-set-font-lock-defaults)
#+end_src

Finally, I would like to use ~RET~ to visit links in ~calfw-details-mode~ just
like in ~org-mode~.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'calfw-details-mode-map :states 'normal
    "RET" #'org-open-at-point)
#+end_src

** Slack Client

Slack is an important tool for communication in a corporate setting. ~emacs~ has a reasonably workable Slack client.

Like ~calfw~, the Slack package comes with some hard-coded faces.

#+begin_src emacs-lisp
  (use-package slack
    :custom-face
    (slack-preview-face ((t (:inherit highlight))))
    (slack-new-message-marker-face ((t (:height 1.0 :foreground "#d33682"))))

    :general
    (:keymaps '(slack-mode-map slack-buffer-mode-map)
     :states 'normal
     "<" #'slack-buffer-goto-prev-message
     ">" #'slack-buffer-goto-next-message
     "A" (lambda () (interactive) (goto-char (point-max)) (call-interactively #'evil-append))
     "q" #'kill-buffer-and-window)

    (:keymaps '(slack-mode-map slack-buffer-mode-map slack-edit-message-mode-map)
     :state '(normal visual insert)
     :prefix "C-c"
     "m" #'slack-message-embed-mention
     "M" #'slack-message-embed-channel))
#+end_src

To use slack, I need to register "team". Currently, I have two teams: the Department of Economics at UC Berkeley, and the incoming cohorts of Robinhood University recruits. For the same reason that I explained in setting up ~org-gcal~ ([[backend: org-gcal]]), I hook the interactive authentication process to the ~server-after-make-frame-hook~ to start the slack process.

#+begin_src emacs-lisp
  (defvar gatsby:slack-started-p nil "Non-nil if `slack-start' has been run before.")

  (defun gatsby:slack--init (&rest _)
    (when (and (not gatsby:slack-started-p)
               (server-running-p))

      (slack-register-team
       :name "berkeley-econ"
       :token (password-store-get "slack/berkeley-econ")
       :subscribed-channels '(general jmc p-room)
       :full-and-display-names t
       :modeline-enabled t
       :modeline-name "CAL"
       :animate-image t)

      (slack-register-team
       :name "robinhood-university"
       :token (password-store-get "slack/robinhood-university")
       :subscribed-channels '(general)
       :full-and-display-names t
       :modeline-enabled t
       :modeline-name "RU"
       :animate-image t)

      (slack-start)
      (setq gatsby:slack-started-p t)
      ;; modeline lighter
      (add-to-list 'gatsby:right-mode-line '(:eval slack-modeline))
      ;; update every 5 minutes
      (run-at-time nil 300 #'slack-update-modeline)))

  (add-hook 'server-after-make-frame-hook #'gatsby:slack--init)
#+end_src

Again, I want to put a small lighter on the mode-line to remind me whether I have new messages. Slack has a builtin mode-line lighter, but it takes up too much space. I override it with a more compact one.

My slack mode-line is very simple. If I have unread threads, the team name will be visible on the mode-line with an ~error-face~. If there are unread messages in the channels that I subscribed to, the team name will again be visible, but with a ~warning-face~. When I have both unread messages and threads, threads will have precedence. When I have neither, nothing will appears on my mode-line.

#+begin_src emacs-lisp
  (defun gatsby:slack--format-modeline (alist)
    (let* ((slack-status (-non-nil (-map #'gatsby:slack--format-modeline-1 alist)))
           (status (if slack-status (s-join "|" slack-status) "0")))
      (format "[S:%s] " status)))

  (defun gatsby:slack--format-modeline-1 (elm)
    "ELM is '(team-name . ((thread . (has-unreads . mention-count)) (channel . (has-unreads . mention-count))))"
    (let* ((name (car elm))
           (summary (cdr elm))
           (thread (cdr (assq 'thread summary)))
           (channel (cdr (assq 'channel summary)))
           (unread (or (car thread) (car channel)))
           (thread-count (cdr thread))
           (channel-count (cdr channel)))
      (cond ((not unread) nil)
            ((> 0 thread-count) (propertize name 'face 'compilation-error))
            ((> 0 channel-count) (propertize name 'face 'compilation-warning)))))

  (setq slack-modeline-formatter #'gatsby:slack--format-modeline)
#+end_src

The builtin ~slack-[something]-open~ functions are annoying, since I have to use different commands to open im, channel, group, ... chat window. It also requires me to specify the team before I can select which chat window I can open. Instead of binding all those things to different keybindings. I decide to write a small wrapper so I can open any chat from all my teams, ims, channels, groups, etc.

#+begin_src emacs-lisp
  (defun gatsby:slack-open ()
    "Open a channel, group or im within `slack-current-team'."
    (interactive)
    (let* ((team (slack-team-select 'no-default))
           (room (slack-room-select (nconc (slack-team-ims team)
                                           (slack-team-channels team)
                                           (slack-team-groups team))
                                    team)))
      (slack-room-display room team)))

(general-define-key :keymaps '(normal motion) :prefix "SPC"
 "mq" #'gatsby:slack-open)
#+end_src

A big advantage of using slack within ~emacs~ is that I can interact with slack from within ~emacs~. One use case that is particularly interesting is the ability to select arbitrary code/text from an arbitrary ~emacs~ buffer and send it to slack, which I implement in the following function

#+begin_src emacs-lisp
  (defun gatsby:slack--open-quote-editor (room team quote-string)
    "Open an editor for ROOM in TEAM. Put QUOTE-STRING into the editor.

  Taken from `slack-room-display'."
    (cl-labels
        ((edit (buf)
               (let ((editor-buf (slack-buffer-display-message-compose-buffer buf)))
                 ;; HACK: wait 0.5 sec for the buffer creation to finish
                 (run-at-time 0.5 nil (lambda () (insert quote-string))))))
      (let ((buf (slack-buffer-find 'slack-message-buffer team room)))
        (if buf (edit buf)
          (message "No Message in %s, fetching from server..." (slack-room-name room team))
          (slack-room-clear-messages room)
          (slack-conversations-view
           room team
           :after-success #'(lambda (messages cursor)
                              (slack-room-set-messages room messages team)
                              (edit (slack-create-message-buffer room cursor team))))))))

  (defun gatsby:slack-quote (beg end)
    "Insert the visually selected text/code into a slack message. Prompt the user to choose the team and room for the text."
    (interactive "r")
    (let* ((raw-string (filter-buffer-substring beg end))
           (quote-type-map '(("text" . (lambda (tx)
                                         (->> tx
                                              (s-split "\n")
                                              (--map (concat "> " it))
                                              (s-join "\n"))))
                             ("code" . (lambda (tx)
                                         (concat "```" tx "```")))))
           (quote-type (completing-read "quoting: " '("text" "code")))
           (quote-string (funcall (cdr (assoc-string quote-type quote-type-map)) raw-string))
           ;; select destination
           (team (slack-team-select 'no-default))
           (room (slack-room-select
                  (nconc (slack-team-ims team)
                         (slack-team-channels team)
                         (slack-team-groups team))
                  team)))
      (gatsby:slack--open-quote-editor room team quote-string)))

  (general-define-key :keymaps 'visual :prefix "SPC"
    "mq" #'gatsby:slack-quote)
#+end_src

For some reasons, slack makes ~slack-message-write-another-buffer~, which opens a temporary buffer to compose slack message, and ~slack-message-edit~, which opens a temporary buffer to edit a sent message, two different functions, where in fact, the only difference is that the ~slack-message-edit~ requires an additional parameter ~ts~. I consolidate these two commands and provide an unified command for editing messages.

#+begin_src emacs-lisp
  (defun gatsby:slack-edit ()
    "Edit the message at point."
    (interactive)
    (if (slack-get-ts)
        (call-interactively 'slack-message-edit)
      (call-interactively 'slack-message-write-another-buffer)))

  (general-define-key :keymaps '(slack-mode-map slack-buffer-mode-map) :states 'normal :prefix "C-c"
    "'" #'slack-message-write-another-buffer)
#+end_src

Finally, add key bindings for reactions.

#+begin_src emacs-lisp
  (general-define-key :keymaps '(slack-mode-map slack-buffer-mode-map) :states 'normal :prefix "C-c"
    "r" #'slack-message-add-reaction
    "R" #'slack-message-remove-reaction)
#+end_src

* Production Environment
** Emacs-Lisp

The builtin ~elisp-mode~ is, of course, good enough for editing ~elisp~ file.

#+begin_src emacs-lisp
  (use-package elisp-mode :straight (:type built-in))
#+end_src

Set the ~tab-width~ to 2  in ~elisp-mode~, as lisp do not look good with too many spaces.

#+begin_src emacs-lisp
  (defun gatsby:lisp--set-tab-width ()
    (setq-local tab-width 2))

  (add-hook 'emacs-lisp-mode-hook #'gatsby:lisp--set-tab-width)
#+end_src

*** REPL: ielm

Although I have ~eval-last-sexp~ to evaluate lisp expressions, it is useful sometime to have a real REPL. ~ielm~ fills this hole.

#+begin_src emacs-lisp
  (use-package ielm :straight (:type built-in))
#+end_src

Enable autocompletion in the REPL buffer.

#+begin_src emacs-lisp
  (add-hook 'ielm-mode-hook #'company-mode)
#+end_src

~ielm~ is derived from ~comint~ mode, so I only need to register the REPL function to ~gatsby:comint-repl-function-alist~ variable.

#+begin_src emacs-lisp
  (defun gatsby:ielm-repl ()
    "Start an ielm REPL."
    (interactive)
    (let* ((buf (get-buffer-create "*ielm*")))
      (unless (comint-check-proc buf)
        (with-current-buffer buf
          (inferior-emacs-lisp-mode)))
      buf))

  (add-to-list 'gatsby:comint-repl-function-alist '(emacs-lisp-mode gatsby:ielm-repl))
  (add-to-list 'gatsby:comint-repl-function-alist '(lisp-interaction-mode gatsby:ielm-repl))

  (add-to-list 'gatsby:comint-repl-mode-alist '(emacs-lisp-mode . inferior-emacs-lisp-mode))
  (add-to-list 'gatsby:comint-repl-mode-alist '(lisp-interaction-mode . inferior-emacs-lisp-mode))
#+end_src

~ielm~ uses a different ~send-input~ function, I need to accommodate it here.

#+begin_src emacs-lisp
  (defun gatsby:ielm--eval-input ()
    (ielm-eval-input ielm-input))

  (defun gatsby:ielm-return ()
    (interactive)
    (advice-add #'comint-send-input :after #'gatsby:ielm--eval-input)
    (call-interactively #'gatsby:comint-return)
    (advice-remove #'comint-send-input #'gatsby:ielm--eval-input))

  (general-define-key :keymaps 'inferior-emacs-lisp-mode-map :states 'insert
    "<return>" #'gatsby:ielm-return)
#+end_src

In most of the time, it makes more sense to evaluate the sexp around point, rather than the line at point. Therefore, instead of calling ~eval-region-or-line~, I define a new function ~eval-region-or-sexp~ for this purpose.

#+begin_src emacs-lisp
  (defun gatsby:lisp-eval-region-or-sexp ()
    "Evaluate the selected region if in visual state. Otherwise evaluate the sexp before point."
    (interactive)
    (if (region-active-p)
        (gatsby:comint--eval-region 'ielm-send-input (region-beginning) (region-end))
      (save-excursion
        (backward-sexp)
        (gatsby:comint--send-code-to-repl 'ielm-send-input (thing-at-point 'sexp)))))
#+end_src

Finally, define the entry point of REPL.

#+begin_src emacs-lisp
  (general-define-key :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map) :states '(motion normal visual) :prefix "SPC"
    "rr" #'gatsby:lisp-eval-region-or-sexp
    "rb" #'gatsby:comint-eval-buffer
    "rz" #'gatsby:comint-associate-repl
    "ro" #'gatsby:comint-start-or-pop-to-repl)
#+end_src

*** helpful mode

~emacs~ is self-documented. The docstrings of any function or variable can be retrieved and displayed in the ~*help*~ buffer. ~helpful-mode~ improves upon the builtin ~*help*~ buffer to display more information.

#+begin_src emacs-lisp
  (use-package helpful)
#+end_src

Since I will not (and should not) edit the content in the ~helpful~ buffers, I put it in the motion state.

#+begin_src emacs-lisp
  (add-to-list 'evil-motion-state-modes 'helpful-mode)
#+end_src

Finally, define entry point for ~helpful~ mode.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'helpful-mode-map :states 'motion :prefix "SPC"
    "q" #'kill-buffer-and-window)

  (general-define-key :keymaps '(motion normal visual) :prefix "SPC"
    "hf" 'helpful-callable
    "hk" 'helpful-key
    "hv" 'helpful-variable
    "hm" 'describe-mode)
#+end_src

*** aggressive indent

~aggressive-indent-mode~ is useful to automatically adjusting indent lisp codes.

#+begin_src emacs-lisp
  (use-package aggressive-indent)

  (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
#+end_src

*** easy escape

It is difficult to read regexp in ~elisp~, since I need to escape the escape character (\) itself, resulting in strings like "\\\\(\\\\)" ~easy-escape~ mode solves this problem by applying additional font locks to the escaped characters, making them easier to read.

#+begin_src emacs-lisp
  (use-package easy-escape)

  (add-hook 'emacs-lisp-mode-hook #'easy-escape-minor-mode)
  (add-hook 'ielm-mode-hook #'easy-escape-minor-mode)
#+end_src

** Python

Python is a general purpose language with many libraries that enable people to jump on a task without worrying too much about inventing the wheel. I use version 3.9 of python.

#+begin_src nix :noweb-ref home-manager
  home.packages = with pkgs; [
    (python39.withPackages (p: with p; [ jupyter ]))
  ];
#+end_src

I use the builtin ~python-mode~, together with ~emacs-jupyter~ and ~eglot~ for REPL/LSP support.

#+begin_src emacs-lisp
  (use-package python
    :mode ("\\.py'" . python-mode)
    :init
    (defun gatsby:python--set-indent-width ()
      (setq-local tab-width 4)
      (setq python-indent-offset 4))

    (setf (alist-get 'python-mode eglot-server-programs)
          '("pyright-langserver" "--stdio"))
    :hook
    (python-mode . gatsby:python--set-indent-width)
    (python-mode . eglot-ensure)
#+end_src

Register python with ~emacs-jupyter~ to enable REPL for python.

#+begin_src emacs-lisp
  :config

  (defun gatsby:python-start-repl ()
    "Infer python versions from shebang.  If there is no shebang, promote the user for python's version."
    (let* ((shebang (save-excursion (goto-char 1) (thing-at-point 'line)))
           (kernel (if (string-match "#!/usr/bin/env\s+\\(python.?\\)" (or shebang ""))
                       (match-string 1 shebang)
                     (completing-read "Cannot infer python interpreter, please select: "
                                      '("python2" "python3")))))
      (jupyter-run-repl kernel kernel (current-buffer) nil t)))

  (add-to-list 'gatsby:jupyter-repl-function-alist '(python-mode . gatsby:python-start-repl))
#+end_src

Python is different as indentation is part of the syntax. The following functions deal with this feature when sending indented code to REPL.

#+begin_src emacs-lisp
  (defun gatsby:python--dedent-string (string)
    "remove the comment indentation of STRING."
    (let ((strings (split-string string "\n")))
      (if (cdr strings)
          ;; multiline, need to remove indentation
          (let ((indent (if (string-match "^[\t ]+" (car strings))
                            (length (match-string 0 (car strings)))
                          0)))
            (s-join "\n"
                    (--map (if (s-prefix-p (s-repeat indent " ") it)
                               (substring it indent)
                             ""))))
        string)))

  (defun gatsby:python-eval-region-or-line ()
    "If region is active, eval current region, otherwise eval current line."
    (interactive)
    (let* ((region (if (use-region-p)
                       (list (region-beginning) (region-end))
                     (list (line-beginning-position) (line-end-position))))
           (string (gatsby:python--dedent-string (apply
                                                  #'buffer-substring-no-properties
                                                  region))))
      (jupyter-eval-string string)
      (deactivate-mark)))
#+end_src

Now define keybindings.

#+begin_src emacs-lisp
  :general
  (:states '(motion normal visual)
   :keymaps 'python-mode-map
   :prefix "SPC"
   "rb" 'jupyter-eval-buffer
   "rr" 'gatsby:python-eval-line-or-region
   "ro" 'gatsby:jupyter-start-or-switch-to-repl

   "rz" 'jupyter-repl-associate-buffer
   "rZ" 'jupyter-repl-restart-kernel))
#+end_src

** STATA

STATA is a package that can conduct statistical analysis using its own script-like language. It has two main advantages for me: it is widely used in economics community, and therefore has a large array of packages to perform different statistical analyses. I am also more familiar with it than the R package.

#+begin_src nix :noweb-ref home-manager
  home = {
    packages = with pkgs; let
      stata = stdenv.mkDerivation {
        name = "stata-14";
        src = /home/lactaid/Downloads/stata;
        # FIXME: still complaining not finding the following libraries
        # installing from arch for now
        # (libpng12; ncurses5-compat-libs)
        propagatedBuildInputs = [ ncurses5 libpng12 ];
        installPhase = ''
          export plat=linux.64

          buildDir=$(pwd)
          mkdir -p $out
          cp unix/linux.64/ado.taz $out/ado.tar.Z
          cp unix/linux.64/base.taz $out/base.tar.Z
          cp unix/linux.64/bins.taz $out/bins.tar.Z
          cp unix/linux.64/docs.taz $out/docs.tar.Z
          cp unix/linux.64/setrwxp $out/setrwxp
          cp unix/linux.64/inst2 $out/inst2

          cd $out
          ./inst2 now

          # install license file
          cp $buildDir/stata.lic ./
        '';
      };

      kernelFile = {
        display_name = "Stata";
        language = "stata";
        argv = ["python" "-m" "stata_kernel" "-f" "{connection_file}"];
      };

      stataKernel = python39.pkgs.buildPythonPackage rec {
        pname = "stata_kernel";
        version = "1.12.2";
        src = builtins.fetchTarball {
          url = https://github.com/kylebarron/stata_kernel/archive/v1.12.2.tar.gz;
        };
        propagatedBuildInputs = [
          pkgs.python39
          python39Packages.beautifulsoup4
          python39Packages.jupyter
          python39Packages.pandas
          python39Packages.packaging
          python39Packages.pillow
          python39Packages.pexpect
          python39Packages.pygments
          python39Packages.requests
          stata
        ];
        doCheck = false;
        postInstall = ''
          # install kernel files
          mkdir -p $out/kernels/stata_kernel
          echo '\${builtins.toJSON kernelFile}' > $out/kernels/stata_kernel/kernel.json
          '';
      };
    in
      [ stata stataKernel ];

    file.".stata_kernel.conf".text = ''
      [stata_kernel]
      stata_path = \${stata}/stata-mp
      execution_mode = console
      cache_directory = ~/.cache/stata_kernel_cache
      autocomplete_closing_symbol = False
      graph_format = svg
      graph_scale = 1
      user_graph_keywords = coefplot,vioplot
    '';

    sessionVariables = {
      JUPYTER_PATH = ''$JUPYTER_PATH''${JUPYTER_PATH:+:}${stataKernel}'';
    };
  };
#+end_src

There is no official major mode for stata ~do~ script files. ~ess~ (emacs speak statistics) used to offer an integrated development environment for STATA (in addition to R and other statistical packages). Yet, ~ess-stata-mode~ became [[http://ess.r-project.org/Manual/news.html][obsolete]] since version 19.03. I use a stripped down version of ~stata-mode~ to work in STATA script files.

#+begin_src emacs-lisp
  (use-package stata-mode
    :straight (stata-mode :repo "junyi-hou/stata-mode" :host github)
    :mode ("\\.do'" . stata-mode)
#+end_src

STATA has a very useful jupyter [[https://kylebarron.dev/stata_kernel/][kernel]] which allows me to run STATA do script in a jupyter console/notebook. I use ~stata_kernel~ in conjuncture with ~emacs-jupyter~, so I can send codes from my ~do~ script buffers to a inferior jupyter process.

#+begin_src emacs-lisp
  :config
  (add-to-list 'gatsby:jupyter-repl-function-alist '(stata-mode . "stata"))

  :general
  (:states '(motion normal visual)
   :keymaps 'stata-mode-map
   :prefix "SPC"
   "rb" 'jupyter-eval-buffer
   "rr" 'jupyter-eval-line-or-region
   "ro" 'gatsby:jupyter-start-or-switch-to-repl

   "rz" 'jupyter-repl-associate-buffer
   "rZ" 'jupyter-repl-restart-kernel))
#+end_src

** Nix

I use nix to manage my dotfiles and development environments. nix uses its own language to manage setups. Therefore, it would be ideal if I can read and write nix files in ~emacs~ to modify my nix settings.

There are several useful packages for day-to-day and development with ~nix~:

#+begin_src emacs-lisp
  (use-package nix-mode
    :straight (nix-mode :host github :repo "nixOS/nix-mode"
                        :files (:defaults "*.el"))
    :mode ("\\.nix\\'" "\\.nix.in\\'")
#+end_src

nix community offers a basic LSP server for linting .nix file. I register it with ~home-manager~ first and then hook it onto the ~eglot~ server program so it can recognize and run LSP server automatically when I open a .nix file.

#+begin_src nix :noweb-ref home-manager
  home.packages = [
    (import (builtins.fetchTarball {
      url = https://github.com/nix-community/rnix-lsp/archive/master.tar.gz;
    }))
  ];
#+end_src

#+begin_src emacs-lisp
  :config
  (add-to-list 'eglot-server-programs '(nix-mode . ("rnix-lsp")))
  (add-hook 'nix-mode-hook #'eglot-ensure)
#+end_src

nix supports REPL. ~nix-mode~ has a builtin ~nix-repl~ command to run REPL. Since ~nix-repl~ is a derived mode from ~comint-mode~, configuring ~nix-repl~ is relatively easy:

#+begin_src emacs-lisp
  (add-to-list 'gatsby:comint-repl-function-alist '(nix-mode gatsby:nix-repl))
  (add-to-list 'gatsby:comint-repl-mode-alist '(nix-mode . nix-repl-mode))

  (defun gatsby:nix-repl ()
    (let ((buf (get-buffer-create "*Nix-REPL*")))
      (unless (comint-check-proc buf)
        (nix--make-repl-in-buffer buf)
        (with-current-buffer buf (nix-repl-mode)))
      buf))

  (general-define-key :keymaps 'nix-mode-map :states '(normal visual) :prefix "SPC"
    "ro" #'gatsby:comint-start-or-pop-to-repl
    "rr" #'gatsby:comint-eval-region-or-line
    "rb" #'gatsby:comint-eval-buffer
    "rz" #'gatsby:comint-associate-nix-repl))
#+end_src

Sometimes I would like to check out package files located at ~nix-store~. To ensure reproducible environment, nix installs packages to a unique path in ~nix-store~ by prefixing the package name with a hash. This makes it difficult to quickly navigate to the path where a particular package is installed. Luckily, I have ~selectrum~ and ~prescient~. And the following function will make it super easy in finding the path in ~nix-store~.

#+begin_src emacs-lisp
  (defun gatsby:nix-eshell-in-storage (storage)
    "Open an eshell in the directory of STORAGE."
    (interactive (list (read-file-name "Select the package directory: "
                                       "/nix/store/"
                                       nil
                                       nil
                                       nil
                                       'directory-name-p)))
    (gatsby:eshell-open-here storage))

  (general-define-key :keymaps 'normal :prefix "SPC"
    "ns" #'gatsby:nix-eshell-in-storage)
#+end_src

I use ~nixpkgs-fmt~ to format my nix code before save.

#+begin_src nix :noweb-ref home-manager
  home.packages = with pkgs; [
      nixpkgs-fmt
  ];
#+end_src

#+begin_src emacs-lisp
  (setq nix-nixfmt-bin "nixpkgs-fmt")

  (defun gatsby:nix--fmt-before-save ()
    (add-hook 'before-save-hook #'nix-format-buffer nil t))

  (add-hook 'nix-mode-hook #'gatsby:nix--fmt-before-save)
#+end_src

Finally, the ~nix-prefetch-X~ scripts are convenient since it allows me to get the hash value of source codes that I can feed to the ~fetcher~ function later.

#+begin_src nix :noweb-ref home-manager
  home.packages = with pkgs; [
    nix-prefetch-scripts
    nix-prefetch-github
  ];
#+end_src

** Markdown

~emacs~ is also useful to edit and read non-code text as well. The first of which is ~markdown~ files.

#+begin_src emacs-lisp
(use-package markdown-mode :mode ("\\.markdown\\'" "\\.md\\'"))
#+end_src

Furthermore, I can use ~emacs~ to read system logs using ~journalctl~ and ~syslogd~.

** System Journal

#+begin_src emacs-lisp
  (use-package journalctl-mode
    :if (executable-find "journalctl")
    :commands journalctl)

  (use-package syslog-mode
    :if (executable-find "syslogd"))
#+end_src

~journalctl-mode~ offers an interactive way to read the journal file. Since it is still an early stage project, it needs some tuning.

#+begin_src emacs-lisp
  (defun gatsby:journalctl--set-options (fn &rest args)
    (if args
        (apply fn args)
      (funcall fn "-x -n 1000")))

  (advice-add #'journalctl :around #'gatsby:journalctl--set-options)

  (setq journalctl-chunk-size 1000)

  (general-define-key :keymaps 'journalctl-mode-map :states 'normal
    "<" #'journalctl-previous-chunk
    ">" #'journalctl-next-chunk
    "q" #'kill-buffer-and-window)
#+end_src

** Man-Page Integration

I can also read man page from within ~emacs~ and even in ~eshell~. The builtin ~man~ mode offers good integration of reading man page.

#+begin_src emacs-lisp
  (use-package man
    :hook
    (man-mode . outline-minor-mode)

    :general
    (:keymaps 'Man-mode-map
     :states 'motion
     "zc" 'outline-hide-entry
     "zo" 'outline-show-entry)
#+end_src

My only issue of ~man~ mode is that it always opens a new window to display man page. Sometimes I want it to display using the existing window (e.g., when calling from ~eshell~). Therefore, I advice ~man~ to use the ~eshell~ window when called from ~eshell~.

#+begin_src emacs-lisp
  :config
  (defun gatsby:man--maybe-use-current-window (fn &rest args)
    "Use the current window to display the man buffer if in eshell mode. Respect `Man-notify-method' otherwise."
    (if (eq major-mode 'eshell-mode)
        (cl-letf (((symbol-function 'Man-notify-when-ready) 'switch-to-buffer))
          (apply fn args))
      (apply fn args)))

  (advice-add #'man :around #'gatsby:man--maybe-use-current-window)
#+end_src

This concludes the configuration for ~man~

#+begin_src emacs-lisp
  )
#+end_src

** LaTeX

First install ~textlive~ and the LSP ~digestif~ via ~home-manager~.

#+begin_src nix :noweb-ref home-manager
  home.packages = with pkgs; let

    digestif = pkgs.writeScriptBin "digestif" (builtins.readFile
      (builtins.fetchurl https://raw.githubusercontent.com/astoff/digestif/master/scripts/digestif));

    in [ texlive.combined.scheme-full digestif ];
#+end_src

AUCTeX is a gigantic package that aims at providing a tex IDE for ~emacs~. Although I already use a tex LSP ([[https://github.com/astoff/digestif][digestif]]) to handles label, autocomplete, etc. I still need AUCTeX to conveniently interact with tex command line utilities (mainly via ~TeX-command-sequence~ function)

#+begin_src emacs-lisp
  (use-package tex
    :straight auctex
#+end_src

AUCTeX tries to be smart and increase the font size of (sub)section titles, move up or down the super/subscripts, etc. I do not particularly such efforts:

#+begin_src emacs-lisp
  :custom-face
  (font-latex-italic-face ((t (:underline nil :inherit 'italic))))
  (font-latex-slide-title-face ((t (:height 1.0 :inherit 'font-lock-function-name-face))))
  (font-latex-sectioning-5-face ((t (:inherit 'default))))

  :custom
  (tex-fontify-script nil)
  (font-latex-fontify-script nil)
  (font-latex-fontify-sectioning 1.0))
#+end_src

Make sure that I load LSP and folding mode when I open an ~.tex~ file.

#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook #'eglot-ensure)
  (add-hook 'LaTeX-mode-hook #'company-mode)
#+end_src

Load ~TeX-PDF-mode~, which allows me to use ~PDFTeX~ as the main tex engine. Also make sure that I enable synctex search and shell-escape.

#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook #'TeX-PDF-mode)

  (setq TeX-parse-self t
        TeX-auto-save t
        TeX-source-correlate-mode t
        TeX-source-correlate-start-server t
        LaTeX-command "latex -shell-escape")

  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
#+end_src

Load ~outline-minor-mode~ to enable code folding.

#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook #'outline-minor-mode)

  (setq TeX-outline-extra '(("^\\(% \\)?\\\\begin{frame}" 3)))
#+end_src

Properly format tex file can be done as simple as running ~(indent-region (point-min) (point-max))~. But I need to turn off ~LaTeX-syntactic-comments~ and ~LaTeX-item-indent~, because they mess up the indent level for commented blocks and lists, respectively.

#+begin_src emacs-lisp
  (defun gatsby:latex--setup ()
    "Setup tab width and indentation rule for `LaTeX-mode'."
    (setq-local tab-width 2)
    (add-hook 'before-save-hook
              (lambda () (indent-region (point-min) (point-max))) nil t))

  (add-hook 'LaTeX-mode-hook #'gatsby:latex--setup)

  (setq LaTeX-syntactic-comments nil
        LaTeX-item-indent 0)
#+end_src

Furthermore, tex has many wired pairs (like $). It does not play well with ~electric-pair-mode~. AUCTeX has a builtin replacement of ~electric-pair-mode~ which, although usable, not "electric" enough for me. In particular, it misses a function that allows me to delete the closing pair after point with ~delete~ if there is nothing between the matching pairs. I add this function to it.

#+begin_src emacs-lisp
  (setq TeX-electric-math (cons "$" "$")
        LaTeX-electric-left-right-brace t
        LaTeX-syntactic-comments nil)

  (defun gatsby:latex-delete ()
    "Deleting the whole pair if in an empty pair, other wise delete the character on the left."
    (interactive)
    (let* ((old-point (point))
           (TeX-braces-association `(,@TeX-braces-association
                                     ("{" . "}")
                                     ("\\[" . "\\]")))
           (lbrace-pos (re-search-backward (rx (group-n 1 (= 1 (or "{" "[" "(")))
                                               (0+ space))
                                           nil t))
           lbrace)
      (if (not lbrace-pos)
          (call-interactively 'backward-delete-char-untabify)
        ;; deal with { and \{
        (setq lbrace (match-string 1))
        (when (TeX-escaped-p)
          (setq lbrace (concat TeX-esc lbrace))
          (backward-char))
        (let* ((rbrace (cdr (assoc lbrace TeX-braces-association)))
               (lmacro-regexp `(rx (= 1 ,TeX-esc (group-n 1 (or ,@(-map 'car LaTeX-left-right-macros-association)))) point))
               (lmacro-pos (re-search-backward (eval lmacro-regexp) nil t))
               (brace-start (point))
               lmacro rmacro)
          (if lmacro-pos
              (setq lmacro (match-string 1)
                    rmacro (cdr (assoc lmacro LaTeX-left-right-macros-association)))
            (setq rmacro ""
                  lmacro ""))
          (if (re-search-forward (eval `(rx point
                                            (opt ,TeX-esc)
                                            ,lmacro ,lbrace
                                            (0+ space)
                                            (opt ,TeX-esc)
                                            ,rmacro ,rbrace))
                                 nil t)
              (delete-region brace-start (point))
            (goto-char old-point)
            (call-interactively 'backward-delete-char-untabify))))))

  (general-define-key :keymaps 'LaTeX-mode-map :states 'insert
    "DEL" #'gatsby:latex-delete)
#+end_src

Finally, I use ~Zathura~ as pdf viewer.

#+begin_src nix :noweb-ref home-manager
  programs.zathura.enable = true;
#+end_src

#+begin_src emacs-lisp
  (setq TeX-view-program-selection '((output-pdf "Zathura")))
#+end_src

I add quick key bindings to complie tex file and do forward search (for tex sorce code to the pdf). Backwards search needs to be configured in ~Zathurarc~.

#+begin_src emacs-lisp
  (general-define-key :keymaps 'LaTeX-mode-map :states 'normal :prefix "SPC"
    "rr" (lambda ()
           (interactive)
           (TeX-command-sequence '("LaTeX" "BibTeX" "LaTeX" "LaTeX" "View") t))
    "ro" (lambda ()
           (interactive)
           (TeX-command-sequence "View" t)))
#+end_src

* Miscellaneous Tools
** Command Line Utilities

#+begin_src nix :noweb-ref home-manager
  home.packages = [ pkgs.tree pkgs.curl pkgs.htop ];
#+end_src

** Browser

#+begin_src nix :noweb-ref home-manager
  home.packages = [ pkgs.firefox ];

  home.sessionVariables = {
    MOZ_ENABLE_WAYLAND = 1;
  };
#+end_src

* TODO
** vterm: implement ~evil-surround~.
** langtool: write my own languagetool integration?
** jupyter: save repl log history when exit
** org-gcal: support invite people

check out https://developers.google.com/calendar/v3/reference/events/insert

** ein: freezes ~emacs~
** integrate pyright

I use [[https://github.com/microsoft/pyright][pyright by Microsoft]] as python LSP. The process of installing ~pyright~ is less than straightforward: ~pyright~ is distributed using ~node.js~, one of the build system ~nix~ does not have good support for. I use ~node2nix~ package to first build a pseudo-package that contains the nix expression for building ~pyright~, and then import that expression to build it.
