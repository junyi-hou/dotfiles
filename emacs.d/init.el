;; -*- lexical-binding: t; -*-

;; this file is auto-generated by main.org, do not modify!

(setq gc-cons-threshold most-positive-fixnum)

(setq message-log-max 10000)

(setq visible-bell t
      ring-bell-function 'ignore
      server-client-instructions nil)

(setq max-mini-window-height 1)

(if (boundp 'use-short-answers)
    (setq use-short-answers t)
  (defalias 'yes-or-no-p 'y-or-n-p))

(defun gatsby:core--unkillable-scratch ()
  (if (string= (buffer-name (current-buffer)) "*scratch*")
      (progn
        (delete-region (point-min) (point-max))
        (insert initial-scratch-message)
        nil)
    t))

(add-hook 'kill-buffer-query-functions #'gatsby:core--unkillable-scratch)

(defun gatsby:core--unkillable-message ()
  (if (string= (buffer-name (current-buffer)) "*Messages*")
      (progn
        (delete-window (get-buffer-window "*Messages*"))
        nil)
    t))

(add-hook 'kill-buffer-query-functions #'gatsby:core--unkillable-message)

(defun gatsby:core-refresh-message-buffer ()
  "Clear `*Message*' buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)))

(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(horizontal-scroll-bar-mode -1)
(blink-cursor-mode -1)

(defun gatsby:core--split-vertical (window)
  "Return t if should split WINDOW vertically, otherwise return nil."
  (let* ((h (window-total-height window))
         (w (window-total-width window))
         (ratio (/ (float h) w)))
    (cond
     ((< ratio 0.15) t)
     ((< (/ (float w) 2) 90) nil)
     (t t))))

(defun gatsby:core-split-window (&optional window)
  "Split WINDOW side-by-side, if WINDOW width < 90, split it top-and-down."
  (let ((window (or window (selected-window))))
    (if (gatsby:core--split-vertical window)
        (split-window-right)
      (split-window-below))))

(setq split-window-preferred-function 'gatsby:core-split-window)

(setq scroll-step 1)

(use-package dash)
(use-package f)
(use-package s)

(use-package gcmh :demand t)

(setq gcmh-high-cons-threshold 33554432)

(defun gatsby:core--reset-gc ()
  (setq gc-cons-threshold 25165824))

(add-hook 'after-init-hook #'gatsby:core--reset-gc)

(gcmh-mode 1)

(use-package general :demand t)

(defun gatsby:lisp--fix-indent ()
  (setq-local lisp-indent-function #'gatsby:lisp-indent-function))

(defun gatsby:lisp-indent-function (indent-point state)
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))

(add-hook 'emacs-lisp-mode-hook #'gatsby:lisp--fix-indent)

(use-package no-littering)

(setq auto-save-file-name-transforms  `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))
      backup-directory-alist `((".*" . ,(no-littering-expand-var-file-name "backup/")))
      custom-file (no-littering-expand-etc-file-name "custom.el"))

(load custom-file 'noerror)

(use-package saveplace :hook (after-init . save-place-mode))

(setq save-place-file (expand-file-name "save-place.el" no-littering-var-directory))

(use-package paren :hook (after-init . show-paren-mode))

(use-package subword :hook (after-init . global-subword-mode))

(use-package simple)

(add-hook 'after-init-hook #'global-visual-line-mode)

(use-package visual-fill-column)

(add-hook 'text-mode-hook #'visual-fill-column-mode)

(setq comment-auto-fill-only-comments t)
(add-hook 'prog-mode-hook #'auto-fill-mode)

(setq-default fill-column 80)
(setq fill-column 80)

(general-define-key :keymaps 'messages-buffer-mode-map :states 'normal
  "q" #'delete-window)

(general-define-key :keymaps 'messages-buffer-mode-map :states 'normal :prefix "C-c"
  "C-l" #'gatsby:core-refresh-message-buffer)

(use-package whitespace :hook (before-save . whitespace-cleanup))

(use-package autorevert :hook (after-init . global-auto-revert-mode))

(use-package alert :commands alert)

(setq alert-default-style (if (eq system-type 'gnu/linux) 'libnotify 'osx-notifier))

(setq alert-fade-time 60)

(use-package gruvbox-theme)
(setq custom-safe-themes t)
(load-theme 'gruvbox-dark-medium)

(setq-default fringe-indicator-alist
              '((continuation nil nil)
                (truncation nil nil)
                (overlay-arrow . nil)
                (up . nil)
                (down . nil)
                (top nil nil)
                (bottom nil nil nil nil)
                (top-bottom nil nil nil nil)
                (empty-line . nil)
                (unknown . nil)))

(defvar gatsby:right-mode-line '((:eval (gatsby:mode-line-vc-info)) mode-name))

(defun gatsby:format-right-mode-line ()
  (format-mode-line gatsby:right-mode-line))

(defun gatsby:mode-line-vc-info ()
  (if (and vc-mode buffer-file-name)
      (let* ((backend (vc-backend buffer-file-name))
             (repo (file-name-nondirectory (directory-file-name (vc-root-dir))))
             (state (vc-state buffer-file-name backend))
             (str (format "%s:%s "
                          repo
                          (substring vc-mode (+ (if (eq backend 'Hg) 2 3) 2)))))
        (propertize (if (> (length str) 25)
                        (concat
                         (substring str 0 (- 25 3))
                         "...")
                      str)
                    'mouse-face 'mode-line-highlight))
    ""))

(defun gatsby:mode-line-maybe-shorten-buffer-name ()
  "Shorten the buffer name if it is too long, otherwise return the original buffer name string."
  (if-let* ((buf-name (buffer-name))
            (str-len (length buf-name))
            (_ (> str-len 50)))
      (format "%s...%s"
              (substring buf-name 0 10)
              (substring buf-name (- str-len 37) str-len))
    buf-name))

(setq mode-line-format
      (list mode-line-mule-info
            mode-line-modified
            mode-line-remote " "
            "%[" '(:eval (gatsby:mode-line-maybe-shorten-buffer-name)) "%]"
            '(:eval (propertize
                     " " 'display
                     `((space :align-to (- (+ right right-fringe right-margin)
                                           ,(+ 3 (string-width (gatsby:format-right-mode-line))))))))
            '(:eval (gatsby:format-right-mode-line))))

(setq-default mode-line-format
              (list mode-line-mule-info
                    mode-line-modified
                    mode-line-remote " "
                    "%[" '(:eval (gatsby:mode-line-maybe-shorten-buffer-name)) "%]"
                    '(:eval (propertize
                             " " 'display
                             `((space :align-to (- (+ right right-fringe right-margin)
                                                   ,(+ 3 (string-width (gatsby:format-right-mode-line))))))))
                    '(:eval (gatsby:format-right-mode-line))))

(use-package ligature)

(ligature-set-ligatures
 'prog-mode
 '("!!" "!=" "!==" "!!!" "!≡" "!≡≡" "!>" "!=<" "#(" "#_" "#{" "#?"
   "#>" "##" "#_(" "%=" "%>" "%>%" "%<%" "&%" "&&" "&*" "&+" "&-" "&/"
   "&=" "&&&" "&>" "$>" "***" "*=" "*/" "*>" "++" "+++" "+=" "+>"
   "++=" "--" "-<" "-<<" "-=" "->" "->>" "---" "-->" "-+-" "-\\/" "-|>"
   "-<|" ".."  "..." "..<" ".>" ".~" ".=" "/*" "//" "/>" "/=" "/=="
   "///" "/**" ":::" "::" ":=" ":≡" ":>" ":=>" ":(" ":>:" ":<:" "<$>"
   "<*" "<*>" "<+>" "<-" "<<" "<<<" "<<=" "<=" "<=>" "<>" "<|>" "<<-"
   "<|" "<=<" "<~" "<~~" "<<~" "<$" "<+" "<!>" "<@>" "<#>" "<%>" "<^>"
   "<&>" "<?>" "<.>" "</>" "<\\>" "<\">" "<:>" "<~>" "<**>" "<<^" "<!"
   "<@" "<#" "<%" "<^" "<&" "<?" "<." "</" "<\\" "<\"" "<:" "<->"
   "<!--" "<--" "<~<" "<==>" "<|-" "<<|" "<-<" "<-->" "<<==" "<=="
   "=<<" "==" "===" "==>" "=>" "=~" "=>>" "=/=" "=~=" "==>>" "≡≡"
   "≡≡≡" "≡:≡" ">-" ">=" ">>" ">>-" ">>=" ">>>" ">=>" ">>^" ">>|"
   ">!=" ">->" "??" "?~" "?=" "?>" "???"  "?."  "^=" "^." "^?" "^.."
   "^<<" "^>>" "^>" "\\\\" "\\>" "\\/-" "@>" "|=" "||" "|>" "|||" "|+|"
   "|->" "|-->" "|=>" "|==>" "|>-" "|<<" "||>" "|>>" "|-" "||-" "~="
   "~>" "~~>" "~>>" "[[" "]]" "\">" "_|_"))

(add-hook 'after-init-hook #'global-ligature-mode)

(defconst gatsby:base-font-size 135 "The base level of font size.")

(set-face-attribute
 'default nil
 :family "Monospace"
 :width 'normal
 :weight 'Regular)

(defun gatsby:theme-fontsize-up (&optional size)
  "Increase the font size in the current frame by SIZE.  If SIZE is nil, default to 5."
  (interactive)
  (let* ((current-size (plist-get (custom-face-attributes-get 'default nil) :height))
         (new-size (+ (or size 5) current-size)))
    (set-face-attribute
     'default (selected-frame)
     :height new-size)))

(defun gatsby:theme-fontsize-down (&optional size)
  "Decrease the font size in the current frame by SIZE.  If SIZE is nil, default to 5."
  (interactive)
  (let* ((current-size (plist-get (custom-face-attributes-get 'default nil) :height))
         (new-size (- current-size (or size 5))))
    (set-face-attribute
     'default (selected-frame)
     :height new-size)))

(defun gatsby:theme--determine-font-size (frame)
  "Determine the fontsize by looking at `x-display-pixel-height'."
  (set-face-attribute
   'default frame
   :height (round (* gatsby:base-font-size (/ (x-display-pixel-height) 1080.0)))))

(add-to-list 'after-make-frame-functions #'gatsby:theme--determine-font-size)

(general-define-key :keymaps '(motion normal visual emacs insert)
  "C-+" 'gatsby:theme-fontsize-up
  "C--" 'gatsby:theme-fontsize-down)

(set-face-attribute 'minibuffer-prompt nil :weight 'normal)

(setq-default indent-tabs-mode nil
              tab-width 4
              electric-indent-inhibit t)

(setq backward-delete-char-untabify-method 'all)

(use-package highlight-indent-guides
  :hook
  (prog-mode . highlight-indent-guides-mode)
  :custom
  (highlight-indent-guides-method 'bitmap)
  (highlight-indent-guides-responsive nil))

(use-package beacon :hook (after-init . beacon-mode))

(setq beacon-blink-when-window-scrolls nil
      beacon-can-go-backwards t
      beacon-size 15)

(use-package hl-todo :hook (after-init . global-hl-todo-mode))

(setq hl-todo-keyword-faces '(("TODO" . "#FB4934")
                              ("FIXME"  . "#FB4934")
                              ("NOTE"   . "#FABD2F")
                              ("HACK"   . "#FABD2F")))

(setq hl-todo-exclude-modes nil)

(use-package display-line-numbers :hook (prog-mode . display-line-numbers-mode))

(defun gatsby:theme--set-line-number-background (&rest _)
  (set-face-attribute 'line-number nil :background (face-background 'default)))

(gatsby:theme--set-line-number-background)
(advice-add #'load-theme :after #'gatsby:theme--set-line-number-background)

(setq display-line-numbers-width-start t)

(use-package eldoc-box
  :hook ((text-mode prog-mode) . eldoc-box-hover-mode))

(defun gatsby:eldoc-box--position (width height)
  "Display `eldoc-box' in the bottom right corner of the `selected-window'."
  (let* ((edge (window-pixel-edges))
         (modeline-height (- (nth 3 (window-pixel-edges))
                             (nth 3 (window-inside-pixel-edges))))
         (y (- (nth 3 edge) 5 height modeline-height))
         (x (- (nth 2 edge) 5 width)))
    (cons x y)))
(setq eldoc-box-position-function #'gatsby:eldoc-box--position)

(setq eldoc-box-cleanup-interval 0.5
      eldoc-box-clear-with-C-g t)

(setq eldoc-box-max-pixel-height 400)

(defun gatsby:eldoc-box--set-font-size (&rest _)
  (set-face-attribute
   'default eldoc-box--frame
   :height (face-attribute 'default :height (frame-parameter eldoc-box--frame 'parent-frame))))

(add-hook 'eldoc-box-frame-hook #'gatsby:eldoc-box--set-font-size)

(use-package evil
  :custom (evil-undo-system 'undo-redo)
  :init (evil-mode 1)
  :general
  (:keymaps '(motion normal visual)
   "j" 'evil-next-visual-line
   "k" 'evil-previous-visual-line

   "H" 'evil-first-non-blank-of-visual-line
   "L" 'evil-end-of-visual-line

   "SPC" nil)

  (:keymaps '(motion normal visual emacs insert)
   "C-h" 'windmove-left
   "C-j" 'windmove-down
   "C-k" 'windmove-up
   "C-l" 'windmove-right

   "C-u" 'evil-scroll-up
   "C-d" 'evil-scroll-down

   "C-e" (lambda () (interactive) (evil-scroll-line-down 5))
   "C-y" (lambda () (interactive) (evil-scroll-line-up 5)))

  (:keymaps '(motion normal visual)
   :prefix "SPC"

   ;; execute
   "ee" 'execute-extended-command
   "el" 'eval-last-sexp
   "eL" (lambda () (interactive)
          (eval-buffer)
          (message "buffer %s evaluated!" (buffer-name)))

   ;; basic function
   "w" 'evil-write
   "k" 'delete-window
   "K" 'delete-frame

   ;; split
   "\\"  (lambda () (interactive) (evil-window-vsplit) (evil-window-right 1))
   "-"   (lambda () (interactive) (evil-window-split) (evil-window-down 1)))

  (:keymaps 'visual
   :prefix "SPC"
   "a" 'align-regexp)

  (:keymaps '(normal motion)
   "<tab>" 'evil-jump-item))

(use-package evil-surround :hook (after-init . global-evil-surround-mode))

(use-package evil-nerd-commenter
  :after evil
  :commands evilnc-comment-or-uncomment-lines
  :general
  (:keymaps '(normal visual)
   :prefix "SPC"
   "t" 'evilnc-comment-or-uncomment-lines))

(use-package expand-region

  :general
  (:keymaps 'visual
   "v" 'er/expand-region
   "V" 'er/contract-region))

(use-package elec-pair :hook (after-init . electric-pair-mode))

(setq-default mode-line-format `((:evil evil-mode-line-tag) ,@mode-line-format))

(--each (buffer-list)
  (with-current-buffer it
    (setq mode-line-format `((:evil evil-mode-line-tag) ,@mode-line-format))))

(evil-define-motion gatsby:evil-next-three-lines ()
  (interactive)
  (evil-next-visual-line 3))

(evil-define-motion gatsby:evil-previous-three-lines ()
  (interactive)
  (evil-previous-visual-line 3))

(general-define-key :keymaps '(motion normal visual)
  "J" 'gatsby:evil-next-three-lines
  "K" 'gatsby:evil-previous-three-lines)

(defun gatsby:evil-visual-tab ()
  "Indent region if in visual-line-mode, otherwise select contains inside a pair of tags via `evil-jump-item'"
  (interactive)
  (if (eq evil-visual-selection 'line)
      (indent-region (region-beginning) (region-end))
    (evil-jump-item)))

(general-define-key :keymaps 'visual
  "<tab>" 'gatsby:evil-visual-tab)

(defun gatsby:evil-normal-state-if-not-motion ()
    "Switch to evil normal state if the current state is not motion state."
    (interactive)
    (unless (or (evil-motion-state-p)
                (evil-normal-state-p)
                (minibufferp (current-buffer))
                (memq major-mode evil-emacs-state-modes))
      (evil-normal-state)))

(global-set-key (kbd "<escape>") #'gatsby:evil-normal-state-if-not-motion)

(global-set-key (kbd "M-u") #'universal-argument)

(defun gatsby:evil-better-newline (newline-fun &rest args)
    "When calling `newline', check whether current line is a comment line (i.e., start with 0 or more spaces followed by `comment-start-skip')  If so, automatically indent and insert `comment-start-skip' after calling `newline' for the first call.  Delete the auto-inserted comment for the second call.  Otherwise call `newline' as default."
    (let* (;; line - the current line as string
           (line (buffer-substring-no-properties
                  (line-beginning-position)
                  (line-end-position)))
           ;; only-comment - t if the current line starts with comment
           (only-comment (and comment-start-skip
                              (string-match (concat "\\(^[\t ]*\\)\\(" comment-start-skip "\\)") line)))
           ;; newline-string - string insert into newline
           (newline-string (if only-comment
                               (match-string 2 line)
                             "")))
      (if (and only-comment
               (eq last-command 'newline))
          (progn
            (delete-region (line-beginning-position) (point))
            (insert (match-string 1 line)))
        (apply newline-fun args)
        (insert newline-string))))

(advice-add 'newline :around #'gatsby:evil-better-newline)

(defun gatsby:evil--recenter-after-goto-point-max (count)
  "Thin wrapper around `evil-scroll-line-to-center' so center the end-of-buffer after a G motion."
  (unless count
    (recenter nil)))

(advice-add #'evil-goto-line :after #'gatsby:evil--recenter-after-goto-point-max)

(defun gatsby:kill-buffer-and-or-window ()
  "Delete window and kill buffer if `buffer-file-name' is nil."
  (interactive)
  (if (buffer-file-name)
      (kill-buffer)
    (kill-buffer-and-window)))

(general-define-key :keymaps '(normal motion visual) :prefix "SPC"
  "q" #'gatsby:kill-buffer-and-or-window)

(use-package selectrum
  :defines (selectrum-minibuffer-bindings selectrum-should-sort)
  :custom (selectrum-fix-vertical-window-height t)
  :init (selectrum-mode 1)
  :general
  (:keymaps '(motion normal visual)
   :prefix "SPC"
   "oo" #'find-file
   "om" (lambda () (interactive)
          (switch-to-buffer-other-window (get-buffer-create "*Messages*"))))

  ;; evil like scrolling
  (:keymaps 'selectrum-minibuffer-map
   "C-d" #'selectrum-next-page
   "C-u" #'selectrum-previous-page
   "C-e" #'selectrum-next-page
   "C-y" #'selectrum-previous-page))

(defun gatsby:selectrum--remove-base (dir)
  "Insert the string of trimming the base of DIR into the minibuffer."
  (delete-minibuffer-contents)
  (insert (string-trim-right (if (string= dir "~/") (expand-file-name "~/") dir) "[^/]+/?")))

(defun gatsby:selectrum-better-backspace ()
  "If `point' is at \"/\", delete till the last \"/\"."
  (interactive)
  (if (thing-at-point-looking-at "/")
      (let ((dir (minibuffer-contents-no-properties)))
        (gatsby:selectrum--remove-base dir))
    (call-interactively #'backward-delete-char)))

(general-define-key :keymaps #'selectrum-minibuffer-map
  "<backspace>" #'gatsby:selectrum-better-backspace)

(defun gatsby:selectrum-next-candidate-cycle ()
  "Move selection to next candidate, if at the end, go to the top."
  (interactive)
  (when selectrum--current-candidate-index
    (setq selectrum--current-candidate-index
          (if (= selectrum--current-candidate-index (1- (length selectrum--refined-candidates)))
              (if (selectrum--match-strictly-required-p) 0 -1)
            (1+ selectrum--current-candidate-index)))))

(defun gatsby:selectrum-previous-candidate-cycle ()
  "Move selection to previous candidate, if at the beginning, go to the end."
  (interactive)
  (when selectrum--current-candidate-index
    (setq selectrum--current-candidate-index
          (if (= selectrum--current-candidate-index (if (selectrum--match-strictly-required-p) 0 -1))
              (1- (length selectrum--refined-candidates))
            (1- selectrum--current-candidate-index)))))

(general-define-key :keymaps #'selectrum-minibuffer-map
 "M-j" #'gatsby:selectrum-next-candidate-cycle
 "M-k" #'gatsby:selectrum-previous-candidate-cycle)

(defun gatsby:selectrum-select-current-candidate-if-not-dir ()
  "Select the current candidate. If, however, the current selection is a directory, enter the directory instead of opening it using `dired'."
  (interactive)
  (let*  ((input (minibuffer-contents-no-properties))
          (index selectrum--current-candidate-index)
          (candidate (selectrum--get-candidate index))
          (dir (if (directory-name-p input) input (file-name-directory input))))
    (if (and dir (directory-name-p candidate))
        (progn
          (delete-minibuffer-contents)
          (insert (format "%s%s" dir candidate)))
      (selectrum-select-current-candidate))))

(defun gatsby:selectrum-unified-tab ()
  "<tab> does the following things
1. if there is a common part among candidates, complete the common part;
2. if there is only one candidate, select the candidate
3. if the last command is `gatsby:selectrum-unified-tab', or `selectrum--current-candidate-index' is not 0/-1 (the top candidate), then select the current candidate"
  (interactive)
  (when selectrum--current-candidate-index
    (let* ((common (try-completion "" selectrum--refined-candidates)))
      (cond
       ;; case 3
       ((or (eq last-command this-command)
            (not (memq selectrum--current-candidate-index '(0 -1))))
        (gatsby:selectrum-select-current-candidate-if-not-dir))
       ;; case 2
       ((= 1 (length selectrum--refined-candidates))
        (gatsby:selectrum-select-current-candidate-if-not-dir))
       ;; case 1
       ((not (string= common ""))
        (let*  ((input (minibuffer-contents-no-properties))
                (dir (if (directory-name-p input) input (file-name-directory input))))
          (if dir
              (progn
                (delete-minibuffer-contents)
                (insert (format "%s%s" dir common)))
            (insert common))))))))

(general-define-key :keymaps 'selectrum-minibuffer-map
  "<tab>" #'gatsby:selectrum-unified-tab)

(general-define-key :keymaps '(motion normal visual emacs insert)
  "<C-return>" #'selectrum-repeat)

(defcustom selectrum-become-command-context-list
  '((helpful-variable helpful-function)
    (consult-outline consult-line consult-flymake)
    (find-file switch-to-buffer project-plus-switch-project
               project-plus-find-file consult-buffer))
  "The selectrum-become context list.

    Each element is a list of selectrum commands that should be considered
    within the same group and can become each other. See the default value
    for example."
  :type '(list '(list command))
  :group 'selectrum)

(defun selectrum-become ()
  (interactive)
  (let ((cmd selectrum--last-command)
        (input selectrum--previous-input-string)
        (enable-recursive-minibuffers t))
    (let ((new-cmd (completing-read "Select different command: "
                                    (->> selectrum-become-command-context-list
                                      (--first (memq cmd it))
                                      (--map (symbol-name it))
                                      (--filter (not (eq (symbol-name cmd) it)))))))
      (run-at-time 0 nil
                   (lambda ()
                     (let ((selectrum--repeat t)
                           (selectrum--previous-input-string input))
                       (call-interactively (intern new-cmd))
                       (setq selectrum--current-candidate-index 0
                             selectrum--last-command (intern new-cmd)))))
      (abort-recursive-edit))))

(general-define-key :keymaps #'selectrum-minibuffer-map
  "<C-return>" #'selectrum-become)

(use-package prescient
  :config
  (setq prescient-save-file (concat no-littering-var-directory "prescient-save.el"))
  (prescient-persist-mode 1))

(use-package selectrum-prescient :config (selectrum-prescient-mode 1))

(use-package consult
  :commands
  (consult--read)
  :custom
  (consult-preview-key nil)
  :general
  (:keymaps '(motion normal visual)
   :prefix "SPC"
   "ob" #'consult-buffer))

(defun gatsby:consult-outline (&optional initial)
  "Override `consult-outline' to enable optional initial INPUT."
  (interactive)
  (let ((cands (consult--with-increased-gc (consult--outline-candidates))))
    (consult--read
     cands
     :prompt "Go to heading: "
     :annotate (consult--line-prefix)
     :category 'consult-location
     :sort nil
     :require-match t
     :add-history (thing-at-point 'symbol)
     :history '(:input consult--line-history)
     :lookup #'consult--line-match
     :initial initial
     :state (consult--jump-state))))

(advice-add #'consult-outline :override #'gatsby:consult-outline)

(defun gatsby:consult-search-visual-line (beg end)
  (interactive "r")
  (evil-exit-visual-state)
  (consult-line (buffer-substring-no-properties beg end)))

(defun gatsby:consult-search-visual-outline (beg end)
  (interactive "r")
  (evil-exit-visual-state)
  (consult-outline (buffer-substring-no-properties beg end)))

(general-define-key :keymaps '(motion normal)
  "*" #'consult-line
  "#" #'consult-outline)

(general-define-key :keymaps 'visual
  "*" #'gatsby:consult-search-visual-line
  "#" #'gatsby:consult-search-visual-outline)

(setq evil-search-module 'isearch)

(defun gatsby:consult-line-from-evil (arg)
  "Take current search string and run `consult-line' on it.
If ARG is non-nil, run `consult-outline' instead."
  (interactive "P")
  (let ((str isearch-string)
        (enable-recursive-minibuffers t)
        (fn (if arg #'consult-outline #'consult-line)))
    (run-at-time 0 nil fn str)
    (abort-recursive-edit)))

(general-define-key :keymaps 'isearch-mode-map
  "<C-return>" #'gatsby:consult-line-from-evil)

(use-package consult-selectrum
  :after (consult selectrum))

(use-package marginalia)
(marginalia-mode 1)

(use-package eshell)

(setenv "PAGER" "cat")

(setenv "TERM" "xterm-256color")

(use-package xterm-color)

(add-hook 'eshell-mode-hook #'company-mode)

(defun gatsby:eshell--setup ()
  "Further setup eshell mode."
  (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
  (setq eshell-hist-ignoredups t)
  (setq eshell-history-size 10000)
  (require 'esh-mode)
  (add-hook 'eshell-before-prompt-hook (lambda () (setq xterm-color-preserve-properties t)))
  (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
  (setq eshell-output-filter-functions
        (remove 'eshell-handle-ansi-color eshell-output-filter-functions))
  (setq eshell-buffer-maximum-lines 12000)
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)
  (setq eshell-list-files-after-cd t)
  (setq eshell-error-if-no-glob t
        eshell-glob-case-insensitive t)
  (setq eshell-destroy-buffer-when-process-dies t)
  (setq eshell-scroll-to-bottom-on-input 'all)
  )

(add-hook 'eshell-first-time-mode-hook #'gatsby:eshell--setup)

(add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

(setq eshell-hist-ignoredups t)

(setq eshell-history-size 10000)

(require 'esh-mode)
(add-hook 'eshell-before-prompt-hook (lambda () (setq xterm-color-preserve-properties t)))
(add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
(setq eshell-output-filter-functions
      (remove 'eshell-handle-ansi-color eshell-output-filter-functions))

(setq eshell-buffer-maximum-lines 12000)
(add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

(setq eshell-list-files-after-cd t)

(setq eshell-error-if-no-glob t
      eshell-glob-case-insensitive t)

(setq eshell-destroy-buffer-when-process-dies t)

(setq eshell-scroll-to-bottom-on-input 'all)

(use-package em-term :after eshell)

(defun gatsby:eshell-history ()
  "Search history"
  (interactive)
  (let* ((selectrum-should-sort nil)
         (eshell-bol (save-excursion (eshell-bol) (point)))
         (command (completing-read
                   "History: "
                   (if eshell-history-ring
                       (-distinct (ring-elements eshell-history-ring))
                     '())
                   nil nil
                   (buffer-substring eshell-bol (point)))))
    (delete-region eshell-bol (point))
    (insert command)))

(defun gatsby:eshell-goto-last-prompt ()
  "Goto current prompt and continue editting."
  (interactive)
  (goto-char (point-max))
  (evil-insert 1))

(defun gatsby:eshell--change-buffer-title ()
  "Change the title of eshell buffer to reflect $pwd."
  (rename-buffer (format "%s: %s" eshell-buffer-name (directory-file-name default-directory)) 'unique))

(add-hook 'eshell-mode-hook #'gatsby:eshell--change-buffer-title)
(add-hook 'eshell-directory-change-hook #'gatsby:eshell--change-buffer-title)

(defun gatsby:eshell-clear-buffer ()
  "Eshell version of `cls'."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)
    (eshell-send-input)))

(defun gatsby:eshell-toggle-sudo ()
  "Add/Remove sudo in the begining of command line."
  (interactive)
  (let ((pos (point))
        (commands (buffer-substring-no-properties
                   (eshell-bol) (point-max))))
    (if (string-match-p "^sudo " commands)
        (progn
          (eshell-bol)
          (while (re-search-forward "sudo " nil t)
            (replace-match "" t nil))
          (setq pos (- pos 4)))
      (eshell-bol)
      (insert "sudo ")
      (setq pos (+ pos 6)))
    (goto-char pos)
    (evil-insert-state)))

(evil-define-operator eshell/evil-change (beg end type register yank-handler delete-func)
  "Like `evil-change' but will not delete/copy the prompt."
  (interactive "<R><x><y>")
  (save-restriction
    (narrow-to-region eshell-last-output-end (point-max))
    (evil-change (max beg (point-min))
                 (if (eq type 'line) (point-max) (min (or end (point-max)) (point-max)))
                 type register yank-handler delete-func)))

(evil-define-operator eshell/evil-change-line (beg end type register yank-handler)
  "Change to end of line."
  :motion evil-end-of-line
  (interactive "<R><x><y>")
  (eshell/evil-change beg end type register yank-handler #'evil-delete-line))

(evil-define-operator eshell/evil-delete (beg end type register yank-handler)
  "Like `evil-delete' but will not delete/copy the prompt."
  (interactive "<R><x><y>")
  (save-restriction
    (narrow-to-region eshell-last-output-end (point-max))
    (evil-delete (if beg (max beg (point-min)) (point-min))
                 (if (eq type 'line) (point-max) (min (or end (point-max)) (point-max)))
                 type register yank-handler)))

(evil-define-operator eshell/evil-delete-line (_beg end type register yank-handler)
  "Change to end of line."
  :motion nil
  :keep-visual t
  (interactive "<R><x>")
  (eshell/evil-delete (point) end type register yank-handler))

(defun gatsby:eshell--setkey ()
  "Customize key in eshell-mode."
  (general-define-key
   :states '(normal visual motion)
   :keymaps 'eshell-mode-map
   "A" 'gatsby:eshell-goto-last-prompt
   "H" 'eshell-bol
   "S" 'gatsby:eshell-toggle-sudo
   "c" 'eshell/evil-change
   "C" 'eshell/evil-change-line
   "d" 'eshell/evil-delete
   "D" 'eshell/evil-delete-line
   "<" 'eshell-previous-prompt
   ">" 'eshell-next-prompt)

  (general-define-key
   :states 'insert
   :keymaps 'eshell-mode-map
   "C-r" 'gatsby:eshell-history)

  (general-define-key
   :states '(normal visual motion emacs insert)
   :keymaps 'eshell-mode-map
   :prefix "C-c"
   "C-l" 'gatsby:eshell-clear-buffer)

  (general-define-key
   :states '(normal visual motion)
   :keymaps 'eshell-mode-map
   :prefix "SPC"
   "q" 'kill-buffer-and-window))

(add-hook 'eshell-first-time-mode-hook #'gatsby:eshell--setkey)

(defun eshell/x (file &rest args)
  "Unpack FILE with ARGS using default command."
  (let* ((command
          (-some (lambda (x)
                   (if (string-match-p (car x) file)
                       (cadr x)))
                 '((".*\.tar.bz2" "tar xjf")
                   (".*\.tar.gz" "tar xzf")
                   (".*\.bz2" "bunzip2")
                   (".*\.rar" "unrar x")
                   (".*\.gz" "gunzip")
                   (".*\.tar" "tar xf")
                   (".*\.tbz2" "tar xjf")
                   (".*\.tgz" "tar xzf")
                   (".*\.zip" "unzip")
                   (".*\.Z" "uncompress")
                   (".*" "echo 'Could not unpack the file:'"))))
         (unpack-command
          (concat command " " file " " (mapconcat 'identity args " "))))
    (eshell/printnl "Unpack command: " unpack-command)
    (eshell-command-result unpack-command)))

(defun eshell/mkcd (dir &rest _)
  "Run \"mkdir dir\" then \"cd dir\""
  (interactive)
  (eshell/mkdir dir)
  (eshell/cd dir))

(defun eshell/ff (&rest files)
  "Open FILES in emacs."
  (setq files (flatten-tree files))
  (mapc 'find-file files))

(defun eshell/FF (&rest files)
  "Open FILES in a new window in emacs."
  (setq files (flatten-tree files))
  (gatsby:core-split-window)
  (other-window 1)
  (mapc 'find-file files))

(defun gatsby:eshell-open-here (&optional arg)
  "Open a new shell in the current directory.
If the prefix argument (ARG) is not null, go to the home directory.
If there is already a eshell buffer open for that directory, switch to that buffer."
  (interactive "P")
  (let* ((dir (if arg (expand-file-name "~/") default-directory))
         ;; check whether there exists a eshell buffer for DIR
         (exists (--first (with-current-buffer it
                            (and (string-equal major-mode "eshell-mode")
                                 (f-equal-p dir default-directory)))
                          (buffer-list)))
         ;; check if the matched eshell buffer is visible
         (visible (when exists (get-buffer-window exists))))
    (if visible
        (select-window visible)
      (split-window-below (- (/ (window-total-height) 3)))
      (other-window 1)
      (if exists
          (switch-to-buffer exists)
        (let ((default-directory dir))
          (eshell 'Z))))
    (goto-char (point-max))
    (evil-insert-state)))

(general-define-key :keymaps '(motion normal visual) :prefix "SPC"
  "os" 'gatsby:eshell-open-here)

(use-package tramp)
(use-package em-tramp)

(setq tramp-histfile-override "/dev/null")
(add-to-list 'tramp-remote-path 'tramp-own-remote-path)

(defun gatsby:eshell-sudo (&rest commands)
  "Use `tramp' run COMMAND in /sudo::`default-directory'.  Does not have any flags so won't get error if -i or --user is given."
  (setq commands (flatten-tree commands))
  (if (not commands)
      (gatsby:eshell-su)
    (throw 'eshell-external
           (let ((user "root")
                 (host (or (file-remote-p default-directory 'host) "localhost"))
                 (dir (file-local-name (expand-file-name default-directory)))
                 (prefix (file-remote-p default-directory))
                 (sudo? (string-equal "sudo" (file-remote-p default-directory 'method))))
             (cond (sudo?
                    (eshell-named-command (car commands) (cdr commands)))
                   (prefix
                    (let ((default-directory (format "%s|sudo:%s@%s:%s"
                                                     (substring prefix 0 -1) user host dir)))
                      (eshell-named-command (car commands) (cdr commands))))
                   (t
                    (let ((default-directory (format "/sudo:%s@%s:%s" user host dir)))
                      (eshell-named-command (car commands) (cdr commands)))))))))

(advice-add #'eshell/sudo :override #'gatsby:eshell-sudo)

;; override eshell/su
(defun gatsby:eshell-su (&rest _)
  "toggle between `default-directory' and /sudo::`default-directory'."
  (let ((user "root")
        (host (or (file-remote-p default-directory 'host) "localhost"))
        (dir (file-local-name (expand-file-name default-directory)))
        (prefix (file-remote-p default-directory))
        (sudo? (string-equal "sudo" (file-remote-p default-directory 'method))))
    (if sudo?
        ;; in sudo mode, go back to non-sudo
        (let ((new-prefix (replace-regexp-in-string
                           (format "[|/]sudo:root@%s" host) ""
                           prefix)))
          (eshell/cd (if (string= ":" new-prefix) dir (format "%s%s" new-prefix dir))))
      ;; in non-sudo mode, go to sudo
      (if prefix
          (eshell/cd
           (format "%s|sudo:%s@%s:%s" (substring prefix 0 -1) user host dir))
        (eshell/cd (format "/sudo:%s@%s:%s" user host dir))))))

(advice-add #'eshell/su :override #'gatsby:eshell-su)

(defun gatsby:eshell-cd (cd &rest args)
  "Make `eshell/cd' tramp-aware."
  (let* ((host (file-remote-p default-directory))
         (home (format "%s/home/%s" host (file-remote-p default-directory 'user))))
    (if (and (not args)
             host)
        (if (file-exists-p home)
            (funcall cd home)
          (funcall cd (format "%s/" host)))
      (funcall cd args))))

(advice-add #'eshell/cd :around #'gatsby:eshell-cd)

(with-eval-after-load 'envrc
  (defun gatsby:envrc--update-after-cd (&rest _)
    "Update the current direnv environment after `eshell/cd'."
    (let ((buf (current-buffer)))
      (if (f-traverse-upwards (lambda (dir)
                                (f-exists-p (format "%s/.envrc" dir))))
          (envrc--update)
        (envrc--clear buf)
        (setq envrc--status 'none))))

  (advice-add #'eshell/cd :after #'gatsby:envrc--update-after-cd))

(use-package org
  :config
  (setq org-startup-indented t
        org-startup-with-latex-preview t
        org-preview-latex-image-directory ".org-latex-imgcache/")
  (setq org-use-sub-superscripts nil)
  (setq org-indent-mode-turns-on-hiding-stars nil
        org-hide-leading-stars nil)
  (set-face-extend 'org-block t)
  (set-face-extend 'org-block-begin-line t)
  (set-face-extend 'org-block-end-line t))

(defun gatsby:org--enable-extra-pairs ()
  (make-variable-buffer-local 'electric-pair-pairs)
  (add-to-list 'electric-pair-pairs '(?\~ . ?\~)))

(add-hook 'org-mode-hook #'gatsby:org--enable-extra-pairs)

(defun gatsby:org--fix-indent () (setq tab-width 2))
(add-hook 'org-mode-hook #'gatsby:org--fix-indent)

(defun gatsby:org--indent-mode-with-correct-wrap (level indentation &optional heading)
  (let* ((line (aref (pcase heading
                           (`nil org-indent--text-line-prefixes)
                           (`inlinetask org-indent--inlinetask-line-prefixes)
                           (_ org-indent--heading-line-prefixes))
                         level))
           (wrap
            (concat line
                  (org-add-props
                        (if heading (concat (make-string level ?*) " ")
                              (make-string indentation ?\s))
                        nil 'face (if (eq (car (org-element-at-point)) 'src-block)
                                    'org-block
                                  'org-indent)))))
    ;; Add properties down to the next line to indent empty lines.
    (add-text-properties (line-beginning-position) (line-beginning-position 2)
                               `(line-prefix ,line wrap-prefix ,wrap)))
  (forward-line))

(advice-add #'org-indent-set-line-properties :override #'gatsby:org--indent-mode-with-correct-wrap)

(defun gatsby:org--complete-keywords ()
  "Allow company to complete org keywords after ^#+"
  (add-hook 'completion-at-point-functions
            'pcomplete-completions-at-point nil t))

(add-hook 'org-mode-hook #'company-mode)
(add-hook 'org-mode-hook #'gatsby:org--complete-keywords)

(defcustom gatsby:org-foldable'(example-block export-block src-block table)
  "A list of org-element that are consider foldable, and hence can be folded/expanded by `gatsby:org-hide-block' and `gatsby:org-show-block'."
  :type '(list symbol)
  :group 'org)

(defun gatsby:org-hide-block ()
  "Hide current block, if it is inside element defined in `gatsby:org-foldable', first try to fold the element.  Fall back to `evil-close-fold'."
  (interactive)
  (let ((element (org-element-at-point)))
    (if (memq (car element) gatsby:org-foldable)
        (progn
          (goto-char (plist-get (cadr element) :begin))
          (org-hide-block-toggle t))
      (evil-close-fold))))

(defun gatsby:org-show-block ()
  "Show current block."
  (interactive)
  (condition-case _
      (org-hide-block-toggle 'off)
    (error (evil-open-fold))))

(general-define-key :keymaps 'org-mode-map :states '(normal visual motion)
  "zo" #'gatsby:org-show-block
  "zc" #'gatsby:org-hide-block)

(setq org-cycle-emulate-tab nil)

(general-define-key :keymaps 'org-mode-map :states '(normal visual motion) :prefix "SPC"
  "rf" #'org-footnote)

(general-define-key :keymaps 'org-mode-map :states '(normal visual motion)
  "<" #'org-previous-visible-heading
  ">" #'org-next-visible-heading)

(general-define-key :keymaps 'org-mode-map :states 'normal
  "RET" #'org-open-at-point)

(use-package org-appear
  :hook (org-mode . org-appear-mode))

(setq org-appear-autolinks t)

(setq org-export-backends '(ascii html latex md odt)
      org-export-coding-system 'utf-8
      org-export-with-sub-superscripts t
      org-export-with-toc nil
      org-latex-packages-alist '(("" "setspace")
                                 ;; https://github.com/gpoore/minted/issues/92
                                 ("cache=false" "minted")
                                 ("" "pdflscape")
                                 ("" "multirow")
                                 ("" "multicol")
                                 ("" "booktabs")
                                 ("" "amsthm")
                                 ("" "amssymb")
                                 ("" "listingsutf8")
                                 ("top=1in, bottom=1in, left=1in, right=1in" "geometry")
                                 ("" "natbib"))
      org-latex-listings 'minted
      org-highlight-latex-and-related '(latex entities script)
      org-latex-pdf-process
      '("pdflatex -shell-escape -output-directory %o %f"
        "biber %b"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(general-define-key :keymaps 'org-mode-map :states '(normal visual motion) :prefix "SPC"
  "re" #'org-export-dispatch)

(setq org-src-window-setup 'plain)

(setq org-confirm-babel-evaluate nil)

(setq org-src-ask-before-returning-to-edit-buffer nil)

(defun gatsby:org--ensure-normal-state (&rest _)
  (evil-normal-state))

(advice-add #'org-edit-src-code :before #'gatsby:org--ensure-normal-state)

(setq org-babel-load-languages '((emacs-lisp . t)
                                 (shell . t)))

(defconst gatsby:org-babel-default-interpreters '("emacs-lisp" "shell")
  "List of interpreters that should be available at all environments.")

(defvar gatsby:org-babel-available-interpreters '("emacs-lisp" "shell")
  "List of interpreters available in the current environment.")

(make-variable-buffer-local 'gatsby:org-babel-available-interpreters)

(defvar gatsby:org-babel-hook nil
  "Hook run with `org-mode-hook', but specific to my babel setting.")

(defun gatsby:org-babel-run-hook ()
  (run-hooks 'gatsby:org-babel-hook))

(add-hook 'org-mode-hook #'gatsby:org-babel-run-hook)

(general-define-key :keymaps 'org-mode-map :states '(normal visual motion) :prefix "SPC"
  "rr" #'org-ctrl-c-ctrl-c)

(add-hook 'org-babel-after-execute-hook #'org-display-inline-images)

(defun gatsby:org-remove-all-results ()
  "Remove results from every code block in buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward org-babel-src-block-regexp nil t)
      (org-babel-remove-result))))

(general-define-key :keymaps 'org-mode-map :states '(normal visual motion) :prefix "SPC"
  "rc" #'gatsby:org-remove-all-results)

(use-package ob-async)

(use-package flymake :hook (prog-mode . flymake-mode))

(setq flymake-start-on-newline nil)

(defun gatsby:flymake-enter-normal-state-check ()
  "Check for syntax errors when entering normal state"
  (when (bound-and-true-p evil-mode)
    (flymake-log :debug "starting syntax check as entering normal state")
    (flymake-start t)))

(add-hook 'evil-normal-state-entry-hook #'gatsby:flymake-enter-normal-state-check)

(define-fringe-bitmap 'gatsby:double-error-bitmap
  [#b11011000
   #b01101100
   #b00110110
   #b00011011
   #b00110110
   #b01101100
   #b11011000])

(setq flymake-note-bitmap '(gatsby:double-error-bitmap default)
      flymake-warning-bitmap '(gatsby:double-error-bitmap compilation-warning)
      flymake-error-bitmap '(gatsby:double-error-bitmap compilation-error))

(dolist (face '(flymake-note flymake-warning flymake-error))
  (set-face-attribute face nil :underline nil))

(advice-add #'flymake-eldoc-function :override #'ignore)

(use-package flymake-childframe
  :hook (flymake-mode . flymake-childframe-mode))

(setq flymake-childframe-prefix '((note . "[INFO]")
                                  (warning . "[WARN]")
                                  (error . "[ERR]")))

(ligature-set-ligatures 'flymake-childframe-buffer-mode
                        '("[INFO]" "[WARN]" "[ERR]"))

(use-package company)
(add-hook 'prog-mode-hook #'company-mode)

(setq company-idle-delay nil
      company-require-match 'never
      company-search-regexp-function #'company-search-words-in-any-order-regexp)

(defun gatsby:indent-or-complete ()
  "Tab for company, yas, and indentation.
  1, if nothing before the `point', insert `tab-width' number of spaces.
  2, if there is a yas-snippet, expand it.
  3, if 1/2 not satisfies, call `company-manual-begin'."
  (interactive)
  (if (looking-back "\\([[:space:]]+\\|^\\=\\)" (line-beginning-position)) ;; case 1
      (insert-tab)
    (unless (yas-expand) ;; case 2
      ;; case 3
      (unless (symbol-value company-search-mode)
        (company-filter-candidates)))))

(general-define-key :keymaps 'insert
  "<tab>" 'gatsby:indent-or-complete)

(defun gatsby:company-filter-delete ()
  "improve `company-search-delete-char'."
  (if (string= company-search-string "")
      (progn
        (company-search-abort)
        (call-interactively #'backward-delete-char-untabify)
        (company-filter-candidates))
    (let ((ss (substring company-search-string 0 -1)))
      (when company-search-filtering
        (company--search-update-predicate ss))
      (company--search-update-string ss))))

(advice-add #'company-search-delete-char :override #'gatsby:company-filter-delete)

(defun gatsby:company-filter-abort ()
  "Abort both the `company-search-mode' and the `company-mode'"
  (interactive)
  (ignore-errors (company-search-abort))
  (company-abort))

(general-define-key :keymaps 'company-active-map
  "M-j" 'company-select-next
  "M-k" 'company-select-previous
  "<tab>" 'company-complete-selection)

(general-define-key :keymaps 'company-search-map
  "M-j" 'company-select-next
  "M-k" 'company-select-previous
  "C-g" 'gatsby:company-filter-abort
  "<tab>" 'company-complete-selection)

(setq company-auto-commit-chars '(?\( ?. 44))

(defun gatsby:company-complete-and-insert-char (char)
  "Complete with the current selection and insert CHAR."
  (company-complete-selection)
  (insert (char-to-string char)))

;; bind auto complete chars in `company-search-map'
(--each company-auto-commit-chars
  (define-key company-search-map (char-to-string it)
    (lambda () (interactive) (gatsby:company-complete-and-insert-char it))))

(with-eval-after-load 'flymake
  (setq flymake-no-changes-timeout nil))

(setq company-show-numbers t
      company-tooltip-limit 10
      company-tooltip-align-annotations t
      company-selection-wrap-around t
      company-auto-commit t)

(setq company-dabbrev-downcase nil
      company-dabbrev-ignore-case nil
      company-dabbrev-code-other-buffers nil
      company-backends '((:separate company-capf company-yasnippet)
                         company-files
                         (company-dabbrev-code company-dabbrev)))

(use-package company-prescient :hook (company-mode . company-prescient-mode))

(use-package yasnippet
  :hook
  (company-mode . yas-reload-all)
  (company-mode . yas-minor-mode)
  :config
  (setq yas-triggers-in-field t)
  (defun gatsby:yas--clear-field-filter (cmd)
    "Clear field regardless of whether it has been modified or not.
  This make sure that if I backtab into a modified field I can still hit <Del> and delete the whole field."
    (let ((field (yas-current-field)))
      (when (and field
                 (eq (point) (marker-position (yas--field-start field))))
        cmd)))
  
  (advice-add #'yas--maybe-clear-field-filter :override #'gatsby:yas--clear-field-filter)
  
  (defun gatsby:yas-better-backspace ()
    "If `point' is at the beginning of an unmodified yas-field, delete the field, otherwise backwards delete char."
    (interactive)
    (cond ((yas--maybe-clear-field-filter t)
           (yas--skip-and-clear (yas-current-field)))
          (t (call-interactively #'backward-delete-char-untabify))))
  
  (general-define-key :keymaps 'yas-keymap "<backspace>" 'gatsby:yas-better-backspace)
  (add-to-list 'yas-prompt-functions #'completing-read))

(use-package eglot
  :custom-face
  ;; less invasive symbol highlight
  (eglot-highlight-symbol-face ((t :underline t))))

(setq eglot-stay-out-of '(company))

(use-package tree-sitter
  :hook
  (tree-sitter-mode . tree-sitter-hl-mode)
  (tree-sitter-mode . tree-sitter-fold-mode))

(use-package tree-sitter-langs)

(use-package tree-sitter-fold)

(use-package comint)

(defun gatsby:comint-goto-last-prompt ()
  "Goto current prompt and continue editting."
  (interactive)
  (goto-char (point-max))
  (evil-insert 1))

(defun gatsby:comint-cls ()
  "clear current REPL buffer."
  (interactive)
  (let ((comint-buffer-maximum-size 0))
    (comint-truncate-buffer)))

(defun gatsby:comint-return ()
  "<return> sends a newline character, and double <return> sends `comint-send-input'."
  (interactive)
  (let* ((text-before-point (buffer-substring (save-excursion (comint-bol)) (point)))
         (open-b (s-count-matches "\\[" text-before-point))
         (close-b (s-count-matches "\\]" text-before-point))
         (open-c (s-count-matches "{" text-before-point))
         (close-c (s-count-matches "}" text-before-point))
         (open-p (s-count-matches "(" text-before-point))
         (close-p (s-count-matches ")" text-before-point)))
    (if (or (eq last-command this-command)
            (and (= open-b close-b)
                 (= open-c close-c)
                 (= open-p close-p)))
        (call-interactively 'comint-send-input)
      (call-interactively 'newline))))

(defcustom gatsby:comint-repl-mode-alist nil
  "An alist of (code-buffer-mode . repl-mode)."
  :type 'alist
  :group 'comint)

(defvar-local gatsby:comint-repl-buffer nil
  "The repl associated to the current buffer.")

(defun gatsby:comint-associate-repl ()
  "Select a repl of mode REPL-MODE and associate the current buffer to that repl."
  (interactive)
  (let* ((repl-mode (cdr (assq major-mode gatsby:comint-repl-mode-alist)))
         (candidates (-map 'buffer-name
                           (--filter
                            (with-current-buffer it
                              (eq major-mode repl-mode))
                            (buffer-list))))
         (repl-name (completing-read "Choose REPL to associate to: "
                                     (or candidates (buffer-list)))))

    (setq gatsby:comint-repl-buffer (get-buffer repl-name))))

(general-define-key :keymaps 'comint-mode-map :states '(normal visual motion emacs insert) :prefix "C-c"
  "C-l" 'gatsby:comint-cls
  "C-c" 'comint-interrupt-subjob)

(general-define-key :keymaps 'comint-mode-map :states 'insert
  "<up>" 'comint-previous-matching-input-from-input
  "<down>" 'comint-next-matching-input-from-input
  "<return>" 'gatsby:comint-return)

(general-define-key :keymaps 'comint-mode-map :states '(normal motion visual insert emacs)
  "C-j" 'evil-window-down
  "C-d" 'evil-scroll-down)

(general-define-key :keymaps 'comint-mode-map :states '(normal motion visual)
  "<" 'comint-previous-prompt
  ">" 'comint-next-prompt
  "A" 'gatsby:comint-goto-last-prompt
  "H" 'comint-bol
  "SPC" 'nil)

(defcustom gatsby:comint-repl-function-alist nil
  "An alist of (code-buffer-mode . (function to call REPL . argument if any))."
  :type 'alist
  :group 'comint)

(defun gatsby:comint--start-repl (repl-fn &rest args)
  "Start a REPL in the background using REPL-FN with ARGS."
  (let ((code-buffer (current-buffer))
        (display-buffer-alist `(,(cons "*" (cons #'display-buffer-no-window nil)))))
    (let ((repl-buffer (apply repl-fn args)))
      (with-current-buffer code-buffer
        (setq-local gatsby:comint-repl-buffer repl-buffer)))))

(defun gatsby:comint--pop-to-repl ()
  "Switch to `gatsby:comint-repl-buffer' associated with the current buffer."
  (if (and gatsby:comint-repl-buffer
           (buffer-live-p gatsby:comint-repl-buffer))
      (progn
        (pop-to-buffer gatsby:comint-repl-buffer)
        (select-window (get-buffer-window gatsby:comint-repl-buffer)))
    (user-error "Buffer not associated with a REPL")))

(defun gatsby:comint-start-or-pop-to-repl ()
  "Start (or pop to the existing) repl buffer for the current buffer."
  (interactive)
  (unless (and gatsby:comint-repl-buffer
               (buffer-live-p gatsby:comint-repl-buffer))
    (apply #'gatsby:comint--start-repl
           (cdr (assq major-mode gatsby:comint-repl-function-alist))))
  (gatsby:comint--pop-to-repl))

(defun gatsby:comint--send-code-to-repl (send-fn string)
  "Send STRING using SEND-FN to the associated buffer for evaluation."
  (if gatsby:comint-repl-buffer
      (with-current-buffer gatsby:comint-repl-buffer
        (goto-char (point-max))
        (let ((bol (save-excursion
                     (comint-bol))))
          (delete-region bol (point-max)))
        (insert string)
        (funcall send-fn))
    (user-error "Associated REPL not found")))

(defun gatsby:comint--eval-region (send-fn beg end)
  (gatsby:comint--send-code-to-repl send-fn (buffer-substring-no-properties beg end))
  (deactivate-mark))

(defun gatsby:comint-eval-region-or-line ()
  (interactive)
  (if (region-active-p)
      (gatsby:comint--eval-region 'comint-send-input
                                  (region-beginning) (region-end))
    (gatsby:comint--send-code-to-repl 'comint-send-input
                                      (thing-at-point 'line 'no-properties))))

(defun gatsby:comint-eval-buffer ()
  (interactive)
  (gatsby:comint--send-code-to-repl
   'comint-send-input
   (buffer-substring-no-properties (point-min) (point-max))))

(defun gatsby:comint-exit-repl ()
  "When quitting repl buffer, reset `gatsby:comint-repl-buffer' for all associated code buffers."
  (interactive)
  (when (y-or-n-p "Really quit this REPL? ")
    (let ((repl-buffer (current-buffer)))
      (--each (--filter (with-current-buffer it (eq gatsby:comint-repl-buffer repl-buffer))
                        (buffer-list))
        (with-current-buffer it
          (setq-local gatsby:comint-repl-buffer nil))))

    (let ((process (get-buffer-process (current-buffer))))
      (set-process-query-on-exit-flag process nil)
      (when (process-live-p process)
        (delete-process process))
      (kill-buffer-and-window))))

(general-define-key :keymaps 'comint-mode-map :states '(normal motion visual) :prefix "SPC"
  "q" 'gatsby:comint-exit-repl)

(use-package jupyter

:custom-face
(jupyter-repl-traceback ((t (:extend t :background "firebrick")))))

(defun gatsby:jupyter-repl-cell-code ()
  "Return the code of the current cell, tweaked to stripped text properties to make sure things like `highlight-indent-guides' does not get picked up."
  (buffer-substring-no-properties
   (jupyter-repl-cell-code-beginning-position)
   (jupyter-repl-cell-code-end-position)))

(advice-add #'jupyter-repl-cell-code :override #'gatsby:jupyter-repl-cell-code)

(defun gatsby:jupyter--encode-before-eval (fn &rest args)
  "advice `jupyter-eval-string' to encode first the strings with utf-8."
  (let (str)
    (if (cdr args)
        (setq str (apply #'buffer-substring-no-properties (cdr args)))
      (setq str (car args)))
    (funcall fn (encode-coding-string str 'utf-8))))

(advice-add #'jupyter-eval-string :around #'gatsby:jupyter--encode-before-eval)

(advice-add #'jupyter-repl-isearch-setup :override #'ignore)

(advice-add #'jupyter-command :around #'envrc-propagate-environment)

(defun gatsby:jupyter--update-kernelspecs (&rest _)
  "Update kernelspecs before running any REPL."
  (jupyter-available-kernelspecs 'refresh))

(advice-add #'jupyter-run-repl :before #'gatsby:jupyter--update-kernelspecs)

(setq jupyter-repl-echo-eval-p t)

(setq jupyter-repl-maximum-size 12000)

(setq jupyter-repl-history-maximum-length 5000)

(defun gatsby:jupyter--pop-repl (&rest _)
  "Pop repl buffer, then go back to the code buffer."
  (let* ((code-buffer (current-buffer)))
    (jupyter-repl-pop-to-buffer)
    (switch-to-buffer-other-window code-buffer)))

(advice-add #'jupyter-eval-line-or-region :before #'gatsby:jupyter--pop-repl)

(defun gatsby:jupyter--deactivate-mark (&rest _)
  "Deactivate mark, use &rest to satisfies the number of arguments"
  (deactivate-mark))

(advice-add #'jupyter-eval-region :after #'gatsby:jupyter--deactivate-mark)

(defun gatsby:jupyter-goto-last-prompt ()
  "Goto current prompt and continue editting."
  (interactive)
  (goto-char (point-max))
  (evil-insert 1))

(general-define-key :keymaps 'jupyter-repl-mode-map :states '(normal visual motion)
  "A" #'gatsby:jupyter-goto-last-prompt
  "<" #'jupyter-repl-backward-cell
  ">" #'jupyter-repl-forward-cell
  "SPC" nil)

(general-define-key :keymaps 'jupyter-repl-mode-map :states '(normal visual motion) :prefix "C-c"
  "C-c" #'jupyter-repl-interrupt-kernel
  "C-l" #'jupyter-repl-clear-cells)

(general-define-key :keymaps 'jupyter-repl-mode-map :states '(normal visual motion) :prefix "SPC"
  "q" #'kill-buffer-and-window)

(general-define-key :keymaps 'jupyter-repl-mode-map :states 'insert
  "<up>" #'jupyter-repl-history-previous-matching
  "<down>" #'jupyter-repl-history-next-matching)

(defcustom gatsby:jupyter-repl-function-alist nil
  "An alist of (code-buffer-mode . action), where action can be:
- a string indicating the kernel name should be called in CODE-BUFFER-MODE
- a function with no argument that should be called to start the corresponding jupyter REPL in CODE-BUFFER-MODE"
  :type 'alist
  :group 'jupyter)

(defun gatsby:jupyter-start-or-switch-to-repl ()
  "Switch to REPL associated the current buffer.  If there is no REPL associated with the current buffer, start one according to KERNEL type."
  (interactive)
  (if (and jupyter-current-client
           (jupyter-kernel-alive-p jupyter-current-client))
      (jupyter-repl-pop-to-buffer)
    (let ((code-buffer (current-buffer))
          (major-mode-action (cdr (assq major-mode gatsby:jupyter-repl-function-alist))))
      (cond ((stringp major-mode-action)
             (jupyter-run-repl major-mode-action major-mode-action (current-buffer) nil t))
            ((functionp major-mode-action)
             (funcall major-mode-action))
            (t (call-interactively 'jupyter-run-repl)))
      (switch-to-buffer-other-window code-buffer))))

(add-hook 'jupyter-repl-mode-hook #'company-mode)

(add-to-list 'ligature-composition-table
             `(jupyter-repl-mode ,@(cdr (assq 'prog-mode ligature-composition-table))))

(defun gatsby:jupyter--register-local-kernels (kernel-names)
  ;; fix stata kernel issues
  (when (and (member "stata" kernel-names)
             (not (boundp 'inferior-STA-program-name)))
    (setq inferior-STA-program-name "stata-mp"))

  ;; load languages
  (let* ((kernel-names '("python3" "stata"))
         (jupyter '(jupyter . t))
         (kernels `(,@(--map `(,(intern it) . t) kernel-names)))
         (interpreters (if (assq 'jupyter org-babel-load-languages)
                           `(,@(butlast org-babel-load-languages)
                             ,@kernels
                             ,jupyter)
                         `(,@org-babel-load-languages
                           ,@kernels
                           ,jupyter))))
    (org-babel-do-load-languages 'org-babel-load-languages interpreters)))

(defun gatsby:jupyter--update-available-interpreters (kernel-names)
  (setq-local gatsby:org-babel-available-interpreters
              `(,@gatsby:org-babel-default-interpreters
                ,@(--map (format "jupyter-%s" it) kernel-names))))

(make-variable-buffer-local 'ob-async-no-async-languages-alist)

(defun gatsby:jupyter--enable-async-block (kernel-names)
  ;; let jupyter manager its own async state
  (setq-local ob-async-no-async-languages-alist
              `(,@(--map (format "jupyter-%s" it) kernel-names)))

  ;; set jupyter languages default header argument
  (--each kernel-names
    (eval `(setq ,(intern (format "org-babel-default-header-args:jupyter-%s" it))
                 (quote ((:async . "yes")
                         (:session . ,it)
                         (:kernel . ,it)))))))

(defun gatsby:jupyter--pre-are-local-env-for-org ()
  (when (executable-find "jupyter")
    (let* ((_kernels (jupyter-available-kernelspecs 'refresh))
           (kernel-names (--map (plist-get (cddr it) :language) _kernels)))
      (gatsby:jupyter--register-local-kernels kernel-names)
      (gatsby:jupyter--update-available-interpreters kernel-names)
      (gatsby:jupyter--enable-async-block kernel-names))))

(add-hook 'gatsby:org-babel-hook #'gatsby:jupyter--pre-are-local-env-for-org)

(use-package ein)

(setq ein:output-area-inlined-images t)

(use-package flyspell-correct)

(add-hook 'text-mode-hook #'flyspell-mode)
(add-hook 'prog-mode-hook #'flyspell-prog-mode)

(defun gatsby:style-flyspell-correct-selectrum (candidates word)
  "Run `completing-read' for the given CANDIDATES

List of CANDIDATES is given by flyspell for the WORD."
  (let* ((selectrum-should-sort nil)
         (save "[SAVE]")
         (accept-session "[ACCEPT (session)]")
         (accept-buffer "[ACCEPT (buffer)]")
         (skip "[SKIP]")
         (result (completing-read
                  (format "Correcting '%s': " word)
                  (append (list save accept-session accept-buffer skip)
                          candidates)
                  nil nil nil nil (car candidates))))
    (cond
     ((string= result save)
      (cons 'save word))
     ((string= result accept-session)
      (cons 'session word))
     ((string= result accept-buffer)
      (cons 'buffer word))
     ((string= result skip)
      (cons 'skip word))
     (t
      result))))

(setq flyspell-correct-interface #'gatsby:style-flyspell-correct-selectrum)

(setq langtool-bin "languagetool-commandline")
(use-package langtool)

(defun gatsby:langtool--display-message (overlays)
  (let ((msg (langtool-details-error-message overlays)))
    (eldoc-box--eldoc-message-function msg)))

(setq langtool-autoshow-message-function #'gatsby:langtool--display-message)

(defvar gatsby:langtool--in-process nil
  "Non-nil means we are in the process of checking grammar.")

(defun gatsby:langtool-toggle (&optional lang)
  "Toggle languagetool check."
  (interactive (when current-prefix-arg
                 (list (langtool-read-lang-name))))
  (if gatsby:langtool--in-process
      (progn
        (langtool-check-done)
        (setq gatsby:langtool--in-process nil))
    (langtool-check-buffer lang)
    (setq gatsby:langtool--in-process t)))

(add-hook 'langtool-noerror-hook (lambda (&rest _) (setq gatsby:langtool--in-process nil)))

(general-define-key :keymaps '(motion normal visual) :prefix "SPC"
  "cc" 'flyspell-correct-wrapper
  "cg" 'gatsby:langtool-toggle)

(use-package magit)

(add-to-list 'evil-motion-state-modes 'magit-status-mode)
(add-to-list 'evil-motion-state-modes 'magit-diff-mode)
(add-to-list 'evil-motion-state-modes 'magit-log-mode)
(add-to-list 'evil-motion-state-modes 'magit-revision-mode)
(add-to-list 'evil-motion-state-modes 'magit-process-mode)

(evil-set-initial-state 'git-commit-mode 'insert)

(defcustom magit-push-protected-branch nil
  "When set, ask for confirmation before pushing to this branch (e.g. master).  Set this in .dir-locals.el"
  :type 'list
  :safe 'listp
  :group 'magit)

(defun magit-push--protected-branch (magit-push-fun &rest args)
  "Ask for confirmation before pushing a protected branch."
  (if (member (magit-get-current-branch) magit-push-protected-branch)
      ;; Arglist is (BRANCH TARGET ARGS)
      (if (yes-or-no-p (format "Push to protected branch %s? " (magit-get-current-branch)))
          (apply magit-push-fun args)
        (error "Push aborted by user"))
    (apply magit-push-fun args)))

(advice-add 'magit-push-current-to-pushremote :around #'magit-push--protected-branch)
(advice-add 'magit-push-current-to-upstream :around #'magit-push--protected-branch)

(magit-add-section-hook 'magit-status-sections-hook
                        'magit-insert-recent-commits
                        'magit-insert-unpushed-to-upstream-or-recent
                        'replace)

(magit-add-section-hook 'magit-status-sections-hook
                        'magit-insert-unpushed-to-upstream
                        'magit-insert-unpushed-to-pushremote
                        'append)

(defun gatsby:vcs-visit-thing-at-point ()
  "Get file at point in magit buffers."
  (interactive)
  (cond ((magit-section-match '([file] [hunk]))
         (let ((file (magit-file-at-point t)))
           (unless file
             (error "No file at point"))
           (magit-diff-visit-file--internal file nil #'switch-to-buffer-other-window)))
        ((magit-section-match [commit])
         ;; commits: show the commit details
         (call-interactively #'magit-show-commit))
        ((magit-section-match [* error])
         (magit-process-buffer))
        ((magit-section-match [stash])
         (call-interactively #'magit-ediff-show-stash))
        ((and (magit-section-match '(issue pullreq))
              (featurep 'forge))
         ;; for `forge-issue' and `forge-pullreq' block, visit corresponding issue
         (call-interactively #'forge-visit-topic))
        ;; fallback - `magit-visit-thing'
        (t 'magit-visit-thing)))

(general-define-key :keymaps '(magit-status-mode-map magit-diff-mode-map magit-log-mode-map)
                    :states '(motion normal visual)
                    "RET" #'gatsby:vcs-visit-thing-at-point)

(general-define-key :keymaps '(magit-status-mode-map magit-diff-mode-map magit-log-mode-map)
                    :states '(motion normal visual)
                    "SPC" nil
                    ">" 'magit-section-forward-sibling
                    "<" 'magit-section-backward-sibling
                    "zo" 'magit-section-show
                    "zc" 'magit-section-hide
                    "`" 'magit-dispatch)

(general-define-key :keymaps '(magit-status-mode-map
                               magit-diff-mode-map
                               magit-log-mode-map
                               magit-revision-mode-map)
                    :states '(motion normal)
                    :prefix "SPC"
                    "r" (lambda () (interactive) (magit-refresh-buffer)))

(general-define-key :keymaps 'magit-status-mode-map :states '(motion normal)
  "d" 'magit-discard
  "E" 'magit-ediff
  "c" 'magit-commit
  "p" 'magit-push
  "f" 'magit-fetch
  "F" 'magit-pull)

(general-define-key :keymaps '(motion normal visual) :prefix "SPC"
  "gg" #'magit-status
  "gd" #'magit-ediff-show-working-tree
  "gl" #'magit-log-buffer-file
  "gb" #'magit-blame)

(use-package magit-delta)

(add-hook 'magit-mode-hook #'magit-delta-mode)

(setq magit-delta-delta-args `("--max-line-distance" "0.6"
                               "--24-bit-color" "always"
                               "--minus-color=#420000"
                               "--plus-color=#006910"
                               "--plus-emph-color=#00b300"
                               "--color-only"))

(use-package git-rebase)

(add-to-list 'evil-motion-state-modes 'git-rebase-mode)

(general-define-key :keymaps 'git-rebase-mode-map :states 'motion
  "p" 'git-rebase-pick
  "e" 'git-rebase-edit
  "l" 'git-rebase-label
  "r" 'git-rebase-reword
  "s" 'git-rebase-squash
  "d" 'git-rebase-kill-line
  "M-j" 'git-rebase-move-line-down
  "M-k" 'git-rebase-move-line-up)

(use-package forge)

(setq forge-topic-list-limit '(60 . -1))

(general-define-key :keymaps 'magit-status-mode-map
  "@" 'forge-dispatch)

(general-define-key :keymaps 'forge-topic-mode-map :states '(normal visual motion)
  "<return>" 'gatsby:vcs-visit-thing-at-point
  "zo" 'magit-section-show
  "zc" 'magit-section-hide)

(general-define-key :keymaps 'forge-topic-mode-map :states '(normal visual motion) :prefix "SPC"
  "re" 'magit-edit-thing
  "rr" 'forge-create-post)

(use-package ediff)

(add-to-list 'evil-motion-state-modes 'ediff-mode)

(setq ediff-window-setup-function 'ediff-setup-windows-plain)

(defun gatsby:vcs-ediff-scroll-left (&optional arg)
  "Scroll left."
  (interactive "P")
  (let ((last-command-event ?>))
    (ediff-scroll-horizontally arg)))

(defun gatsby:vcs-ediff-scroll-right (&optional arg)
  "Scroll right."
  (interactive "P")
  (let ((last-command-event ?<))
    (ediff-scroll-horizontally arg)))

(defun gatsby:vcs-ediff-scroll-up (&optional arg)
  "Scroll up by half of a page."
  (interactive "P")
  (let ((last-command-event ?V))
    (ediff-scroll-vertically arg)))

(defun gatsby:vcs-ediff-scroll-down (&optional arg)
  "Scroll down by half of a page."
  (interactive "P")
  (let ((last-command-event ?v))
    (ediff-scroll-vertically arg)))

(defun gatsby:vcs-ediff-scroll-down-1 ()
  "Scroll down by a line."
  (interactive)
  (let ((last-command-event ?v))
    (ediff-scroll-vertically 1)))

(defun gatsby:vcs-ediff-scroll-up-1 ()
  "Scroll down by a line."
  (interactive)
  (let ((last-command-event ?V))
    (ediff-scroll-vertically 1)))

(defun gatsby:vcs-ediff-first-difference ()
  "Jump to first difference."
  (interactive)
  (ediff-jump-to-difference 1))

(defun gatsby:vcs-ediff-last-difference ()
  "Jump to last difference."
  (interactive)
  (ediff-jump-to-difference ediff-number-of-differences))

(defun gatsby:vcs-ediff-modify-keys ()
  "Due to the wired way `ediff-mode' sets up its keymap, need to wrap this in a function and run it in `ediff-keymap-setup-hook'."
  (general-define-key
   :keymaps 'ediff-mode-map
   :states 'motion
   "SPC" nil
   "?" 'ediff-toggle-help
   "n" 'ediff-next-difference
   "N" 'ediff-previous-difference
   "G" 'ediff-jump-to-difference
   "gg" 'gatsby:vcs-ediff-first-difference

   "j" 'gatsby:vcs-ediff-scroll-down-1
   "k" 'gatsby:vcs-ediff-scroll-up-1
   "h" 'gatsby:vcs-ediff-scroll-left
   "l" 'gatsby:vcs-ediff-scroll-right
   "C-d" 'gatsby:vcs-ediff-scroll-down
   "C-u" 'gatsby:vcs-ediff-scroll-up

   "a" 'ediff-copy-A-to-B
   "b" 'ediff-copy-B-to-A

   "C-e" 'ediff-next-difference
   "C-y" 'ediff-previous-difference

   "q" 'ediff-quit)

  ;; fool-proving
  (general-define-key
   :keymaps 'ediff-mode-map
   :states 'motion
   :prefix "SPC"
   "q" 'ediff-quit)

  ;; if it is a three-window job
  (unless ediff-3way-comparison-job
    (general-define-key
     :keymaps 'ediff-mode-map
     :states 'motion
     "a" 'ediff-copy-A-to-C
     "b" 'ediff-copy-B-to-C
     "+" 'ediff-combine-diffs)))

(add-hook 'ediff-keymap-setup-hook #'gatsby:vcs-ediff-modify-keys)

(use-package projectile
  :hook
  (after-init . projectile-mode)
  :init
  (defun gatsby:projectile-find-file (&optional args)
    "Call `projectile-find-file', and pass prefix ARGS to it.
  If no project is found at `default-directory', call `find-file' instead."
    (interactive "P")
    (if (projectile-project-root)
        (projectile--find-file args)
      (call-interactively #'find-file)))
  
  (advice-add #'projectile-find-file :override #'gatsby:projectile-find-file)
  :general
  (:keymaps '(normal motion)
   :prefix "SPC"
   "op" #'projectile-switch-project
   "of" #'projectile-find-file))

(use-package deadgrep)

(defun gatsby:visual-deadgrep (beg end)
  "use `deadgrep' to search visually selected text."
  (interactive "r")
  (deadgrep (buffer-substring-no-properties beg end)))

(defun gatsby:deadgrep-refine-search ()
  (interactive)
  (deadgrep--search-term 'ignore))

(general-define-key :keymaps 'deadgrep-mode-map :states 'emacs
  "j" #'deadgrep-forward
  "J" #'deadgrep-forward-filename
  "k" #'deadgrep-backward
  "K" #'deadgrep-backward-filename
  "r" #'deadgrep-restart
  "s" #'gatsby:deadgrep-refine-search)

(add-to-list 'evil-emacs-state-modes 'deadgrep-mode)

(general-define-key :keymaps '(normal motion) :prefix "SPC"
  "og" #'deadgrep)

(general-define-key :keymaps 'visual :prefix "SPC"
  "og" #'gatsby:visual-deadgrep)

(use-package envrc)
(add-hook 'after-init-hook #'envrc-global-mode)

(defun gatsby:envrc--maybe-reload ()
  "run `envrc-reload' if the current buffer name is one of \"shell.nix\", \"default.nix\", or \"flake.nix\"."
  (when (and (member (f-filename (buffer-file-name)) '("shell.nix" "default.nix" "flake.nix"))
             (member ".envrc" (--map (f-base it) (f-files default-directory))))
    (envrc-reload)))

(defun gatsby:envrc--setup-update-hook ()
  (add-hook 'after-save-hook #'gatsby:envrc--maybe-reload nil t))

(add-hook 'nix-mode-hook #'gatsby:envrc--setup-update-hook)

(advice-add #'executable-find :around #'envrc-propagate-environment)

;; mouse face for envrc-lighter
(defun gatsby:envrc--envrc-lighter ()
  "`envrc--lighter' with mouse hover showing current root directory"
  (let ((root (or (f-traverse-upwards
                   (lambda (dir) (f-exists-p (format "%s/.envrc" dir))))
                  "no direnv environment")))
    `("[e:"
      (:propertize ,(symbol-name envrc--status)
       face
       ,(pcase envrc--status
          (`on 'envrc-mode-line-on-face)
          (`error 'envrc-mode-line-error-face)
          (`none 'envrc-mode-line-none-face))
       mouse-face mode-line-highlight
       help-echo ,root
       )
      "]")))

(setq gatsby:right-mode-line `((:eval (gatsby:envrc--envrc-lighter)) " " ,@gatsby:right-mode-line))

(defun gatsby:envrc-edit-or-init ()
  "Update or init a nix-direnv environment in the current `default-directory'."
  (interactive)
  (if-let* ((root (envrc--find-env-dir)))
      (let ((shell (format "%sshell.nix" root))
            (default (format "%sdefault.nix" root))
            (flake (format "%sflake.nix" root)))
        (find-file-other-window (completing-read
                                 (format "direnv environment found at %s, openning: " root)
                                 (--filter (f-exists-p it) `(,shell ,default ,flake)))))
    (gatsby:envrc-init-direnv default-directory)))

(defun gatsby:envrc-init-direnv (root)
  "Initialize a nix-direnv environment in ROOT directory."
  (interactive (list (read-file-name "Select the root directory: "
                                     default-directory
                                     nil
                                     nil
                                     nil
                                     'directory-name-p)))
  ;; 1. put use_nix in .envrc file
  (with-temp-buffer
    (insert "use flake\n")
    (write-file (format "%s.envrc" root) nil))
  ;; 2. init (and open) a shell.nix file with basic structure
  (f-touch (format "%sflake.nix" root))
  ;; ask if want to allow
  (when (and (eq envrc--status 'error)
             (y-or-n-p (format "%s is not allowed by direnv, allowing it?")))
    (envrc-allow))
  (find-file-other-window (format "%sflake.nix" root))
  (yas-expand-snippet (yas-lookup-snippet "new-shell"))
  (evil-insert-state))

(defun gatsby:envrc-log-buffer ()
  "Switch to `*envrc*' buffer."
  (interactive)
  (with-current-buffer "*envrc*"
    (goto-char (point-max))
    (goto-char (or (re-search-backward "^====" nil t) (point-min))))
  (switch-to-buffer-other-window "*envrc*"))

(defun gatsby:envrc--unkillable-log-buffer ()
  (if (string= (buffer-name (current-buffer)) "*envrc*")
      (progn
        (delete-window (get-buffer-window "*envrc*"))
        nil)
    t))

(add-hook 'kill-buffer-query-functions #'gatsby:envrc--unkillable-log-buffer)

(add-to-list 'evil-motion-state-modes 'special-mode)

(general-define-key :keymaps 'special-mode-map :states 'motion
  "q" 'delete-window)

(general-define-key :keymaps '(normal visual motion) :prefix "SPC"
  "ne" #'gatsby:envrc-edit-or-init
  "nn" #'envrc-reload
  "nd" #'envrc-deny
  "na" #'envrc-allow
  "nl" #'gatsby:envrc-log-buffer)

(defun gatsby:dired--turn-off-line-break ()
  (visual-line-mode -1)
  (setq truncate-lines t))

(add-hook 'dired-mode-hook #'gatsby:dired--turn-off-line-break)

(add-to-list 'evil-motion-state-modes 'dired-mode)

(use-package dired)

(setq dired-listing-switches "-lh")

(defun gatsby:dired-toggle-hide ()
  "Toggle whether to show hidden files."
  (interactive)
  (let* ((switches dired-actual-switches)
         (new-switches (if (string-match "a" dired-actual-switches)
                           (replace-regexp-in-string "a" "" dired-actual-switches)
                         (concat dired-actual-switches "a"))))
    (setq-local dired-actual-switches new-switches)
    (revert-buffer)))

(general-define-key :keymaps 'dired-mode-map :states 'motion
  "h" #'gatsby:dired-toggle-hide
  "r" #'revert-buffer)

(general-define-key :keymaps 'dired-mode-map :states 'motion
  ;; sort
  "s" 'dired-sort-toggle-or-edit

  ;; movement
  "j" 'dired-next-line
  "k" 'dired-previous-line
  "J" (lambda () (interactive) (dired-next-line 3))
  "K" (lambda () (interactive) (dired-previous-line 3))
  "<backspace>" 'dired-up-directory

  ;; files
  "<return>" 'dired-find-file
  "<M-return>" 'dired-find-file-other-window
  "f" 'find-file
  "F" 'dired-create-directory
  "t" 'dired-show-file-type
  "y" 'dired-copy-filename-as-kill)

(general-define-key :keymaps '(motion normal visual) :prefix "SPC"
  "od" (lambda () (interactive) (dired default-directory)))

(use-package dired-rainbow
  :after dired
  :config
  (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
  (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
  (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
  (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
  (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
  (dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
  (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
  (dired-rainbow-define log "#c17d11" ("log"))
  (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
  (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
  (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
  (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
  (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
  (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
  (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
  (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
  (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
  (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
  (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*")
  (dired-rainbow-define-chmod directory "#6cb2eb" "d.*"))

(use-package dired-collapse :hook (dired-mode . dired-collapse-mode))

(use-package elisp-mode)

(defun gatsby:lisp--set-tab-width ()
  (setq-local tab-width 2))

(add-hook 'emacs-lisp-mode-hook #'gatsby:lisp--set-tab-width)

(use-package ielm
  :init
  (defun gatsby:ielm-repl ()
    "Start an ielm REPL."
    (interactive)
    (let* ((buf (get-buffer-create "*ielm*")))
      (unless (comint-check-proc buf)
        (with-current-buffer buf
          (inferior-emacs-lisp-mode)))
      buf))
  
  (add-to-list 'gatsby:comint-repl-function-alist '(emacs-lisp-mode gatsby:ielm-repl))
  (add-to-list 'gatsby:comint-repl-function-alist '(lisp-interaction-mode gatsby:ielm-repl))
  
  (add-to-list 'gatsby:comint-repl-mode-alist '(emacs-lisp-mode . inferior-emacs-lisp-mode))
  (add-to-list 'gatsby:comint-repl-mode-alist '(lisp-interaction-mode . inferior-emacs-lisp-mode))
  :config
  (add-hook 'inferior-emacs-lisp-mode-hook #'company-mode)
  (defun gatsby:ielm--eval-input ()
    (ielm-eval-input ielm-input))
  
  (defun gatsby:ielm-return ()
    (interactive)
    (advice-add #'comint-send-input :after #'gatsby:ielm--eval-input)
    (call-interactively #'gatsby:comint-return)
    (advice-remove #'comint-send-input #'gatsby:ielm--eval-input))
  
  (general-define-key :keymaps 'inferior-emacs-lisp-mode-map :states 'insert
    "<return>" #'gatsby:ielm-return)
  (defun gatsby:lisp-eval-region-or-sexp ()
    "Evaluate the selected region if in visual state. Otherwise evaluate the sexp before point."
    (interactive)
    (if (region-active-p)
        (gatsby:comint--eval-region 'ielm-send-input (region-beginning) (region-end))
      (save-excursion
        (backward-sexp)
        (gatsby:comint--send-code-to-repl 'ielm-send-input (thing-at-point 'sexp)))))
  (general-define-key :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map) :states '(motion normal visual) :prefix "SPC"
    "rr" #'gatsby:lisp-eval-region-or-sexp
    "rb" #'gatsby:comint-eval-buffer
    "rz" #'gatsby:comint-associate-repl
    "ro" #'gatsby:comint-start-or-pop-to-repl))

(use-package helpful)

(add-to-list 'evil-motion-state-modes 'helpful-mode)

(general-define-key :keymaps 'helpful-mode-map :states 'motion :prefix "SPC"
  "q" #'kill-buffer-and-window)

(general-define-key :keymaps '(motion normal visual) :prefix "SPC"
  "hf" 'helpful-callable
  "hk" 'helpful-key
  "hv" 'helpful-variable
  "hm" 'describe-mode)

(use-package aggressive-indent
  :hook (emacs-lisp-mode . aggressive-indent-mode))

(use-package easy-escape
  :hook ((emacs-lisp-mode ielm-mode) . easy-escape-minor-mode))

(use-package python
  :mode ("\\.py'" . python-mode)
  :hook
  (python-mode . gatsby:python--set-indent-width)
  (python-mode . eglot-ensure)
  (python-mode . tree-sitter-mode)
  :init
  (defun gatsby:python--set-indent-width ()
    (setq-local tab-width 4))
  (setf (cdr (assq 'python-mode eglot-server-programs)) '("pyright-langserver" "--stdio"))
  :config
  (defun gatsby:python-start-repl ()
    "Infer python versions from shebang.  If there is no shebang, promote the user for python's version."
    (let* ((shebang (save-excursion (goto-char 1) (thing-at-point 'line)))
           (kernel (if (string-match "#!/usr/bin/env\s+\\(python.?\\)" (or shebang ""))
                       (match-string 1 shebang)
                     (completing-read "Cannot infer python interpreter, please select: "
                                      '("python2" "python3")))))
      (jupyter-run-repl kernel kernel (current-buffer) nil t)))
  
  (add-to-list 'gatsby:jupyter-repl-function-alist '(python-mode . gatsby:python-start-repl))
  (defun gatsby:python--dedent-string (string)
    "remove the comment indentation of STRING."
    (let ((strings (split-string string "\n")))
      (if (cdr strings)
          ;; multiline, need to remove indentation
          (let ((indent (if (string-match "^[\t ]+" (car strings))
                            (length (match-string 0 (car strings)))
                          0)))
            (s-join "\n"
                    (--map (if (s-prefix-p (s-repeat indent " ") it)
                               (substring it indent)
                             "")
                           strings)))
        string)))
  
  (defun gatsby:python-eval-region-or-line ()
    "If region is active, eval current region, otherwise eval current line."
    (interactive)
    (let* ((region (if (use-region-p)
                       (list (region-beginning) (region-end))
                     (list (line-beginning-position) (line-end-position))))
           (string (gatsby:python--dedent-string (apply
                                                  #'buffer-substring-no-properties
                                                  region))))
      (jupyter-eval-string string)
      (deactivate-mark)))
  :general
  (:states '(motion normal visual)
   :keymaps 'python-mode-map
   :prefix "SPC"
   "rb" #'jupyter-eval-buffer
   "rr" #'gatsby:python-eval-region-or-line
   "ro" #'gatsby:jupyter-start-or-switch-to-repl
  
   "rz" #'jupyter-repl-associate-buffer
   "rZ" #'jupyter-repl-restart-kernel)
  
  (:states 'visual
   :keymaps 'python-mode-map
   [remap evil-shift-left] #'python-indent-shift-left
   [remap evil-shift-right] #'python-indent-shift-right))

(setq python-indent-offset 4
      python-indent-guess-indent-offset-verbose nil)

(use-package stata-mode
  :mode ("\\.do'" . stata-mode)
  :config
  (add-to-list 'gatsby:jupyter-repl-function-alist '(stata-mode . "stata"))
  :general
  (:states '(motion normal visual)
   :keymaps 'stata-mode-map
   :prefix "SPC"
   "rb" #'jupyter-eval-buffer
   "rr" #'jupyter-eval-line-or-region
   "ro" #'gatsby:jupyter-start-or-switch-to-repl
  
   "rz" #'jupyter-repl-associate-buffer
   "rZ" #'jupyter-repl-restart-kernel))

(use-package ess
  :hook
  (ess-r-mode . eglot-ensure)
  (ess-r-mode . tree-sitter-mode)
  (ess-r-mode . gatsby:tree-sitter-load-r)
  :config
  (add-to-list 'gatsby:jupyter-repl-function-alist '(ess-r-mode . "irkernel"))
  (defun gatsby:r-pipe ()
    "Insert tidyverse pipe symbol %>%."
    (interactive)
    (insert "%>%")
    (reindent-then-newline-and-indent))
  (defun gatsby:r-assign-or-pipe ()
    "If the last non space character before `point' is \"=\", replace the equal sign with the assign operator. Otherwise insert a pipe operator."
    (interactive)
    (if (re-search-backward "[[:space:]]*=[[:space:]]*\\=" (line-beginning-position) t)
        (progn (replace-match "") (call-interactively #'ess-insert-assign))
      (gatsby:r-pipe)))
  
  (general-define-key :keymaps 'ess-r-mode-map :states 'insert
    "M-RET" #'gatsby:r-assign-or-pipe)
  :general
  (:keymaps 'ess-r-mode-map
   :states '(motion normal visual)
   :prefix "SPC"
   "rb" #'jupyter-eval-buffer
   "rr" #'jupyter-eval-line-or-region
   "ro" #'gatsby:jupyter-start-or-switch-to-repl
  
   "rz" #'jupyter-repl-associate-buffer
   "rZ" #'jupyter-repl-restart-kernel))

(defun gatsby:tree-sitter-load-r ()
  ;; register ess-r-mode with r grammar
  (unless (assq 'ess-r-mode tree-sitter-major-mode-language-alist)
    (add-to-list 'tree-sitter-major-mode-language-alist '(ess-r-mode . r)))

  ;; register tree-sitter
  (tree-sitter-require 'r))

(use-package nix-mode
  :mode ("\\.nix\\'" "\\.nix.in\\'")
  :hook
  (nix-mode . eglot-ensure)
  ;; the order is important: `tree-sitter-mode' needs to be after
  ;; `install-and-load-nix'
  (nix-mode . tree-sitter-mode)
  (nix-mode . gatsby:tree-sitter-load-nix)
  :init
  (defun gatsby:nix-shell-in-storage (storage)
    "Open an eshell/vterm in the directory of STORAGE."
    (interactive (list (read-file-name "Select the package directory: "
                                       "/nix/store/"
                                       nil
                                       nil
                                       nil
                                       'directory-name-p)))
    (let ((default-directory storage))
      (if current-prefix-arg
          (gatsby:vterm-open-here)
        (gatsby:eshell-open-here))))
  
  (general-define-key :keymaps '(normal motion) :prefix "SPC"
    "ns" #'gatsby:nix-shell-in-storage)
  (add-to-list 'eglot-server-programs '(nix-mode . ("rnix-lsp")))
  :config
  (add-to-list 'gatsby:comint-repl-function-alist '(nix-mode gatsby:nix-repl))
  (add-to-list 'gatsby:comint-repl-mode-alist '(nix-mode . nix-repl-mode))
  
  (defun gatsby:nix-repl ()
    (let ((buf (get-buffer-create "*Nix-REPL*")))
      (unless (comint-check-proc buf)
        (nix--make-repl-in-buffer buf)
        (with-current-buffer buf (nix-repl-mode)))
      buf))
  
  (general-define-key :keymaps 'nix-mode-map :states '(normal visual) :prefix "SPC"
    "ro" #'gatsby:comint-start-or-pop-to-repl
    "rr" #'gatsby:comint-eval-region-or-line
    "rb" #'gatsby:comint-eval-buffer
    "rz" #'gatsby:comint-associate-nix-repl)
  (setq nix-nixfmt-bin "nixpkgs-fmt")
  
  (defun gatsby:nix--fmt-before-save ()
    (add-hook 'before-save-hook #'nix-format-buffer nil t))
  
  (add-hook 'nix-mode-hook #'gatsby:nix--fmt-before-save)
  (defun gatsby:nix--save-excrusion (fn &rest args)
    (let ((ori-point (point)))
      (apply fn args)
      (goto-char ori-point)))
  
  (advice-add #'nix-format-buffer :around #'gatsby:nix--save-excrusion)
  (defun gatsby:nix-snippet-update-body (regexp &rest updates)
    "Update the current content identified by REGEXP using UPDATES.
  
  REGEXP should contain 3 groups.  Group 1 is the beginning of the section.  Group
  2 is the current content.  Group 3 is the end of the section.
  
  UPDATE is either strings to be added to the current content, or a function that
  takes listified current content as the only argument and return a modified list
  of strings as the updated content.
  
  This function first separate the current content into a list of lines.  This
  list is then fed into `gatsby:nix-snippet--process-content' along with UPDATE.
  The content then gets updated and inserted back to the buffer.
  
  This function updates the BODY of a let block.  To update the BINDING of a let
  block, use `gatsby:nix-snippet-update-bind' instead.
  
  Return nil."
    (save-excursion
      (when (re-search-forward regexp nil 'no-error)
        (let* ((beg (match-end 1))
               (end (match-beginning 3))
               (content (-map #'s-trim (s-split "\n" (match-string 2) t)))
               (padding (make-string (+ tab-width (current-indentation)) ?\s)))
          (goto-char beg)
          (delete-region beg end)
          (insert "\n")
          (->> updates
            (gatsby:nix-snippet--process-content content)
            (--remove (string= it ""))
            (--map (concat padding it "\n"))
            (apply #'concat)
            insert))))
    nil)
  
  (defun gatsby:nix-snippet-update-inputs (&rest inputs)
    "Update the current content in flake inputs block using UPDATES.
  
  INPUTS should be strings defining new flakes inputs.
  
  Return nil."
    (save-excursion
      (goto-char (point-min))
      (re-search-forward "\\(?1:[[:space:]]*inputs = {\\)\\(?2:\\(.*\n\\)*?\\)\\(?3:[[:space:]]*};\\)")
      (let* ((beg (match-end 1))
             (end (match-beginning 3))
             (content (-map #'s-trim (s-split "\n" (match-string 2) t)))
             (padding (make-string (+ tab-width (current-indentation)) ?\s)))
        (goto-char beg)
        (delete-region beg end)
        (insert "\n")
        (->> inputs
          (gatsby:nix-snippet--process-content content)
          (--remove (string= it ""))
          (--map (concat padding it "\n"))
          (apply #'concat)
          insert)))
    nil)
  
  (defun gatsby:nix-snippet-update-bind (&rest updates)
    "Update the content of the current let bind with UPDATES.
  
  UPDATE is either strings to be added to the current content, or a function that
  takes listified current content as the only argument and return a modified list
  of strings as the updated content.
  
  This function first separate the current content into a list of node strings.  This
  list is then fed into `gatsby:nix-snippet--process-content' along with UPDATE.
  The content then gets updated and inserted back to the buffer.
  
  Return nil."
    (let* ((root (tree-sitter-node-at-point 'let))
           (node (tsc-get-nth-named-child root 0))
           (beg (1+ (tsc-node-end-position (tsc-get-nth-child root 0))))
           end content padding)
      (while (eq (tsc-node-type node) 'bind)
        (setq content `(,@content ,(tsc-node-text node))
              node (tsc-get-next-sibling node)
              end (tsc-node-end-position node)))
      (setq padding (progn (goto-char end)
                           (apply #'concat (-repeat (+ tab-width (current-indentation)) " "))))
      (goto-char beg)
      (delete-region beg (- end 2))
      (->> updates
        (gatsby:nix-snippet--process-content content)
        (--map (concat padding it "\n"))
        (apply #'concat)
        insert)
      (insert (substring padding 2)))
    (call-interactively #'evil-open-above)
    nil)
  
  (defun gatsby:nix-snippet--process-content (content updates)
    "Update CONTENT recursively using UPDATES.
  
  Elements of UPDATES can either be a function, which takes CONTENT as the
  only argument and returns an updated list of content, or a string.  In the
  latter case, the string will be simply appended to the end of CONTENT.
  
  Return the updated content."
    (let* ((updated (pcase (car updates)
                      ((pred functionp) (funcall (car updates) content))
                      ((pred stringp) `(,@content ,(car updates)))
                      (_ (user-error "UPDATES must be a function or a string"))))
           (next (cdr updates)))
      (if next
          (gatsby:nix-snippet--process-content updated next)
        updated)))
  
  (defmacro gatsby:nix-snippet--include-python-pkgs (&rest pkgs)
    `(lambda (content)
       (if-let* ((idx (--find-index (string-match "(python\\.withPackages (p: with p; \\[\\(?1:.*\\)]))" it) content))
                 (string (nth idx content)))
           (if (not (-difference (list ,@pkgs) (s-split "[[:space:]]+" (match-string 1 string) t)))
               content
             (-replace-at idx (format "(python.withPackages (p: with p; [ %s %s ]))"
                                      (match-string 1 string) (s-join " " (list ,@pkgs)))
                          content))
         `(,@content ,(format "(python.withPackages (p: with p; [ %s ]))" (s-join " " (list ,@pkgs)))))))
  (defun gatsby:nix-snippet--in-let-bind-p ()
    "Return t if `point' is inside a `let' bind block."
    (let* ((let-node (tree-sitter-node-at-point 'let))
           (in-node (tsc-get-prev-sibling (tsc-get-child-by-field let-node :body)))
           (beg (tsc-node-start-position let-node))
           (end (tsc-node-start-position in-node)))
      (and (< (point) end) (> (point) beg))))
  (defcustom gatsby:nix-snippets
    '(gatsby:nix-snippet-python gatsby:nix-snippet-r gatsby:nix-snippet-stata)
    "Snippets used in the `nix-mode'."
    :type '(repeat function)
    :group 'nix)
  
  (defun gatsby:nix-snippet-dispatcher ()
    "Use `completing-read' to select and insert snippets."
    (interactive)
    (call-interactively
     (intern
      (completing-read "Select snippet: "
                       gatsby:nix-snippets))))
  
  (general-define-key :keymaps 'nix-mode-map :states 'insert
    "<M-RET>" #'gatsby:nix-snippet-dispatcher)
  
  (defun gatsby:nix-snippet-python ()
    (interactive)
    ;; apply only when the cursor is inside a let bind block
    (when (gatsby:nix-snippet--in-let-bind-p)
      (gatsby:nix-snippet-update-bind
       "python = pkgs.python39;")
      (gatsby:nix-snippet-update-body
       "\\(?1:devShell\\(.*\n\\)*[[:space:]]*buildInputs = \\[\\)\\(?2:\\(.*\n\\)*\\)\\(?3:[[:space:]]*];\\)"
       "(python.withPackages (p: with p; [ jupyter ]))"
       "pkgs.nodePackages.pyright")))
  
  (defun gatsby:nix-snippet-r ()
    (interactive)
    (when (gatsby:nix-snippet--in-let-bind-p)
      (gatsby:nix-snippet-update-bind
       (lambda (content)
         (if (--filter (s-matches-p "^python[[:space:]]*=" it) content)
             content
           `(,@content "python = pkgs.python39;")))
       "rEnv = with pkgs; rWrapper.override {"
       "  packages = with rPackages; ["
       "    IRkernel"
       "    languageserver"
       "    tidyverse"
       "  ];"
       "};"
       "rKernel = pkgs.writeTextDir \"kernels/irkernel/kernel.json\""
       "  (builtins.toJSON {"
       "    display_name = \"R\";"
       "    language = \"R\";"
       "    argv = ["
       "      \"${rEnv}/bin/R\""
       "      \"--slave\""
       "      \"-e\""
       "      \"IRkernel::main()\""
       "      \"--args\""
       "      \"{connection_file}\""
       "    ];"
       "  });")
      (gatsby:nix-snippet-update-body
       "\\(?1:devShell\\(.*\n\\)*[[:space:]]*buildInputs = \\[\\)\\(?2:\\(.*\n\\)*\\)\\(?3:[[:space:]]*];\\)"
       (gatsby:nix-snippet--include-python-pkgs "jupyter")
       "rEnv"
       "rKernel")
      (gatsby:nix-snippet-update-body
       "\\(?1:devShell\\(.*\n\\)*[[:space:]]*shellHook = ''\\)\\(?2:\\(.*\n\\)*\\)\\(?3:[[:space:]]*'';\\)"
       "export JUPYTER_PATH=$JUPYTER_PATH''${JUPYTER_PATH:+:}${rKernel}")))
  
  (defun gatsby:nix-snippet-stata ()
    (interactive)
    (when (gatsby:nix-snippet--in-let-bind-p)
      (gatsby:nix-snippet-update-bind
       (lambda (content)
         (if (--filter (s-matches-p "^python[[:space:]]*=" it) content)
             content
           `(,@content "python = pkgs.python39;")))
       "stataKernel = python.pkgs.buildPythonPackage rec {"
       "  pname = \"stata_kernel\";"
       "  version = \"1.12.2\";"
       "  src = stata-kernel;"
       "  propagatedBuildInputs = with python.pkgs; ["
       "    beautifulsoup4"
       "    jupyter"
       "    pandas"
       "    packaging"
       "    pillow"
       "    pexpect"
       "    pygments"
       "    requests"
       "  ];"
       "  doCheck = false;"
       "  postInstall = ''"
       "    mkdir -p $out/kernels/stata_kernel"
       "    echo '${builtins.toJSON {"
       "      display_name = \"Stata\";"
       "      language = \"stata\";"
       "      argv = [ \"python\" \"-m\" \"stata_kernel\" \"-f\" \"{connection_file}\" ];"
       "    }}' > \$out/kernels/stata_kernel/kernel.json"
       "  '';"
       "};")
      (gatsby:nix-snippet-update-inputs
       "stata-kernel = {"
       "  url = \"github.com:kylebarron/stata_kernel\";"
       "  flake = false;"
       "};")
      (gatsby:nix-snippet-update-body
       "\\(?1:devShell\\(.*\n\\)*[[:space:]]*buildInputs = \\[\\)\\(?2:\\(.*\n\\)*\\)\\(?3:[[:space:]]*];\\)"
       (gatsby:nix-snippet--include-python-pkgs "jupyter" "stataKernel"))
      (gatsby:nix-snippet-update-body
       "\\(?1:devShell\\(.*\n\\)*[[:space:]]*shellHook = ''\\)\\(?2:\\(.*\n\\)*\\)\\(?3:[[:space:]]*'';\\)"
       "cat > ${projectRoot}/.stata_kernel.conf <<EOF"
       "  [stata_kernel]"
       "  stata_path = stata-bin"
       "  execution_mode = console"
       "  cache_directory = ~/.cache/stata_kernel_cache"
       "  graph_format = svg"
       "  graph_scale = 1"
       "  user_graph_keywords = coefplot,vioplot"
       "EOF"
       "export STATA_KERNEL_USER_CONFIG_PATH=${projectRoot}/.stata_kernel.conf"
       "export JUPYTER_PATH=$JUPYTER_PATH''${JUPYTER_PATH:+:}${stataKernel}"))))

(defun gatsby:tree-sitter-load-nix ()
  "Register nix grammar for tree-sitter if haven't done so."

  (unless (assq 'nix-mode tree-sitter-major-mode-language-alist)
    (add-to-list 'tree-sitter-major-mode-language-alist '(nix-mode . nix)))

  (tree-sitter-require 'nix))

(use-package markdown-mode)

(use-package man
  :hook
  (man-mode . outline-minor-mode)

  :general
  (:keymaps 'Man-mode-map
   :states 'motion
   "zc" #'outline-hide-entry
   "zo" #'outline-show-entry
   ">" #'outline-next-heading
   "<" #'outline-previous-heading)

  :config
  (defun gatsby:man--maybe-use-current-window (fn &rest args)
    "Use the current window to display the man buffer if in eshell mode. Respect `Man-notify-method' otherwise."
    (if (eq major-mode 'eshell-mode)
        (cl-letf (((symbol-function 'Man-notify-when-ready) 'switch-to-buffer))
          (apply fn args))
      (apply fn args)))
  
  (advice-add #'man :around #'gatsby:man--maybe-use-current-window))

(use-package auctex
  :custom
  (tex-fontify-script nil)
  (font-latex-fontify-script nil)
  (font-latex-fontify-sectioning 1.0)
  :custom-face
  (font-latex-italic-face ((t (:underline nil :inherit 'italic))))
  (font-latex-slide-title-face ((t (:height 1.0 :inherit 'font-lock-function-name-face))))
  (font-latex-sectioning-5-face ((t (:inherit 'default))))
  :hook
  (LaTeX-mode . TeX-PDF-mode)
  (LaTeX-mode . outline-minor-mode)
  (LaTeX-mode . eglot-ensure)
  (LaTeX-mode . company-mode)
  (LaTeX-mode . gatsby:latex--setup)
  :init
  (defun gatsby:latex--setup ()
    "Setup tab width and indentation rule for `LaTeX-mode'."
    (setq-local tab-width 2)
    (add-hook 'before-save-hook
              (lambda () (indent-region (point-min) (point-max))) nil t))
  :config
  (setq TeX-parse-self t
        TeX-auto-save t
        TeX-source-correlate-mode t
        TeX-source-correlate-start-server t
        LaTeX-command "latex -shell-escape")
  
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
  (setq TeX-outline-extra '(("^\\(% \\)?\\\\begin{frame}" 3)))
  (setq TeX-electric-math (cons "$" "$")
        LaTeX-electric-left-right-brace t
        LaTeX-syntactic-comments nil)
  
  (defun gatsby:latex-delete ()
    "Deleting the whole pair if in an empty pair, other wise delete the character on the left."
    (interactive)
    (let* ((old-point (point))
           (TeX-braces-association `(,@TeX-braces-association
                                     ("{" . "}")
                                     ("\\[" . "\\]")))
           (lbrace-pos (re-search-backward (rx (group-n 1 (= 1 (or "{" "[" "(")))
                                               (0+ space))
                                           nil t))
           lbrace)
      (if (not lbrace-pos)
          (call-interactively 'backward-delete-char-untabify)
        ;; deal with { and \{
        (setq lbrace (match-string 1))
        (when (TeX-escaped-p)
          (setq lbrace (concat TeX-esc lbrace))
          (backward-char))
        (let* ((rbrace (cdr (assoc lbrace TeX-braces-association)))
               (lmacro-regexp `(rx (= 1 ,TeX-esc (group-n 1 (or ,@(-map 'car LaTeX-left-right-macros-association)))) point))
               (lmacro-pos (re-search-backward (eval lmacro-regexp) nil t))
               (brace-start (point))
               lmacro rmacro)
          (if lmacro-pos
              (setq lmacro (match-string 1)
                    rmacro (cdr (assoc lmacro LaTeX-left-right-macros-association)))
            (setq rmacro ""
                  lmacro ""))
          (if (re-search-forward (eval `(rx point
                                            (opt ,TeX-esc)
                                            ,lmacro ,lbrace
                                            (0+ space)
                                            (opt ,TeX-esc)
                                            ,rmacro ,rbrace))
                                 nil t)
              (delete-region brace-start (point))
            (goto-char old-point)
            (call-interactively 'backward-delete-char-untabify))))))
  
  (general-define-key :keymaps 'LaTeX-mode-map :states 'insert
    "DEL" #'gatsby:latex-delete)
  (setq LaTeX-syntactic-comments nil
        LaTeX-item-indent 0)
  (setq TeX-view-program-selection '((output-pdf "Zathura")))
  :general
  (:keymaps 'LaTeX-mode-map :states 'normal :prefix "SPC"
    "rr" (lambda ()
           (interactive)
           (TeX-command-sequence '("LaTeX" "BibTeX" "LaTeX" "LaTeX" "View") t))
    "ro" (lambda ()
           (interactive)
           (TeX-command-sequence "View" t)))
  (:keymaps 'LaTeX-mode-map :states 'normal
   "<" #'outline-previous-heading
   ">" #'outline-next-heading))

(defun gatsby:update-home ()
  "Make an asynchronous process tangling, building and switch to `home-manager' configuration defined in `flake.nix'. Print stdout to `*flake-process*' buffer.

The exact configuration to be built is determined by the output of \"uname\". This flake currently support x86_64-linux and x86_64-darwin platforms.
"
  (interactive)
  (when (process-live-p "flake-process")
    (user-error "Another flake process is currently running, exiting"))

  (if (buffer-live-p (get-buffer "*flake-process*"))
      (with-current-buffer "*flake-process*"
        (let ((inhibit-read-only t))
          (delete-region (point-min) (point-max))))
    (with-current-buffer (get-buffer-create "*flake-process*")
      (special-mode)))

  (let ((exec-path `(,(projectile-root-bottom-up default-directory) ,@exec-path)))
    (make-process
     :name "flake-process"
     :buffer "*flake-process*"
     :command '("update-user-config")
     :filter
     (lambda (proc msg)
       (when (buffer-live-p (process-buffer proc))
         (with-current-buffer (process-buffer proc)
           (let ((moving (= (point) (process-mark proc)))
                 (inhibit-read-only t))
             (save-excursion
               (goto-char (process-mark proc))
               (insert (xterm-color-filter msg))
               (set-marker (process-mark proc) (point)))
             (if moving (goto-char (process-mark proc)))))))))

  (pop-to-buffer "*flake-process*"))

(defun gatsby:update-readme ()
  "Update README.org."
  (interactive)
  (let* ((source-file (expand-file-name "main.org" (projectile-root-bottom-up default-directory)))
         (readme-file (expand-file-name "README.org" (projectile-root-bottom-up default-directory)))
         (org-mode-hook nil))
    (save-excursion
      (find-file source-file)
      (goto-char (org-find-exact-headline-in-buffer "Overview"))
      (let* ((elem (org-element-at-point))
             (beg (org-element-property :begin elem))
             (end (org-element-property :contents-end elem)))
        (write-region beg end readme-file)))))
